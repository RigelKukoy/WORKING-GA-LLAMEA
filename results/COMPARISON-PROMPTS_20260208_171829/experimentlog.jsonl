{"method_name": "EoH", "problem_name": "MA_BBOB", "llm_name": "gemini-2.0-flash", "method": {"method_name": "EoH", "budget": 50, "kwargs": {"pop_size": 4}}, "problem": {"name": "MA_BBOB", "dims": [5], "training_instances": "range(0, 20)", "test_instances": "range(20, 120)", "budget_factor": 2000}, "llm": {"model": "gemini-2.0-flash", "code_pattern": "```(?:python)?\\n(.*?)\\n```", "name_pattern": "class\\s*(\\w*)(?:\\(\\w*\\))?\\:", "desc_pattern": "#\\s*Description\\s*:\\s*(.*)", "cs_pattern": "space\\s*:\\s*\\n*```\\n*(?:python)?\\n(.*?)\\n```"}, "solution": {"id": "6d0891c6-3601-47be-814a-bb3a56a6aff4", "fitness": 0.75694, "name": "SelfAdaptiveDifferentialEvolution", "description": "A self-adaptive Differential Evolution algorithm that adjusts both the crossover rate and the mutation factor based on the success rate of previous generations.", "code": "import numpy as np\n\nclass SelfAdaptiveDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=20, cr_init=0.5, f_init=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr_init = cr_init\n        self.f_init = f_init\n        self.lb = -5.0\n        self.ub = 5.0\n        self.cr_memory = np.ones(self.pop_size) * self.cr_init\n        self.f_memory = np.ones(self.pop_size) * self.f_init\n\n    def __call__(self, func):\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n        \n        evals = self.pop_size\n\n        while evals < self.budget:\n            for i in range(self.pop_size):\n                # Adaptation of F and CR\n                self.cr = np.random.normal(self.cr_memory[i], 0.1)\n                self.cr = np.clip(self.cr, 0.0, 1.0)\n                self.f = np.random.normal(self.f_memory[i], 0.3)\n                self.f = np.clip(self.f, 0.1, 1.0)\n\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = a + self.f * (b - c)\n                mutant = np.clip(mutant, self.lb, self.ub)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                f = func(trial)\n                evals += 1\n\n                if f < self.fitness[i]:\n                    delta_fitness = self.fitness[i] - f\n                    self.fitness[i] = f\n                    self.population[i] = trial\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                    \n                    # Update memory of F and CR based on success\n                    self.cr_memory[i] = 0.9 * self.cr_memory[i] + 0.1 * self.cr\n                    self.f_memory[i] = 0.9 * self.f_memory[i] + 0.1 * self.f\n                else:\n                    # Even if selection fails, slightly perturb the CR and F\n                    self.cr_memory[i] = 0.9 * self.cr_memory[i] + 0.1 * np.random.rand()\n                    self.f_memory[i] = 0.9 * self.f_memory[i] + 0.1 * np.random.rand()\n\n                if evals >= self.budget:\n                    break\n                    \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "", "error": "", "parent_ids": [], "operator": null, "metadata": {}, "task_prompt": ""}, "log_dir": "run-EoH-MA_BBOB-0", "seed": 0}
{"method_name": "EoH", "problem_name": "MA_BBOB", "llm_name": "gemini-2.0-flash", "method": {"method_name": "EoH", "budget": 50, "kwargs": {"pop_size": 4}}, "problem": {"name": "MA_BBOB", "dims": [5], "training_instances": "range(0, 20)", "test_instances": "range(20, 120)", "budget_factor": 2000}, "llm": {"model": "gemini-2.0-flash", "code_pattern": "```(?:python)?\\n(.*?)\\n```", "name_pattern": "class\\s*(\\w*)(?:\\(\\w*\\))?\\:", "desc_pattern": "#\\s*Description\\s*:\\s*(.*)", "cs_pattern": "space\\s*:\\s*\\n*```\\n*(?:python)?\\n(.*?)\\n```"}, "solution": {"id": "1d7768c1-167c-436d-8458-1a61a92a4958", "fitness": 0.67292, "name": "AdaptiveDE", "description": "# Description: An adaptive Differential Evolution (DE) algorithm with a self-adjusting mutation factor and population size reduction.\n# Code:\n```", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, mutation_factor=0.5, crossover_rate=0.7, reduction_factor=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.mutation_factor = mutation_factor\n        self.crossover_rate = crossover_rate\n        self.reduction_factor = reduction_factor\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)].copy()\n        self.budget -= self.pop_size\n\n    def evolve(self, func):\n        new_population = np.copy(self.population)\n        new_fitness = np.copy(self.fitness)\n        for i in range(self.pop_size):\n            if self.budget <= 0:\n                break\n\n            idxs = [idx for idx in range(self.pop_size) if idx != i]\n            a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n\n            # Adaptive mutation factor\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lb, self.ub)\n\n            # Crossover\n            cross_points = np.random.rand(self.dim) < self.crossover_rate\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial_vector = np.where(cross_points, mutant, self.population[i])\n\n            f_trial = func(trial_vector)\n            self.budget -= 1\n\n            if f_trial < self.fitness[i]:\n                new_population[i] = trial_vector\n                new_fitness[i] = f_trial\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = trial_vector.copy()\n\n        self.population = new_population\n        self.fitness = new_fitness\n        \n        # Population size reduction (optional)\n        if self.budget > 0 and len(self.population) > 10 and np.random.rand() < 0.1:\n            indices = np.argsort(self.fitness)[::-1] #sort from worst to best\n            remove_count = int(len(self.population) * (1 - self.reduction_factor))\n            indices_to_keep = indices[:-remove_count] #indices of the best solutions\n            \n            self.population = self.population[indices_to_keep]\n            self.fitness = self.fitness[indices_to_keep]\n            self.pop_size = len(self.population)\n\n    def __call__(self, func):\n        self.initialize_population(func)\n        while self.budget > 0:\n            self.evolve(func)\n            # Adapt mutation factor\n            if np.random.rand() < 0.2:\n                self.mutation_factor = np.random.uniform(0.3, 0.9)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "", "error": "", "parent_ids": [], "operator": null, "metadata": {}, "task_prompt": ""}, "log_dir": "run-EoH-MA_BBOB-1", "seed": 1}
{"method_name": "EoH", "problem_name": "MA_BBOB", "llm_name": "gemini-2.0-flash", "method": {"method_name": "EoH", "budget": 50, "kwargs": {"pop_size": 4}}, "problem": {"name": "MA_BBOB", "dims": [5], "training_instances": "range(0, 20)", "test_instances": "range(20, 120)", "budget_factor": 2000}, "llm": {"model": "gemini-2.0-flash", "code_pattern": "```(?:python)?\\n(.*?)\\n```", "name_pattern": "class\\s*(\\w*)(?:\\(\\w*\\))?\\:", "desc_pattern": "#\\s*Description\\s*:\\s*(.*)", "cs_pattern": "space\\s*:\\s*\\n*```\\n*(?:python)?\\n(.*?)\\n```"}, "solution": {"id": "31efb890-9e0d-4377-9189-d4b47ce7936b", "fitness": 0.73603, "name": "AdaptiveDE", "description": "This algorithm uses a differential evolution strategy with adaptive mutation and crossover rates based on the success rate of previous generations, aiming for a self-adjusting balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.success_F = []\n        self.success_CR = []\n        self.memory_F = [F] * 10\n        self.memory_CR = [CR] * 10\n        self.memory_index = 0\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        lb, ub = func.bounds.lb, func.bounds.ub\n        self.population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.budget -= self.pop_size\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.population[best_index]\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                \n                # Adaptive F and CR\n                F = self.memory_F[self.memory_index]\n                CR = self.memory_CR[self.memory_index]\n                \n                mutant = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, lb, ub)\n                \n                trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < CR or j == j_rand:\n                        trial[j] = mutant[j]\n                \n                f = func(trial)\n                self.budget -= 1\n                if f < self.fitness[i]:\n                    self.success_F.append(F)\n                    self.success_CR.append(CR)\n                    self.fitness[i] = f\n                    self.population[i] = trial\n                    \n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n            \n            # Update memory of F and CR\n            if self.success_F:\n                self.memory_F[self.memory_index] = np.mean(self.success_F)\n                self.memory_CR[self.memory_index] = np.mean(self.success_CR)\n                self.success_F = []\n                self.success_CR = []\n            \n            self.memory_index = (self.memory_index + 1) % 10\n\n            if self.budget <= 0:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "", "error": "", "parent_ids": [], "operator": null, "metadata": {}, "task_prompt": ""}, "log_dir": "run-EoH-MA_BBOB-2", "seed": 2}
