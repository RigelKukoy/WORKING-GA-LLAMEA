{"id": "4db99f04-e506-4bcd-947c-900e4d221e1f", "fitness": 0.4332466183350097, "name": "AdaptivePSODE", "description": "Population-based algorithm that combines aspects of Particle Swarm Optimization (PSO) and Differential Evolution (DE) with adaptive parameter control.", "code": "import numpy as np\n\nclass AdaptivePSODE:\n    def __init__(self, budget=10000, dim=10, pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.particles = None\n        self.velocities = None\n        self.fitness = None\n        self.personal_best_positions = None\n        self.personal_best_fitness = None\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n        self.eval_count = 0\n\n        # Adaptive Parameter Initialization\n        self.inertia_weight = 0.7  # Initial inertia weight for PSO\n        self.c1 = 1.5             # Cognitive coefficient for PSO\n        self.c2 = 1.5             # Social coefficient for PSO\n        self.mutation_rate = 0.1   # Mutation rate for DE\n        self.crossover_rate = 0.7 # Crossover rate for DE\n\n    def initialize_population(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.particles = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim)) # Initialize velocity\n\n        self.fitness = np.array([func(x) for x in self.particles])\n        self.eval_count += self.pop_size\n\n        self.personal_best_positions = self.particles.copy()\n        self.personal_best_fitness = self.fitness.copy()\n\n        self.global_best_position = self.particles[np.argmin(self.fitness)].copy()\n        self.global_best_fitness = np.min(self.fitness)\n\n\n    def update_parameters(self):\n        # Linear decreasing inertia weight\n        self.inertia_weight = 0.9 - (0.5 * (self.eval_count / self.budget))\n\n        # Dynamically adjust c1 and c2 (exploration vs exploitation)\n        progress = self.eval_count / self.budget\n        self.c1 = 1.5 + np.sin(np.pi * progress) * 0.5\n        self.c2 = 1.5 - np.sin(np.pi * progress) * 0.5\n\n        # Adapt mutation rate\n        self.mutation_rate = 0.05 + (0.2 * (1 - (self.eval_count / self.budget)))\n\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            self.update_parameters()\n\n            for i in range(self.pop_size):\n                # PSO Update\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n\n                velocity = (self.inertia_weight * self.velocities[i] +\n                            self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                            self.c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.velocities[i] = velocity\n                \n                # Keep velocity within reasonable bounds\n                v_max = abs(func.bounds.ub - func.bounds.lb)/2\n                self.velocities[i] = np.clip(self.velocities[i], -v_max, v_max)\n                \n                new_position = self.particles[i] + self.velocities[i]\n\n                # Boundary Handling\n                new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n\n                # DE Mutation and Crossover\n                if np.random.rand() < self.mutation_rate:\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x1, x2, x3 = self.particles[idxs]\n                    mutant = x1 + 0.5 * (x2 - x3)  #DE/rand/1\n\n                    # Crossover\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate:\n                            mutant[j] = new_position[j]\n\n                    mutant = np.clip(mutant, func.bounds.lb, func.bounds.ub)\n                    new_position = mutant\n\n\n                new_fitness = func(new_position)\n                self.eval_count += 1\n\n                if new_fitness < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = new_fitness\n                    self.personal_best_positions[i] = new_position.copy()\n\n                    if new_fitness < self.global_best_fitness:\n                        self.global_best_fitness = new_fitness\n                        self.global_best_position = new_position.copy()\n\n                self.particles[i] = new_position\n                self.fitness[i] = new_fitness\n\n\n        return self.global_best_fitness, self.global_best_position", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptivePSODE scored 0.433 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.1571940482922617, 0.19372489972591234, 0.45053452740098343, 0.6845021425187848, 0.44063292256901243, 0.4885861554303901, 0.29645442950003154, 0.37646508300445714, 0.43602384174662345, 0.21759532089336153, 0.6051526774076399, 0.9994931568833553, 0.2751881514318236, 0.28100422618579346, 0.6436184814056464, 0.5306997764271255, 0.340685592916379, 0.5430222627163976, 0.1971032460450729, 0.5072514241991417]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
