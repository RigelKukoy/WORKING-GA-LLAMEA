{"id": "2bb57d83-7bd6-49df-baed-68d399bc298c", "fitness": 0.0, "name": "AdaptiveDE", "description": "An adaptive differential evolution strategy with population size adaptation and a restart mechanism.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, F=0.5, Cr=0.9, restart_prob=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim  # Adaptive population size\n        self.F = F  # Differential weight\n        self.Cr = Cr  # Crossover rate\n        self.restart_prob = restart_prob #Probability of restarting the population\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.nevals = self.pop_size\n\n        while self.nevals < self.budget:\n            # Adaptive Population Size\n            if self.nevals > self.budget * 0.75 and self.pop_size > 4 * self.dim:\n                 self.pop_size = max(4*self.dim, int(self.pop_size * 0.9))\n                 self.population = self.population[:self.pop_size]\n                 self.fitness = self.fitness[:self.pop_size]\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                x_mutated = self.population[i] + self.F * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, self.lb, self.ub)\n\n                # Crossover\n                x_trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n\n                # Selection\n                f_trial = func(x_trial)\n                self.nevals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.population[i] = x_trial\n                    self.fitness[i] = f_trial\n\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = x_trial\n\n            #Restart mechanism\n            if np.random.rand() < self.restart_prob:\n                self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.population])\n                self.nevals += self.pop_size\n\n                best_index = np.argmin(self.fitness)\n                if self.fitness[best_index] < self.f_opt:\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.population[best_index]\n\n            if self.nevals >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "253d148c-c7f1-4a0d-92d8-8b347cf75ca8", "fitness": "-inf", "name": "AdaptiveDE", "description": "An adaptive Differential Evolution algorithm that dynamically adjusts its parameters based on the function evaluation feedback, using a population-based approach with mutation, crossover, and selection to explore and exploit the search space.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F  # Mutation factor\n        self.CR = CR  # Crossover rate\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.eval_count = 0\n\n    def initialize_population(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.eval_count += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.population[best_index].copy()\n\n    def mutate(self):\n        for i in range(self.pop_size):\n            idxs = np.random.choice(self.pop_size, 3, replace=False)\n            a, b, c = self.population[idxs]\n            mutant = a + self.F * (b - c)\n\n            # Ensure mutant stays within bounds.\n            lb = func.bounds.lb\n            ub = func.bounds.ub\n            mutant = np.clip(mutant, lb, ub)\n\n            trial = self.population[i].copy()\n            for j in range(self.dim):\n                if np.random.rand() <= self.CR or j == np.random.randint(0, self.dim):\n                    trial[j] = mutant[j]\n            yield trial, i\n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            for trial, i in self.mutate():\n                f_trial = func(trial)\n                self.eval_count += 1\n                if f_trial < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = f_trial\n                    \n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = trial.copy()\n\n                # Adaptive parameter control: Adjust F and CR based on success\n                if np.random.rand() < 0.1: # Small probability to adjust parameters\n                    self.F = np.clip(np.random.normal(0.5, 0.1), 0.1, 1.0)\n                    self.CR = np.clip(np.random.normal(0.9, 0.1), 0.1, 1.0)\n\n                if self.eval_count >= self.budget:\n                    break\n            \n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "In the code, line 35, in mutate, the following error occurred:\nNameError: name 'func' is not defined\nOn line: lb = func.bounds.lb", "error": "In the code, line 35, in mutate, the following error occurred:\nNameError: name 'func' is not defined\nOn line: lb = func.bounds.lb", "parent_ids": [], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "2053417e-faaf-4ce7-bf6f-a736fb38437e", "fitness": 0.2242490698511888, "name": "AntColonyOptimization", "description": "A population-based algorithm inspired by the foraging behavior of ants, where each ant explores the search space, deposits pheromones based on the quality of its solution, and probabilistically follows stronger pheromone trails.", "code": "import numpy as np\n\nclass AntColonyOptimization:\n    def __init__(self, budget=10000, dim=10, n_ants=20, evaporation_rate=0.1, alpha=1, beta=2):\n        \"\"\"\n        Initializes the Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            alpha (float): Importance of pheromone.\n            beta (float): Importance of heuristic information (fitness).\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.alpha = alpha\n        self.beta = beta\n        self.pheromone = None # Initialize pheromone matrix dynamically based on evaluations\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None # Initialize bounds later during the function call\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds # Set bounds for sampling inside the function call\n\n        # Dynamic Initialization of pheromone matrix after bounds are defined\n        self.pheromone = np.ones((self.dim, 2))  # One row for each dimension, and two columns for lower/upper bound\n\n        evaluations = 0\n        while evaluations < self.budget:\n            # Generate ant solutions\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                # Update best solution\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Update pheromone trails\n            self.update_pheromone(solutions, fitnesses)\n\n            # Evaporate pheromone\n            self.pheromone *= (1 - self.evaporation_rate)\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution (position) for an ant based on pheromone information.\n        \"\"\"\n        x = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Probabilistically choose a value based on pheromone strength\n            # near the lower or upper bound\n            pheromone_lower = self.pheromone[i, 0]\n            pheromone_upper = self.pheromone[i, 1]\n\n            if np.random.rand() < (pheromone_lower / (pheromone_lower + pheromone_upper)):\n                # Sample near the lower bound\n                x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.lb[i] + 0.1 * (self.bounds.ub[i] - self.bounds.lb[i]))\n            else:\n                # Sample near the upper bound\n                x[i] = np.random.uniform(self.bounds.ub[i] - 0.1 * (self.bounds.ub[i] - self.bounds.lb[i]), self.bounds.ub[i])\n\n        x = np.clip(x, self.bounds.lb, self.bounds.ub)  # Ensure solutions are within bounds\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates the pheromone trails based on the quality of the solutions.\n        \"\"\"\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n\n            # Deposit pheromone based on solution quality (higher reward for better fitness)\n            delta_pheromone = 1 / (1 + f - self.best_fitness)  # Reward better solutions more\n\n            for j in range(self.dim):\n                # Update pheromone near the dimension value\n                if x[j] < (self.bounds.lb[j] + 0.5 * (self.bounds.ub[j] - self.bounds.lb[j])):\n                    self.pheromone[j, 0] += delta_pheromone  # near lower bound\n                else:\n                    self.pheromone[j, 1] += delta_pheromone  # near upper bound", "configspace": "", "generation": 0, "feedback": "The algorithm AntColonyOptimization scored 0.224 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.05124241963852638, 0.09702242537387029, 0.19383029424638132, 0.16722372762008963, 0.12852872799687742, 0.1690381582903281, 0.18298633278793952, 0.13131337820807554, 0.14181548547573553, 0.14036609152644564, 0.15239138506620653, 0.9990664250833385, 0.16897777456363106, 0.16087056659735555, 0.5414710000091485, 0.170441725690483, 0.133875185014787, 0.18468525729031826, 0.14321152848605723, 0.42662350805818083]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "05656a4c-0409-47f2-a4a8-145337fceb02", "fitness": 0.5978757940655586, "name": "CulturalDifferentialEvolution", "description": "Population-based algorithm inspired by cultural evolution, where individuals adapt based on cultural beliefs and social learning, incorporating elements of differential evolution for exploration.", "code": "import numpy as np\n\nclass CulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f=0.8, belief_space_size=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = belief_space_size # Size of the belief space for cultural learning\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space (best individuals observed so far)\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n        belief_fitness = np.sort(fitness)[:self.belief_space_size].copy()\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning: Bias towards best from belief space\n                belief_idx = np.random.randint(self.belief_space_size)\n                x_trial = x_trial + 0.1 * (belief_space[belief_idx] - x_trial)\n                x_trial = np.clip(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                    # Update belief space if necessary\n                    if f_trial < belief_fitness[-1]:\n                        belief_fitness[-1] = f_trial\n                        belief_space[-1] = x_trial\n                        \n                        # Re-sort belief space to maintain order\n                        sorted_indices = np.argsort(belief_fitness)\n                        belief_fitness = belief_fitness[sorted_indices]\n                        belief_space = belief_space[sorted_indices]\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm CulturalDifferentialEvolution scored 0.598 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.21676574132980997, 0.36258467641512593, 0.5664561751109564, 0.8206568049134082, 0.6338431259478132, 0.7150871172223688, 0.5419299504957762, 0.5402432598083677, 0.6455515001153109, 0.5510176185740654, 0.7765999628103935, 0.9952411949812514, 0.3460937106667341, 0.5728127643248726, 0.8758115972645133, 0.741255219915613, 0.43413382908720133, 0.8120306247282598, 0.28446453455682674, 0.5249364730425019]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "abec4b07-61a8-4b3c-919d-835067de372b", "fitness": 0.0, "name": "AdaptiveDE", "description": "Adaptive Differential Evolution with Self-Adaptive Parameters and Neighborhood-Based Mutation, dynamically adjusting F and Cr, using neighborhood information for mutation, and incorporating a local search step for exploitation.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, F=0.5, Cr=0.9, restart_prob=0.05, local_search_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim  # Adaptive population size\n        self.F = F  # Differential weight, now adaptive\n        self.Cr = Cr  # Crossover rate, now adaptive\n        self.restart_prob = restart_prob #Probability of restarting the population\n        self.local_search_prob = local_search_prob #Probability of performing local search\n        self.lb = -5.0\n        self.ub = 5.0\n        self.archive = [] # Archive for past solutions\n        self.archive_size = int(self.budget * 0.1) #Archive size\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.nevals = self.pop_size\n\n        # Initialize F and Cr memory\n        self.F_memory = np.full(self.pop_size, self.F)\n        self.Cr_memory = np.full(self.pop_size, self.Cr)\n\n        while self.nevals < self.budget:\n            # Adaptive Population Size\n            if self.nevals > self.budget * 0.75 and self.pop_size > 4 * self.dim:\n                 self.pop_size = max(4*self.dim, int(self.pop_size * 0.9))\n                 self.population = self.population[:self.pop_size]\n                 self.fitness = self.fitness[:self.pop_size]\n                 self.F_memory = self.F_memory[:self.pop_size]\n                 self.Cr_memory = self.Cr_memory[:self.pop_size]\n\n            for i in range(self.pop_size):\n                # Parameter Adaptation (Self-Adaptive F and Cr)\n                self.F_memory[i] = np.clip(np.random.normal(0.5, 0.3), 0.1, 1.0)  # Gaussian distribution\n                self.Cr_memory[i] = np.clip(np.random.normal(0.9, 0.1), 0.0, 1.0)  # Gaussian distribution\n\n                # Mutation (Neighborhood-Based)\n                neighborhood_size = max(2, int(self.pop_size * 0.1)) # Small percentage of pop_size\n                neighbors = np.random.choice(self.pop_size, neighborhood_size, replace=False)\n                best_neighbor_idx = neighbors[np.argmin(self.fitness[neighbors])]\n\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = self.population[idxs]\n\n                x_mutated = self.population[i] + self.F_memory[i] * (self.population[best_neighbor_idx] - self.population[i]) + self.F_memory[i] * (x_r1 - x_r2)\n                x_mutated = np.clip(x_mutated, self.lb, self.ub)\n\n\n                # Crossover\n                x_trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr_memory[i] or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n\n                # Local Search\n                if np.random.rand() < self.local_search_prob:\n                    # Perform a small perturbation around the current solution\n                    x_trial_local = x_trial + np.random.normal(0, 0.01, self.dim)\n                    x_trial_local = np.clip(x_trial_local, self.lb, self.ub)\n                else:\n                    x_trial_local = x_trial\n                    \n                # Selection\n                f_trial = func(x_trial_local)\n                self.nevals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.population[i] = x_trial_local\n                    self.fitness[i] = f_trial\n\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = x_trial_local\n                        \n                    # Update Archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(x_trial_local)\n                    else:\n                         idx_to_replace = np.random.randint(self.archive_size)\n                         self.archive[idx_to_replace] = x_trial_local\n\n            #Restart mechanism\n            if np.random.rand() < self.restart_prob:\n                self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n                self.fitness = np.array([func(x) for x in self.population])\n                self.nevals += self.pop_size\n                self.F_memory = np.full(self.pop_size, self.F)\n                self.Cr_memory = np.full(self.pop_size, self.Cr)\n\n\n                best_index = np.argmin(self.fitness)\n                if self.fitness[best_index] < self.f_opt:\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.population[best_index]\n\n            if self.nevals >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2bb57d83-7bd6-49df-baed-68d399bc298c"], "operator": null, "metadata": {"aucs": [0]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "9da799c3-0dfd-4aab-baf7-9529b5afb154", "fitness": 0.5409694914395925, "name": "HybridDE_NM", "description": "A hybrid algorithm combining Differential Evolution with a Nelder-Mead local search, adaptively switching between exploration and exploitation based on the budget remaining.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridDE_NM:\n    def __init__(self, budget=10000, dim=10, pop_size=40, cr=0.7, f=0.8, nm_iters=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr\n        self.f = f\n        self.nm_iters = nm_iters  # Number of Nelder-Mead iterations\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n\n        de_phase = True  # Start with DE for exploration\n\n        while self.budget > 0:\n            if de_phase:\n                for i in range(self.pop_size):\n                    # Differential Evolution Mutation\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x_r1, x_r2, x_r3 = population[idxs]\n                    x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                    x_mutated = np.clip(x_mutated, lb, ub)\n\n                    # Crossover\n                    x_trial = population[i].copy()\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < self.cr or j == j_rand:\n                            x_trial[j] = x_mutated[j]\n\n                    # Evaluate trial vector\n                    f_trial = func(x_trial)\n                    self.budget -= 1\n\n                    # Selection\n                    if f_trial < fitness[i]:\n                        fitness[i] = f_trial\n                        population[i] = x_trial\n\n                    # Update overall best\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = x_trial\n\n                    if self.budget <= 0:\n                        break\n\n                # Switch to Nelder-Mead if budget is low\n                if self.budget < self.budget/4: # adaptive switching condition\n                    de_phase = False\n\n            else:  # Nelder-Mead Phase\n                for i in range(self.pop_size):\n                    # Apply Nelder-Mead local search to each individual\n                    result = minimize(func, population[i], bounds=func.bounds, method='Nelder-Mead', options={'maxiter': self.nm_iters})\n                    x_nm = result.x\n                    f_nm = result.fun\n                    self.budget -= result.nfev  # Account for Nelder-Mead function evaluations\n\n                    if f_nm < fitness[i]:\n                        fitness[i] = f_nm\n                        population[i] = x_nm\n\n                    # Update overall best\n                    if f_nm < self.f_opt:\n                        self.f_opt = f_nm\n                        self.x_opt = x_nm\n\n                    if self.budget <= 0:\n                        break\n                de_phase = True # Switch back to DE after NM to maintain exploration\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDE_NM scored 0.541 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.19216131013944793, 0.2695897133641716, 0.4904962666139919, 0.7855987486850524, 0.5802620584427305, 0.6426121218650338, 0.3650153679101704, 0.49155165219368413, 0.5818718783714643, 0.464812930681785, 0.7179623071948547, 0.9914475406785157, 0.31335621137562275, 0.5307210692874547, 0.8773959575403472, 0.6725542429652076, 0.40039289741900486, 0.7499766271210816, 0.20948244360886958, 0.49212848333336]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "210fefae-8164-434b-b418-412bbe90e4c4", "fitness": 0.07548471820974617, "name": "SelfOrganizingDE", "description": "A self-organizing Differential Evolution algorithm that dynamically adjusts its population size and mutation strategy based on the problem's topology and the algorithm's progress.", "code": "import numpy as np\n\nclass SelfOrganizingDE:\n    def __init__(self, budget=10000, dim=10, initial_pop_size=50):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = initial_pop_size\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.eval_count = 0\n        self.archive = [] # Archive for storing potentially useful individuals\n\n    def initialize_population(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        self.population = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.eval_count += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.population[best_index].copy()\n\n    def evolve(self, func):\n        new_population = []\n        new_fitness = []\n\n        for i in range(self.pop_size):\n            # Mutation strategy: Adaptive selection from multiple strategies\n            strategy = np.random.choice(['DE/rand/1', 'DE/best/1', 'DE/current-to-best/1'])\n            \n            if strategy == 'DE/rand/1':\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = self.population[idxs]\n                mutant = a + 0.5 * (b - c) #F=0.5\n\n            elif strategy == 'DE/best/1':\n                best = self.population[np.argmin(self.fitness)]\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                a, b = self.population[idxs]\n                mutant = best + 0.5 * (a - b) #F=0.5\n\n            elif strategy == 'DE/current-to-best/1':\n                best = self.population[np.argmin(self.fitness)]\n                idxs = np.random.choice(self.pop_size, 1, replace=False)\n                a = self.population[idxs[0]]\n                mutant = self.population[i] + 0.5 * (best - self.population[i]) + 0.5 * (a - self.population[i]) #F=0.5\n\n            # Ensure mutant stays within bounds\n            lb = func.bounds.lb\n            ub = func.bounds.ub\n            mutant = np.clip(mutant, lb, ub)\n\n            # Crossover\n            trial = self.population[i].copy()\n            for j in range(self.dim):\n                if np.random.rand() <= 0.9 or j == np.random.randint(0, self.dim): #CR=0.9\n                    trial[j] = mutant[j]\n\n            f_trial = func(trial)\n            self.eval_count += 1\n\n            if f_trial < self.fitness[i]:\n                new_population.append(trial)\n                new_fitness.append(f_trial)\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = trial.copy()\n            else:\n                new_population.append(self.population[i])\n                new_fitness.append(self.fitness[i])\n                self.archive.append(self.population[i])  # Store rejected individuals\n\n        self.population = np.array(new_population)\n        self.fitness = np.array(new_fitness)\n\n        # Population size adaptation (simplified): Increase if stagnant, decrease if too diverse\n        if np.std(self.fitness) < 1e-6 and self.eval_count < self.budget/2:  #Stagnation\n            self.pop_size = min(self.pop_size + 5, 100) # Max pop size of 100\n            lb = func.bounds.lb\n            ub = func.bounds.ub\n            new_individuals = np.random.uniform(lb, ub, (5, self.dim))\n            new_fitnesses = [func(x) for x in new_individuals]\n            self.eval_count += 5\n            self.population = np.concatenate((self.population, new_individuals))\n            self.fitness = np.concatenate((self.fitness, new_fitnesses))\n\n        elif np.std(self.fitness) > 1 and self.pop_size > 10: # too diverse\n            self.pop_size = max(self.pop_size - 5, 10) # min pop size of 10\n            indices = np.argsort(self.fitness)[:self.pop_size]\n            self.population = self.population[indices]\n            self.fitness = self.fitness[indices]\n    \n\n    def __call__(self, func):\n        self.initialize_population(func)\n\n        while self.eval_count < self.budget:\n            self.evolve(func)\n            if self.eval_count >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm SelfOrganizingDE scored 0.075 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["253d148c-c7f1-4a0d-92d8-8b347cf75ca8"], "operator": null, "metadata": {"aucs": [0.15096943641949234, 0]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "db4fd874-398f-4129-b7b1-7162093adc9d", "fitness": 0.0, "name": "AdaptiveDE", "description": "An adaptive differential evolution with covariance matrix adaptation and orthogonal design to improve exploration and exploitation.", "code": "import numpy as np\nfrom scipy.linalg import orthogonal_procrustes\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, F=0.5, Cr=0.9, restart_prob=0.05, local_search_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 10 * dim\n        self.F = F\n        self.Cr = Cr\n        self.restart_prob = restart_prob\n        self.local_search_prob = local_search_prob\n        self.lb = -5.0\n        self.ub = 5.0\n        self.C = np.eye(dim)  # Covariance matrix for CMA\n\n    def __call__(self, func):\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.nevals = self.pop_size\n\n        # Orthogonal initialization (Latin Hypercube Sampling)\n        self.population = self._latin_hypercube_sampling()\n        self.fitness = np.array([func(x) for x in self.population])\n        self.nevals += self.pop_size\n\n        while self.nevals < self.budget:\n            # Adaptive Population Size\n            if self.nevals > self.budget * 0.75 and self.pop_size > 4 * self.dim:\n                 self.pop_size = max(4*self.dim, int(self.pop_size * 0.9))\n                 self.population = self.population[:self.pop_size]\n                 self.fitness = self.fitness[:self.pop_size]\n\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[idxs]\n                x_mutated = self.population[i] + self.F * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, self.lb, self.ub)\n\n                # Crossover\n                x_trial = np.copy(self.population[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.Cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n\n                # Local Search (CMA-ES inspired)\n                if np.random.rand() < self.local_search_prob:\n                    x_trial = self._cma_mutation(self.population[i])\n                    x_trial = np.clip(x_trial, self.lb, self.ub)\n\n                # Selection\n                f_trial = func(x_trial)\n                self.nevals += 1\n\n                if f_trial < self.fitness[i]:\n                    self.population[i] = x_trial\n                    self.fitness[i] = f_trial\n\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = x_trial\n\n            # Covariance Matrix Adaptation (simplified)\n            if self.nevals % (self.dim * 10) == 0:\n                self._update_covariance_matrix()\n\n            # Restart mechanism\n            if np.random.rand() < self.restart_prob:\n                self.population = self._latin_hypercube_sampling()\n                self.fitness = np.array([func(x) for x in self.population])\n                self.nevals += self.pop_size\n\n                best_index = np.argmin(self.fitness)\n                if self.fitness[best_index] < self.f_opt:\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.population[best_index]\n\n            if self.nevals >= self.budget:\n                break\n\n        return self.f_opt, self.x_opt\n\n    def _cma_mutation(self, x):\n        z = np.random.multivariate_normal(np.zeros(self.dim), self.C)\n        return x + self.F * z  # Use F as step size\n\n    def _update_covariance_matrix(self):\n       #Simplified CMA-ES update - adapt covariance matrix based on successful steps\n        diffs = self.population - np.mean(self.population, axis=0)\n        self.C = np.cov(diffs.T) + 0.001 * np.eye(self.dim) # Add small identity matrix for regularization\n        \n    def _latin_hypercube_sampling(self):\n        # Generate a Latin Hypercube Sample\n        points = np.zeros((self.pop_size, self.dim))\n        for i in range(self.dim):\n            points[:, i] = np.random.permutation(range(self.pop_size))\n        r = np.random.rand(self.pop_size, self.dim)\n        points = (points + r) / self.pop_size\n        # Scale to the search space\n        points = points * (self.ub - self.lb) + self.lb\n        return points", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDE scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2bb57d83-7bd6-49df-baed-68d399bc298c"], "operator": null, "metadata": {"aucs": [0]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "7dde1d4a-c58e-49c1-9d07-f1620c8c8886", "fitness": 0.3255846612367448, "name": "EnhancedAntColonyOptimization", "description": "An enhanced Ant Colony Optimization algorithm that dynamically adjusts pheromone influence based on fitness improvement and adapts ant behavior by focusing exploration around the current best solution.", "code": "import numpy as np\n\nclass EnhancedAntColonyOptimization:\n    def __init__(self, budget=10000, dim=10, n_ants=20, evaporation_rate=0.1, alpha=1, beta=2, q=1.0):\n        \"\"\"\n        Initializes the Enhanced Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            alpha (float): Importance of pheromone.\n            beta (float): Importance of heuristic information (fitness).\n            q (float): Parameter controlling pheromone deposit amount.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.alpha = alpha\n        self.beta = beta\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Enhanced Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones((self.dim, 2))\n        evaluations = 0\n        convergence_count = 0\n        prev_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n\n            # Adaptive evaporation rate based on convergence\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                convergence_count += 1\n                if convergence_count > 10:\n                    self.evaporation_rate *= 0.9  # Increase evaporation if stuck\n            else:\n                convergence_count = 0\n                self.evaporation_rate = 0.1 # Reset evaporation rate\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution.\n        \"\"\"\n        x = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Bias towards the best solution\n            if self.best_solution is not None and np.random.rand() < 0.7:  # 70% probability to explore near best solution\n                x[i] = np.random.normal(self.best_solution[i], 0.1 * (self.bounds.ub[i] - self.bounds.lb[i]))\n            else:\n                pheromone_lower = self.pheromone[i, 0]\n                pheromone_upper = self.pheromone[i, 1]\n                if np.random.rand() < (pheromone_lower / (pheromone_lower + pheromone_upper)):\n                    x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.lb[i] + 0.1 * (self.bounds.ub[i] - self.bounds.lb[i]))\n                else:\n                    x[i] = np.random.uniform(self.bounds.ub[i] - 0.1 * (self.bounds.ub[i] - self.bounds.lb[i]), self.bounds.ub[i])\n\n        x = np.clip(x, self.bounds.lb, self.bounds.ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions more significantly and normalizing pheromone deposits.\n        \"\"\"\n        delta_pheromone = np.zeros((self.dim, 2))\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n\n            # Higher pheromone deposit for better solutions\n            deposit = self.q / (1 + f - self.best_fitness)\n            for j in range(self.dim):\n                if x[j] < (self.bounds.lb[j] + 0.5 * (self.bounds.ub[j] - self.bounds.lb[j])):\n                    delta_pheromone[j, 0] += deposit\n                else:\n                    delta_pheromone[j, 1] += deposit\n\n        # Normalize pheromone deposits to prevent domination by single dimensions\n        delta_pheromone /= np.sum(delta_pheromone) + 1e-9\n\n        self.pheromone += delta_pheromone", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedAntColonyOptimization scored 0.326 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2053417e-faaf-4ce7-bf6f-a736fb38437e"], "operator": null, "metadata": {"aucs": [0.16108932225014072, 0.19090339364253528, 0.31320565257629696, 0.1643364558916659, 0.2513689184705996, 0.312105015771698, 0.27278230769472434, 0.3118025851827205, 0.24900439489817228, 0.15875728752221185, 0.29768474726221383, 0.9998343050919342, 0.21513355393540934, 0.2731777457327452, 0.6795760329071779, 0.32888112933000324, 0.2855256045747795, 0.37077829043562494, 0.1955034141055072, 0.48024306745873413]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "cc7c41e8-2643-4a4f-8ae1-f9441d80f4b5", "fitness": "-inf", "name": "CulturalDifferentialEvolution", "description": "Combines Cultural Differential Evolution with a self-adaptive learning rate for belief space influence and a restart mechanism to escape local optima.", "code": "import numpy as np\n\nclass CulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f=0.8, belief_space_size=10, lr_initial=0.1, lr_decay=0.99):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = belief_space_size # Size of the belief space for cultural learning\n        self.lr = lr_initial  # Initial learning rate for cultural learning\n        self.lr_decay = lr_decay # Decay rate for the learning rate\n        self.restart_patience = 50 # Number of iterations before restarting if no improvement\n        self.no_improvement_count = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space (best individuals observed so far)\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n        belief_fitness = np.sort(fitness)[:self.belief_space_size].copy()\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning: Bias towards best from belief space\n                belief_idx = np.random.randint(self.belief_space_size)\n                x_trial = x_trial + self.lr * (belief_space[belief_idx] - x_trial)\n                x_trial = np.clip(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                    # Update belief space if necessary\n                    if f_trial < belief_fitness[-1]:\n                        belief_fitness[-1] = f_trial\n                        belief_space[-1] = x_trial\n                        \n                        # Re-sort belief space to maintain order\n                        sorted_indices = np.argsort(belief_fitness)\n                        belief_fitness = belief_fitness[sorted_indices]\n                        belief_space = belief_space[sorted_indices]\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    self.no_improvement_count = 0 # Reset counter\n                else:\n                    self.no_improvement_count += 1\n\n                if self.budget <= 0:\n                    break\n            \n            # Adaptive Learning Rate\n            self.lr *= self.lr_decay\n            self.lr = max(0.01, self.lr) # Ensure learning rate doesn't become too small\n\n            # Restart mechanism if no improvement for a while\n            if self.no_improvement_count > self.restart_patience:\n                population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n                fitness = np.array([func(x) for x in population])\n                self.budget -= self.pop_size\n\n                best_idx = np.argmin(fitness)\n                if fitness[best_idx] < self.f_opt:\n                  self.f_opt = fitness[best_idx]\n                  self.x_opt = population[best_idx]\n\n                belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n                belief_fitness = np.sort(fitness)[:self.belief_space_size].copy()\n                self.no_improvement_count = 0\n                self.lr = 0.1 # Reset learning rate as well\n                print(f\"Restarting at generation {generation}...\")\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "0b679e3a-18e6-4a2d-abed-fd20aaf4dd38", "fitness": "-inf", "name": "AntColonyOptimization", "description": "An adaptive Ant Colony Optimization (ACO) that dynamically adjusts exploration based on pheromone concentration and solution quality, focusing search around promising regions.", "code": "import numpy as np\n\nclass AntColonyOptimization:\n    def __init__(self, budget=10000, dim=10, n_ants=20, evaporation_rate=0.1, alpha=1, beta=2, exploration_bias=0.1):\n        \"\"\"\n        Initializes the Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            alpha (float): Importance of pheromone.\n            beta (float): Importance of heuristic information (fitness).\n            exploration_bias (float): Probability of exploring randomly instead of using pheromones.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.alpha = alpha\n        self.beta = beta\n        self.exploration_bias = exploration_bias\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim) * 0.5  # Initialize pheromone with a uniform distribution representing exploration probability\n\n        evaluations = 0\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n            self.pheromone = np.clip(self.pheromone, 0.01, 0.99)  # Ensure pheromone values stay within bounds\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution (position) for an ant, balancing exploration and exploitation.\n        \"\"\"\n        x = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.exploration_bias:\n                # Explore: Sample randomly from the entire range\n                x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n            else:\n                # Exploit: Sample based on pheromone strength (probability of being near the best)\n                if np.random.rand() < self.pheromone[i]:\n                    # Move towards a value near the best found solution in that dimension.\n                    if self.best_solution is not None:\n                         x[i] = np.random.uniform(max(self.bounds.lb[i], self.best_solution[i] - 0.05 * (self.bounds.ub[i] - self.bounds.lb[i])),\n                                                   min(self.bounds.ub[i], self.best_solution[i] + 0.05 * (self.bounds.ub[i] - self.bounds.lb[i])))\n                    else: #If no best solution is available explore.\n                        x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n                else:\n                    #Explore randomly\n                    x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n\n\n        x = np.clip(x, self.bounds.lb, self.bounds.ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates the pheromone trails based on the quality of the solutions.  Normalize the fitnesses to enhance the pheromone update.\n        \"\"\"\n\n        # Normalize fitnesses to a range between 0 and 1, with 1 being the best\n        normalized_fitnesses = 1 - (fitnesses - np.min(fitnesses)) / (np.max(fitnesses) - np.min(fitnesses) + 1e-8)  # Avoid division by zero\n\n\n        for i in range(len(solutions)):\n            x = solutions[i]\n            #f = fitnesses[i]\n            f = normalized_fitnesses[i]\n\n            # Update pheromone for each dimension, scaling by fitness\n            for j in range(self.dim):\n                # The better the fitness, the greater the influence on the pheromone\n                self.pheromone[j] += (f * 0.1 * (1 if x[j] close_to self.best_solution[j] else -1 *abs(x[j] - self.best_solution[j])/(self.bounds.ub[j] - self.bounds.lb[j]))) if self.best_solution is not None else 0\n                #If the coordinate x[j] of the current solution is close to the best solution, then the pheromone increases for that coordinate, else, decreases.\ndef close_to(a, b, tolerance=1e-2):\n    return abs(a-b) < tolerance", "configspace": "", "generation": 1, "feedback": "In the code, line 143, in evaluate, the following error occurred:\nSyntaxError: expected 'else' after 'if' expression", "error": "In the code, line 143, in evaluate, the following error occurred:\nSyntaxError: expected 'else' after 'if' expression", "parent_ids": ["2053417e-faaf-4ce7-bf6f-a736fb38437e"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "5f199cca-b70f-4191-97ef-3d3d13743c01", "fitness": 0.5667528180709318, "name": "HybridPSO_CMAES", "description": "A hybrid optimization algorithm that combines the strengths of Particle Swarm Optimization (PSO) and Covariance Matrix Adaptation Evolution Strategy (CMA-ES) for efficient exploration and exploitation of the search space.", "code": "import numpy as np\n\nclass HybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20, pso_inertia=0.7, pso_cognitive=1.4, pso_social=1.4, cmaes_sigma=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia = pso_inertia\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.population = None  # Initialize population\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim)) # initialize velocities\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n\n        # Initialize CMA-ES parameters\n        mean = np.mean(population, axis=0)\n        covariance = np.eye(self.dim)\n        \n        while self.budget > 0:\n            # PSO update\n            for i in range(self.pop_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocities[i] = (self.pso_inertia * velocities[i] +\n                                 self.pso_cognitive * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.pso_social * r2 * (global_best_position - population[i]))\n                \n                population[i] = population[i] + velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n                \n                fitness = func(population[i])\n                self.budget -= 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_positions[i] = population[i].copy()\n                    \n                    if fitness < global_best_fitness:\n                        global_best_fitness = fitness\n                        global_best_position = population[i].copy()\n            \n            # CMA-ES adaptation - only adapt every 5 iterations (example) to allow PSO to explore\n            if self.budget % 500 < self.pop_size and self.budget > self.pop_size: # Check if sufficient budget is left to apply CMAES and perform function evaluations.\n                # Generate CMA-ES samples\n                z = np.random.multivariate_normal(np.zeros(self.dim), covariance, self.pop_size)\n                cmaes_samples = mean + self.cmaes_sigma * z\n                cmaes_samples = np.clip(cmaes_samples, lb, ub)\n\n                cmaes_fitness = np.zeros(self.pop_size)\n                for i in range(self.pop_size):\n                  cmaes_fitness[i] = func(cmaes_samples[i])\n                  self.budget -= 1\n\n                # Select best CMA-ES samples and update mean and covariance\n                best_cmaes_indices = np.argsort(cmaes_fitness)[:self.pop_size // 2]  # Select top 50%\n                best_cmaes_samples = cmaes_samples[best_cmaes_indices]\n                \n                mean = np.mean(best_cmaes_samples, axis=0)\n\n                # Update covariance (simplified - can be improved with CMA-ES update rules)\n                covariance = np.cov(best_cmaes_samples, rowvar=False)\n                \n                # Replace worst PSO particles with best CMA-ES particles (elitism)\n                worst_pso_indices = np.argsort(personal_best_fitness)[-self.pop_size // 2:]\n                population[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_positions[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices]\n                \n                # Update global best\n                global_best_index = np.argmin(personal_best_fitness)\n                global_best_position = personal_best_positions[global_best_index]\n                global_best_fitness = personal_best_fitness[global_best_index]\n                \n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSO_CMAES scored 0.567 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.18666563105114076, 0.21612730282556902, 0.8343044801471248, 0.874637153859805, 0.3660178217803939, 0.8132789986547951, 0.3257460495994916, 0.5414586444606756, 0.8791371641912913, 0.2168385035529905, 0.8058207668904439, 0.998306545890561, 0.31029409611621606, 0.2539626825972654, 0.727463397197732, 0.9062006213866071, 0.6566158844998229, 0.6776291756100797, 0.24082893270061045, 0.5037225084060197]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "e54affc2-dea2-4749-9b0a-c4ac4611e16f", "fitness": 0.3519130193105907, "name": "RingTopologyAdaptiveDE", "description": "A population-based algorithm that uses a ring topology for information sharing and a self-adaptive mutation strategy to balance exploration and exploitation.", "code": "import numpy as np\n\nclass RingTopologyAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f_initial=0.5, f_decay=0.99, topology_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f_initial    # Differential weight, adaptive\n        self.f_initial = f_initial\n        self.f_decay = f_decay\n        self.topology_size = topology_size # Number of neighbors in the ring\n        \n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Ring Topology Selection\n                neighbors = [(i - j) % self.pop_size for j in range(1, self.topology_size // 2 + 1)] + \\\n                            [(i + j) % self.pop_size for j in range(1, self.topology_size // 2 + 1)]\n                neighbors.append(i) # Include self for comparison\n                best_neighbor = neighbors[np.argmin(fitness[neighbors])]\n                \n                # Self-Adaptive Mutation\n                idxs = np.random.choice(self.pop_size, 2, replace=False)\n                x_r1, x_r2 = population[idxs]\n\n                #Adaptive F\n                if fitness[i] < fitness[best_neighbor]:\n                    self.f = self.f_initial\n                else:\n                    self.f *= self.f_decay\n                \n                x_mutated = population[best_neighbor] + self.f * (x_r1 - x_r2)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "The algorithm RingTopologyAdaptiveDE scored 0.352 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.15837198745793757, 0.3427392676256298, 0.30177300498379067, 0.4088296526905265, 0.2428282772404342, 0.32791465649519935, 0.2860095736689927, 0.2949102681878226, 0.23887403428451137, 0.19318267455588944, 0.27187671911243316, 0.9970210651268497, 0.2987878872380304, 0.3279891288466803, 0.7293907307873793, 0.30959993976259215, 0.29654791739467157, 0.3592479393728466, 0.1906850628936113, 0.4616805984859844]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "865217d9-70da-4225-8c7f-a34564f74097", "fitness": 0.4396002585022698, "name": "SimplifiedACO", "description": "A simplified ACO variant that prioritizes exploration around the best solution found so far, using a single pheromone value per dimension to guide movement towards promising regions, and dynamically adjusts exploration range based on convergence.", "code": "import numpy as np\n\nclass SimplifiedACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.05, q=1.0, initial_exploration=0.2):\n        \"\"\"\n        Initializes the Simplified Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Simplified Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim)  # Single pheromone value per dimension\n        evaluations = 0\n        convergence_count = 0\n        prev_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n\n            # Adaptive exploration range based on convergence\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                convergence_count += 1\n                if convergence_count > 5:\n                    self.exploration_range *= 0.9  # Reduce exploration if stuck\n            else:\n                convergence_count = 0\n                self.exploration_range = 0.2 # Reset exploration range\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution.\n        \"\"\"\n        x = np.zeros(self.dim)\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            x = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n        else:\n            # Exploration around the best solution, guided by pheromones\n            for i in range(self.dim):\n                lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions.\n        \"\"\"\n        delta_pheromone = np.zeros(self.dim)\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n            # Higher pheromone deposit for better solutions, scaled by distance to best solution\n            deposit = self.q / (1 + f - self.best_fitness)\n            delta_pheromone += deposit * np.abs(x - self.best_solution) # Magnitude matters\n\n        self.pheromone += delta_pheromone\n        self.pheromone = np.clip(self.pheromone, 0.01, 1.0) # Prevent pheromone saturation\n", "configspace": "", "generation": 2, "feedback": "The algorithm SimplifiedACO scored 0.440 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7dde1d4a-c58e-49c1-9d07-f1620c8c8886"], "operator": null, "metadata": {"aucs": [0.210748186520053, 0.22909563222833895, 0.42781221771650335, 0.7609583629536303, 0.4154697189911395, 0.5184202524554565, 0.2853794260821312, 0.3892449437218921, 0.37103304181391605, 0.24757336574236632, 0.524076019404971, 0.9983269558514182, 0.24824164286742012, 0.29562922959567317, 0.8004678868017124, 0.41196441913411264, 0.34366676251942074, 0.5294798352150023, 0.2788270688822424, 0.5055902015479983]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "67f486c0-32d1-42f0-9400-6e3e5cb172d1", "fitness": "-inf", "name": "AdaptiveDE_LBFGSB", "description": "A self-adjusting algorithm that combines Differential Evolution with a local search method (L-BFGS-B), dynamically adapting population size and switching between global exploration (DE) and local exploitation (L-BFGS-B) based on stagnation detection.", "code": "import numpy as np\nfrom scipy.optimize import minimize, Bounds\n\nclass AdaptiveDE_LBFGSB:\n    def __init__(self, budget=10000, dim=10, initial_pop_size=50, cr=0.7, f=0.8, stagnation_threshold=100):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = initial_pop_size\n        self.cr = cr\n        self.f = f\n        self.stagnation_threshold = stagnation_threshold\n        self.stagnation_counter = 0\n        self.best_fitness_history = []\n        self.lb = None\n        self.ub = None\n\n    def __call__(self, func):\n        self.lb = func.bounds.lb\n        self.ub = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        self.best_fitness_history.append(self.f_opt)\n\n        while self.budget > 0:\n            # Differential Evolution Mutation\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, self.lb, self.ub)\n\n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n\n                if self.budget <= 0:\n                    break\n\n            self.best_fitness_history.append(self.f_opt)\n\n            # Stagnation Detection and Adaptation\n            if len(self.best_fitness_history) > self.stagnation_threshold:\n                if np.abs(self.best_fitness_history[-1] - self.best_fitness_history[-self.stagnation_threshold]) < 1e-6:\n                    self.stagnation_counter += 1\n                else:\n                    self.stagnation_counter = 0\n\n                if self.stagnation_counter > self.stagnation_threshold // 2:\n                    # Local Search with L-BFGS-B on the best individuals\n                    num_local_searches = min(self.pop_size // 4, 5)\n                    best_indices = np.argsort(fitness)[:num_local_searches]\n                    for idx in best_indices:\n                        result = minimize(func, population[idx], bounds=Bounds(self.lb, self.ub), method='L-BFGS-B', options={'maxfun': 20}) # Reduced maxfun\n                        x_lbfgs = result.x\n                        f_lbfgs = result.fun\n                        self.budget -= result.nfev\n\n                        if f_lbfgs < fitness[idx]:\n                            fitness[idx] = f_lbfgs\n                            population[idx] = x_lbfgs\n\n                        if f_lbfgs < self.f_opt:\n                            self.f_opt = f_lbfgs\n                            self.x_opt = x_lbfgs\n\n                        if self.budget <= 0:\n                            break\n\n                    # Adjust population size (reduce if stagnating, increase otherwise)\n                    if self.pop_size > 20:\n                         self.pop_size = int(self.pop_size * 0.8) # Reduce population size\n                    else:\n                        self.pop_size = min(self.pop_size + 5, 100)  # Increase population size, but limit the upper size\n                    self.stagnation_counter = 0 # Reset the counter to avoid repeated size reductions\n\n                    # Regenerate the population\n                    population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n                    fitness = np.array([func(x) for x in population])\n                    self.budget -= self.pop_size\n            \n            if self.budget <= 0:\n                break\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "In the code, line 76, in __call__, the following error occurred:\nNameError: name 'minimize' is not defined\nOn line: result = minimize(func, population[idx], bounds=Bounds(self.lb, self.ub), method='L-BFGS-B', options={'maxfun': 20}) # Reduced maxfun", "error": "In the code, line 76, in __call__, the following error occurred:\nNameError: name 'minimize' is not defined\nOn line: result = minimize(func, population[idx], bounds=Bounds(self.lb, self.ub), method='L-BFGS-B', options={'maxfun': 20}) # Reduced maxfun", "parent_ids": ["9da799c3-0dfd-4aab-baf7-9529b5afb154"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "87dd11b8-6b22-48ab-9829-7887e68c1a44", "fitness": "-inf", "name": "AdaptiveHybridPSO_CMAES", "description": "Adaptively blends PSO and CMA-ES by monitoring stagnation and dynamically allocating budget between exploration (PSO) and exploitation (CMA-ES).", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20, pso_inertia=0.7, pso_cognitive=1.4, pso_social=1.4, cmaes_sigma=0.5, stagnation_threshold=1e-6, pso_fraction=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia = pso_inertia\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.stagnation_threshold = stagnation_threshold\n        self.pso_fraction = pso_fraction # Initial fraction of budget allocated to PSO\n        self.population = None  # Initialize population\n        self.last_improvement = 0 # Iteration when the last improvement was found\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim)) # initialize velocities\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n        self.last_improvement = 0\n\n        # Initialize CMA-ES parameters\n        mean = np.mean(population, axis=0)\n        covariance = np.eye(self.dim)\n        \n        iteration = 0\n        while self.budget > 0:\n            iteration += 1\n\n            # Adaptive budget allocation\n            pso_budget = int(self.budget * self.pso_fraction)\n            cmaes_budget = self.budget - pso_budget\n            \n            # PSO update\n            for i in range(self.pop_size):\n                if pso_budget <= 0:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocities[i] = (self.pso_inertia * velocities[i] +\n                                 self.pso_cognitive * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.pso_social * r2 * (global_best_position - population[i]))\n                \n                population[i] = population[i] + velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n                \n                fitness = func(population[i])\n                self.budget -= 1\n                pso_budget -=1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_positions[i] = population[i].copy()\n                    \n                    if fitness < global_best_fitness:\n                        global_best_fitness = fitness\n                        global_best_position = population[i].copy()\n                        self.last_improvement = iteration\n            \n            # CMA-ES adaptation\n            if cmaes_budget > self.pop_size :\n                # Generate CMA-ES samples\n                z = np.random.multivariate_normal(np.zeros(self.dim), covariance, self.pop_size)\n                cmaes_samples = mean + self.cmaes_sigma * z\n                cmaes_samples = np.clip(cmaes_samples, lb, ub)\n\n                cmaes_fitness = np.zeros(self.pop_size)\n                for i in range(self.pop_size):\n                  cmaes_fitness[i] = func(cmaes_samples[i])\n                  self.budget -= 1\n                  cmaes_budget -=1\n\n                # Select best CMA-ES samples and update mean and covariance\n                best_cmaes_indices = np.argsort(cmaes_fitness)[:self.pop_size // 2]  # Select top 50%\n                best_cmaes_samples = cmaes_samples[best_cmaes_indices]\n                \n                mean = np.mean(best_cmaes_samples, axis=0)\n\n                # Update covariance (simplified - can be improved with CMA-ES update rules)\n                covariance = np.cov(best_cmaes_samples, rowvar=False)\n                \n                # Replace worst PSO particles with best CMA-ES particles (elitism)\n                worst_pso_indices = np.argsort(personal_best_fitness)[-self.pop_size // 2:]\n                population[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_positions[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices]\n                \n                # Update global best\n                global_best_index = np.argmin(personal_best_fitness)\n                global_best_position = personal_best_positions[global_best_index]\n                global_best_fitness = personal_best_fitness[global_best_index]\n                \n            # Stagnation Check and Adaptive pso_fraction update:\n            if iteration - self.last_improvement > 200 : #Stagnation detected\n                self.pso_fraction = max(0.1, self.pso_fraction - 0.1) # Reduce PSO, increase CMAES.\n            elif self.last_improvement > 0 and iteration - self.last_improvement < 50 :\n                self.pso_fraction = min(0.9, self.pso_fraction + 0.1)\n\n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "0766e335-e76e-4363-9db4-4743b1abbe97", "fitness": 0.2836408203318149, "name": "SocialSpiderOptimization", "description": "A population-based algorithm inspired by the foraging behavior of social spiders, combining elements of PSO and DE for efficient exploration and exploitation with dynamic parameter adjustments.", "code": "import numpy as np\n\nclass SocialSpiderOptimization:\n    def __init__(self, budget=10000, dim=10, n_spiders=30, p_crossover=0.7, p_mutation=0.1, social_influence=0.5):\n        \"\"\"\n        Initializes the Social Spider Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_spiders (int): The number of spiders in the population.\n            p_crossover (float): Probability of crossover.\n            p_mutation (float): Probability of mutation.\n            social_influence (float): Influence of the best spider on others.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_spiders = n_spiders\n        self.p_crossover = p_crossover\n        self.p_mutation = p_mutation\n        self.social_influence = social_influence\n        self.population = None\n        self.fitness = None\n        self.best_spider = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.evaluations = 0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Social Spider Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.population = np.random.uniform(low=self.bounds.lb, high=self.bounds.ub, size=(self.n_spiders, self.dim))\n        self.fitness = np.zeros(self.n_spiders)\n        \n        for i in range(self.n_spiders):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_spider = self.population[i].copy()\n\n            if self.evaluations >= self.budget:\n                return self.best_fitness, self.best_spider\n\n\n        while self.evaluations < self.budget:\n            for i in range(self.n_spiders):\n                # Social Foraging: Move towards better spiders (PSO-like)\n                best_neighbor_index = np.argmin(self.fitness)\n                if i != best_neighbor_index:\n                    r1 = np.random.rand(self.dim)\n                    self.population[i] += r1 * self.social_influence * (self.population[best_neighbor_index] - self.population[i])\n\n                # Differential Evolution-like mutation\n                if np.random.rand() < self.p_mutation:\n                    indices = np.random.choice(self.n_spiders, 3, replace=False)\n                    x1, x2, x3 = self.population[indices[0]], self.population[indices[1]], self.population[indices[2]]\n                    F = 0.8 # Scaling factor\n                    mutated_spider = self.population[i] + F * (x2 - x3)\n                    mutated_spider = np.clip(mutated_spider, self.bounds.lb, self.bounds.ub)\n\n                    # Crossover\n                    if np.random.rand() < self.p_crossover:\n                        cross_points = np.random.rand(self.dim) < 0.5\n                        self.population[i][cross_points] = mutated_spider[cross_points]\n                    else:\n                        self.population[i] = mutated_spider\n                        \n                self.population[i] = np.clip(self.population[i], self.bounds.lb, self.bounds.ub) # Clip after mutation and crossover\n\n                new_fitness = func(self.population[i])\n                self.evaluations += 1\n\n                if new_fitness < self.fitness[i]:\n                    self.fitness[i] = new_fitness\n\n                    if new_fitness < self.best_fitness:\n                        self.best_fitness = new_fitness\n                        self.best_spider = self.population[i].copy()\n                \n                if self.evaluations >= self.budget:\n                    return self.best_fitness, self.best_spider\n\n        return self.best_fitness, self.best_spider", "configspace": "", "generation": 2, "feedback": "The algorithm SocialSpiderOptimization scored 0.284 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7dde1d4a-c58e-49c1-9d07-f1620c8c8886"], "operator": null, "metadata": {"aucs": [0.0973694048526168, 0.2339381953906503, 0.2883370230827367, 0.20421354668665048, 0.1688134422279638, 0.18480071127071218, 0.2188050263424346, 0.26649152592727055, 0.1916535730308606, 0.15574698003710497, 0.1744396601842889, 0.9946376637531206, 0.2543360035896294, 0.207423943401283, 0.6452535958275039, 0.28552248109588607, 0.25321590840965513, 0.2644082219981282, 0.17427291060226802, 0.4091365889255342]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "5fb3fef8-17ad-44e8-be46-7652d24b7c9e", "fitness": "-inf", "name": "GuidedRandomSearchPowell", "description": "A novel hybrid algorithm combining the strengths of a Guided Random Search with a Gradient-Free Optimization method (Powell's method) for efficient global exploration and local refinement.", "code": "import numpy as np\nfrom scipy.optimize import minimize_scalar\nfrom scipy.linalg import solve\n\nclass GuidedRandomSearchPowell:\n    def __init__(self, budget=10000, dim=10, n_samples=50, guide_prob=0.2, step_size=0.1):\n        \"\"\"\n        Initializes the Guided Random Search with Powell's method algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_samples (int): Number of random samples to generate at each iteration.\n            guide_prob (float): Probability of using the best solution to guide the search.\n            step_size (float): Initial step size for Powell's method.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_samples = n_samples\n        self.guide_prob = guide_prob\n        self.step_size = step_size\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.evaluations = 0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Guided Random Search with Powell's method.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n        self.bounds = func.bounds\n        self.best_solution = np.random.uniform(self.bounds.lb, self.bounds.ub)\n        self.best_fitness = func(self.best_solution)\n        self.evaluations = 1\n\n        while self.evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n\n            # Guided Random Search\n            for _ in range(self.n_samples):\n                if np.random.rand() < self.guide_prob:\n                    # Guided Search: Sample around the best solution\n                    x = np.random.normal(self.best_solution, self.step_size * (self.bounds.ub - self.bounds.lb))\n                    x = np.clip(x, self.bounds.lb, self.bounds.ub)\n\n                else:\n                    # Random Search: Sample uniformly\n                    x = np.random.uniform(self.bounds.lb, self.bounds.ub)\n\n                f = func(x)\n                self.evaluations += 1\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if self.evaluations >= self.budget:\n                    break\n\n            # Powell's Method (Gradient-Free Local Search) - Restart from best solution\n            self.best_solution = self.powell_method(func, self.best_solution)\n            self.best_fitness = func(self.best_solution)\n            self.evaluations += 1\n\n            if self.evaluations >= self.budget:\n                break\n\n        return self.best_fitness, self.best_solution\n\n    def powell_method(self, func, x0, tol=1e-4, max_iter=5):\n        \"\"\"\n        Powell's gradient-free optimization method.\n\n        Args:\n            func (callable): The black-box function to optimize.\n            x0 (np.ndarray): Initial solution vector.\n            tol (float): Tolerance for convergence.\n            max_iter (int): Maximum number of iterations.\n\n        Returns:\n            np.ndarray: Optimized solution vector.\n        \"\"\"\n        x = x0.copy()\n        directions = np.eye(self.dim)  # Initial search directions (coordinate axes)\n\n        for _ in range(max_iter):\n            for i in range(self.dim):\n                direction = directions[:, i]\n\n                # 1D optimization along the direction\n                def f1d(alpha):\n                    x_new = x + alpha * direction\n                    x_new = np.clip(x_new, self.bounds.lb, self.bounds.ub)\n                    return func(x_new)\n\n                result = minimize_scalar(f1d, method='bounded', bounds=(-1, 1))  # Bounded alpha for stability\n                alpha_opt = result.x\n                x = x + alpha_opt * direction\n                x = np.clip(x, self.bounds.lb, self.bounds.ub)\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return x\n\n        return x", "configspace": "", "generation": 2, "feedback": "In the code, line 105, in powell_method, the following error occurred:\nNameError: name 'minimize_scalar' is not defined\nOn line: result = minimize_scalar(f1d, method='bounded', bounds=(-1, 1))  # Bounded alpha for stability", "error": "In the code, line 105, in powell_method, the following error occurred:\nNameError: name 'minimize_scalar' is not defined\nOn line: result = minimize_scalar(f1d, method='bounded', bounds=(-1, 1))  # Bounded alpha for stability", "parent_ids": ["7dde1d4a-c58e-49c1-9d07-f1620c8c8886"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "4767cff2-c8c8-451a-95e0-3d7007bf7832", "fitness": "-inf", "name": "AdaptiveHybridPSO_CMAES", "description": "Adaptively blends PSO and CMA-ES by dynamically adjusting the population split based on performance and remaining budget, while also incorporating a mutation operator for diversification.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20, pso_inertia=0.7, pso_cognitive=1.4, pso_social=1.4, cmaes_sigma=0.5, mutation_rate=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia = pso_inertia\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.mutation_rate = mutation_rate\n        self.population = None  # Initialize population\n        self.pso_pop_size = pop_size // 2 # Initial split between PSO and CMAES\n        self.cmaes_pop_size = pop_size - self.pso_pop_size\n        self.pso_fitness_history = []\n        self.cmaes_fitness_history = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        pso_population = np.random.uniform(lb, ub, size=(self.pso_pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pso_pop_size, self.dim)) # initialize velocities\n        personal_best_positions = pso_population.copy()\n        personal_best_fitness = np.array([func(x) for x in pso_population])\n        self.budget -= self.pso_pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n\n        # Initialize CMA-ES parameters\n        mean = np.random.uniform(lb, ub, size=(self.dim))\n        covariance = np.eye(self.dim)\n\n        # Initialize CMA-ES population\n        cmaes_population = np.random.multivariate_normal(mean, covariance, self.cmaes_pop_size)\n        cmaes_population = np.clip(cmaes_population, lb, ub)\n\n        cmaes_fitness = np.array([func(x) for x in cmaes_population])\n        self.budget -= self.cmaes_pop_size\n\n\n        #Combine populations for easier handling and selection\n        population = np.concatenate((pso_population, cmaes_population))\n        fitnesses = np.concatenate((personal_best_fitness, cmaes_fitness))\n\n        while self.budget > 0:\n\n            # PSO update\n            for i in range(self.pso_pop_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocities[i] = (self.pso_inertia * velocities[i] +\n                                 self.pso_cognitive * r1 * (personal_best_positions[i] - pso_population[i]) +\n                                 self.pso_social * r2 * (global_best_position - pso_population[i]))\n                \n                pso_population[i] = pso_population[i] + velocities[i]\n                pso_population[i] = np.clip(pso_population[i], lb, ub)\n\n                # Mutation\n                mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n                pso_population[i][mutation_mask] = np.random.uniform(lb, ub, size=np.sum(mutation_mask))\n                \n                fitness = func(pso_population[i])\n                self.budget -= 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_positions[i] = pso_population[i].copy()\n                    \n                    if fitness < global_best_fitness:\n                        global_best_fitness = fitness\n                        global_best_position = pso_population[i].copy()\n\n            # CMA-ES adaptation\n            if self.budget > self.cmaes_pop_size:\n                # Generate CMA-ES samples\n                z = np.random.multivariate_normal(np.zeros(self.dim), covariance, self.cmaes_pop_size)\n                cmaes_population = mean + self.cmaes_sigma * z\n                cmaes_population = np.clip(cmaes_population, lb, ub)\n\n                cmaes_fitness = np.zeros(self.cmaes_pop_size)\n                for i in range(self.cmaes_pop_size):\n                  cmaes_fitness[i] = func(cmaes_population[i])\n                  self.budget -= 1\n                \n                # Select best CMA-ES samples and update mean and covariance\n                best_cmaes_indices = np.argsort(cmaes_fitness)[:self.cmaes_pop_size // 2]  # Select top 50%\n                best_cmaes_samples = cmaes_population[best_cmaes_indices]\n                \n                mean = np.mean(best_cmaes_samples, axis=0)\n\n                # Update covariance (simplified - can be improved with CMA-ES update rules)\n                covariance = np.cov(best_cmaes_samples, rowvar=False)\n\n                #Mutation for CMAES population\n                for i in range(self.cmaes_pop_size):\n                    mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n                    cmaes_population[i][mutation_mask] = np.random.uniform(lb, ub, size=np.sum(mutation_mask))\n\n                # Replace worst PSO particles with best CMA-ES particles (elitism)\n                worst_pso_indices = np.argsort(personal_best_fitness)[-self.cmaes_pop_size // 2:] #Take the worst half of PSO population\n                pso_population[worst_pso_indices] = cmaes_population[:self.cmaes_pop_size // 2].copy() #replace with the best half from CMAES\n                personal_best_positions[worst_pso_indices] = cmaes_population[:self.cmaes_pop_size // 2].copy()\n                personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices].copy()\n\n                # Update global best\n                global_best_index_pso = np.argmin(personal_best_fitness)\n                if cmaes_fitness.min() < global_best_fitness:\n                     global_best_fitness = cmaes_fitness.min()\n                     global_best_position = cmaes_population[np.argmin(cmaes_fitness)].copy()\n                elif personal_best_fitness[global_best_index_pso] < global_best_fitness:\n                    global_best_fitness = personal_best_fitness[global_best_index_pso]\n                    global_best_position = personal_best_positions[global_best_index_pso].copy()\n\n            # Adaptive Population Adjustment (based on a simplified metric)\n            if len(self.pso_fitness_history) > 5 and len(self.cmaes_fitness_history) > 5:\n                pso_improvement = np.mean(self.pso_fitness_history[-5:]) - np.mean(personal_best_fitness)\n                cmaes_improvement = np.mean(self.cmaes_fitness_history[-5:]) - np.mean(cmaes_fitness)\n\n                if pso_improvement > cmaes_improvement and self.pso_pop_size < self.pop_size - 1:\n                    self.pso_pop_size += 1\n                    self.cmaes_pop_size -= 1\n                elif cmaes_improvement > pso_improvement and self.cmaes_pop_size < self.pop_size -1:\n                    self.cmaes_pop_size += 1\n                    self.pso_pop_size -= 1\n\n                #Update population sizes\n                pso_population = personal_best_positions\n                cmaes_population = cmaes_population\n\n            self.pso_fitness_history.append(np.mean(personal_best_fitness))\n            self.cmaes_fitness_history.append(np.mean(cmaes_fitness))\n\n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "In the code, line 784, in numpy.PyArray_MultiIterNew3, the following error occurred:\nValueError: shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (0,) and arg 1 with shape (2,).", "error": "In the code, line 784, in numpy.PyArray_MultiIterNew3, the following error occurred:\nValueError: shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (0,) and arg 1 with shape (2,).", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "8e5beb70-b62f-48b2-a47d-bb0d2111f3bb", "fitness": "-inf", "name": "EnhancedAntColonyOptimization", "description": "Adaptively biases ant movement towards promising regions by adjusting step sizes based on fitness improvements and dynamically manages pheromone evaporation and deposit rates using a convergence-based strategy and weighted averaging of best solutions.", "code": "import numpy as np\n\nclass EnhancedAntColonyOptimization:\n    def __init__(self, budget=10000, dim=10, n_ants=20, evaporation_rate=0.1, alpha=1, beta=2, q=1.0, initial_step_size=0.1):\n        \"\"\"\n        Initializes the Enhanced Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            alpha (float): Importance of pheromone.\n            beta (float): Importance of heuristic information (fitness).\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_step_size (float): Initial step size for ant movements.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.alpha = alpha\n        self.beta = beta\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.step_size = initial_step_size\n        self.convergence_count = 0\n        self.prev_best_fitness = np.inf\n        self.best_solutions_history = []\n        self.history_length = 5  # Number of past best solutions to consider\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Enhanced Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones((self.dim, 2))\n        evaluations = 0\n\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n                    self.best_solutions_history.append(x)\n                    if len(self.best_solutions_history) > self.history_length:\n                        self.best_solutions_history.pop(0)\n\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n\n            # Adaptive step size and evaporation rate based on convergence\n            if abs(self.best_fitness - self.prev_best_fitness) < 1e-6:\n                self.convergence_count += 1\n                if self.convergence_count > 10:\n                    self.step_size *= 0.9  # Reduce step size if stuck\n                    self.evaporation_rate = min(self.evaporation_rate * 1.1, 0.9)  # Increase evaporation\n            else:\n                self.convergence_count = 0\n                self.step_size = 0.1 # Reset step size\n                self.evaporation_rate = 0.1 # Reset evaporation rate\n\n\n            self.prev_best_fitness = self.best_fitness\n\n            # Dynamic Pheromone Evaporation: Increased exploration if fitness plateaus\n            if self.convergence_count > 10:\n              self.pheromone *= (1 + self.evaporation_rate)\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution and past best solutions.\n        \"\"\"\n        x = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Bias towards the best solution\n            if self.best_solution is not None and np.random.rand() < 0.7:  # 70% probability to explore near best solution\n\n                # Weighted average of past best solutions\n                if self.best_solutions_history:\n                    weights = np.linspace(0.1, 1.0, len(self.best_solutions_history))\n                    weights /= np.sum(weights)  # Normalize weights\n                    weighted_avg = np.average([sol[i] for sol in self.best_solutions_history], weights=weights)\n                    x[i] = np.random.normal(weighted_avg, self.step_size * (self.bounds.ub[i] - self.bounds.lb[i]))\n                else:\n                    x[i] = np.random.normal(self.best_solution[i], self.step_size * (self.bounds.ub[i] - self.bounds.lb[i]))\n\n\n            else:\n                pheromone_lower = self.pheromone[i, 0]\n                pheromone_upper = self.pheromone[i, 1]\n                if np.random.rand() < (pheromone_lower / (pheromone_lower + pheromone_upper)):\n                    x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.lb[i] + self.step_size * (self.bounds.ub[i] - self.bounds.lb[i]))\n                else:\n                    x[i] = np.random.uniform(self.bounds.ub[i] - self.step_size * (self.bounds.ub[i] - self.bounds.lb[i]), self.bounds.ub[i])\n\n        x = np.clip(x, self.bounds.lb, self.bounds.ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions more significantly and normalizing pheromone deposits.\n        \"\"\"\n        delta_pheromone = np.zeros((self.dim, 2))\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n\n            # Higher pheromone deposit for better solutions\n            deposit = self.q / (1 + f - self.best_fitness)\n            for j in range(self.dim):\n                if x[j] < (self.bounds.lb[j] + 0.5 * (self.bounds.ub[j] - self.bounds.lb[j])):\n                    delta_pheromone[j, 0] += deposit\n                else:\n                    delta_pheromone[j, 1] += deposit\n\n        # Normalize pheromone deposits to prevent domination by single dimensions\n        if np.sum(delta_pheromone) > 0:\n            delta_pheromone /= np.sum(delta_pheromone) + 1e-9\n\n        self.pheromone += delta_pheromone", "configspace": "", "generation": 2, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["7dde1d4a-c58e-49c1-9d07-f1620c8c8886"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "25342f08-ae72-4887-8449-419b83d4a602", "fitness": 0.3203393304433135, "name": "AdaptiveACO", "description": "An adaptive ACO variant with dynamic exploration range based on performance, and pheromone updates based on ant quality, focusing on global best intensification with occasional diversification.", "code": "import numpy as np\n\nclass AdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.1, q=1.0, initial_exploration=0.3,\n                 intensification_factor=1.2):\n        \"\"\"\n        Initializes the Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            intensification_factor (float): Factor to increase exploration range when performance is good.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.intensification_factor = intensification_factor\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim) * 0.5  # Initialize pheromone with 0.5\n        evaluations = 0\n        convergence_count = 0\n        prev_best_fitness = np.inf\n        stagnation_count = 0\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0)\n\n            # Adaptive exploration range based on convergence\n            if abs(self.best_fitness - prev_best_fitness) < 1e-7:\n                convergence_count += 1\n                stagnation_count += 1  # Increment stagnation counter\n                if stagnation_count > 10:  # More aggressive stagnation detection\n                   self.exploration_range = min(0.5, self.exploration_range * self.intensification_factor)\n                   stagnation_count = 0 #reset stagnation count after increasing exploration\n            else:\n                convergence_count = 0\n                stagnation_count = 0\n                self.exploration_range = max(0.05, self.exploration_range * 0.95) # Gradually shrink exploration\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution.\n        \"\"\"\n        x = np.zeros(self.dim)\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            x = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n        else:\n            # Exploration around the best solution, guided by pheromones\n            for i in range(self.dim):\n                lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions.\n        \"\"\"\n        # Pheromone update based on solution quality relative to the best\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n            # Stronger pheromone deposit for better ants\n            pheromone_deposit = self.q * (self.best_fitness - f) / (abs(f) + 1e-9) #Avoid division by zero\n\n            #Update pheromone for each dimension, weighted by pheromone deposit\n            self.pheromone += pheromone_deposit * (x - self.best_solution) / (np.abs(self.best_solution) + 1e-9) #Directional update, scaled by distance to best solution. Avoid division by zero.\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0)", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveACO scored 0.320 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["865217d9-70da-4225-8c7f-a34564f74097"], "operator": null, "metadata": {"aucs": [0.160533060213484, 0.17862530145409472, 0.42664002123004385, 0.17619035644534853, 0.26576797901871807, 0.4186356313023951, 0.27142254351117767, 0.4231442332119042, 0.1709320377288357, 0.19331701751281394, 0.18736308927287326, 0.882840238784389, 0.25302516665792674, 0.22732371786036876, 0.2811289757727623, 0.3009513961502247, 0.26444732419281336, 0.6987029130363177, 0.12255869313184709, 0.5032369123779304]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "1e48d60e-6009-44af-bb19-187fb8cc5d3c", "fitness": 0.3093230688783622, "name": "AdaptiveACO", "description": "Adaptive ACO with dynamic pheromone scaling and solution perturbation to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass AdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.05, q=1.0, initial_exploration=0.2, perturbation_rate=0.1):\n        \"\"\"\n        Initializes the Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            perturbation_rate (float): Rate at which the best solution is perturbed to avoid stagnation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.perturbation_rate = perturbation_rate\n        self.pheromone_scaling = 1.0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim)  # Single pheromone value per dimension\n        evaluations = 0\n        convergence_count = 0\n        prev_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n\n            # Adaptive exploration range and pheromone scaling based on convergence\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                convergence_count += 1\n                if convergence_count > 5:\n                    self.exploration_range *= 0.9  # Reduce exploration if stuck\n                    self.pheromone_scaling *= 0.9 # Scale down pheromone influence\n                    # Perturb the best solution to escape local optima\n                    self.best_solution = self.perturb_solution(self.best_solution)\n                    self.best_solution = np.clip(self.best_solution, self.bounds.lb, self.bounds.ub)\n\n            else:\n                convergence_count = 0\n                self.exploration_range = 0.2 # Reset exploration range\n                self.pheromone_scaling = 1.0 # Reset pheromone scaling\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution.\n        \"\"\"\n        x = np.zeros(self.dim)\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            x = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n        else:\n            # Exploration around the best solution, guided by pheromones\n            for i in range(self.dim):\n                lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i] * self.pheromone_scaling)\n                ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i] * self.pheromone_scaling)\n                x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions.\n        \"\"\"\n        delta_pheromone = np.zeros(self.dim)\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n            # Higher pheromone deposit for better solutions, scaled by distance to best solution\n            deposit = self.q / (1 + f - self.best_fitness)\n            delta_pheromone += deposit * np.abs(x - self.best_solution) # Magnitude matters\n\n        self.pheromone += delta_pheromone\n        self.pheromone = np.clip(self.pheromone, 0.01, 1.0) # Prevent pheromone saturation\n\n    def perturb_solution(self, solution):\n        \"\"\"\n        Perturbs the given solution by a small random amount.\n        \"\"\"\n        perturbation = np.random.uniform(-self.perturbation_rate, self.perturbation_rate, self.dim) * (self.bounds.ub - self.bounds.lb)\n        return solution + perturbation", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveACO scored 0.309 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["865217d9-70da-4225-8c7f-a34564f74097"], "operator": null, "metadata": {"aucs": [0.1309178721021511, 0.1617711748100128, 0.28265190427606635, 0.2803302172812093, 0.26075137288162764, 0.28106222934054326, 0.24305252869412275, 0.2281311411085205, 0.2596307304660177, 0.17502563492226586, 0.27088615052378917, 0.9981667932670304, 0.23874948488206715, 0.2520946845401899, 0.6059559425156544, 0.31070118872869745, 0.21778773758109216, 0.345851422379, 0.15804250048263824, 0.48490066678454735]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "c7e44d89-0614-457e-8454-2b28f6aef119", "fitness": "-inf", "name": "AdaptiveHybridDE_NM", "description": "Adaptively combines Differential Evolution with Nelder-Mead, using a restart mechanism and dynamic parameter adjustments based on convergence and remaining budget to balance exploration and exploitation.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridDE_NM:\n    def __init__(self, budget=10000, dim=10, pop_size=40, cr=0.7, f=0.8, nm_iters=5, restart_trigger=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr\n        self.f = f\n        self.nm_iters = nm_iters\n        self.restart_trigger = restart_trigger # Threshold for triggering restart\n        self.initial_budget = budget\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n\n        de_phase = True\n        generation = 0\n        stagnation_counter = 0\n        last_improvement = self.f_opt\n\n        while self.budget > 0:\n            generation += 1\n\n            # Adaptive parameter adjustment based on remaining budget\n            remaining_ratio = self.budget / self.initial_budget\n            cr_adaptive = self.cr * (0.5 + 0.5 * remaining_ratio)  # Decrease CR as budget decreases\n            f_adaptive = self.f * (0.5 + 0.5 / (remaining_ratio + 1e-9)) # Increase F as budget decreases\n            nm_iters_adaptive = int(self.nm_iters * (0.2 + 0.8 * remaining_ratio))\n\n\n            if de_phase:\n                for i in range(self.pop_size):\n                    # Differential Evolution Mutation\n                    idxs = np.random.choice(self.pop_size, 3, replace=False)\n                    x_r1, x_r2, x_r3 = population[idxs]\n                    x_mutated = x_r1 + f_adaptive * (x_r2 - x_r3)\n                    x_mutated = np.clip(x_mutated, lb, ub)\n\n                    # Crossover\n                    x_trial = population[i].copy()\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() < cr_adaptive or j == j_rand:\n                            x_trial[j] = x_mutated[j]\n\n                    # Evaluate trial vector\n                    f_trial = func(x_trial)\n                    self.budget -= 1\n\n                    # Selection\n                    if f_trial < fitness[i]:\n                        fitness[i] = f_trial\n                        population[i] = x_trial\n\n                    # Update overall best\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = x_trial\n                        stagnation_counter = 0 # Reset counter if improved\n\n                    if self.budget <= 0:\n                        break\n\n            else:  # Nelder-Mead Phase\n                for i in range(self.pop_size):\n                    # Apply Nelder-Mead local search to each individual\n                    result = minimize(func, population[i], bounds=func.bounds, method='Nelder-Mead', options={'maxiter': nm_iters_adaptive})\n                    x_nm = result.x\n                    f_nm = result.fun\n                    self.budget -= result.nfev  # Account for Nelder-Mead function evaluations\n\n                    if f_nm < fitness[i]:\n                        fitness[i] = f_nm\n                        population[i] = x_nm\n                    \n                    # Update overall best\n                    if f_nm < self.f_opt:\n                        self.f_opt = f_nm\n                        self.x_opt = x_nm\n                        stagnation_counter = 0\n\n                    if self.budget <= 0:\n                        break\n\n            # Stagnation Check & Restart Mechanism\n            if abs(self.f_opt - last_improvement) < self.restart_trigger * abs(last_improvement): #Use relative improvement\n                stagnation_counter +=1\n            else:\n                stagnation_counter = 0 #Reset counter if improvement occurs\n                last_improvement = self.f_opt\n\n            if stagnation_counter > 50: #If no significant improvement for 50 generations\n                #Restart the population\n                population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n                fitness = np.array([func(x) for x in population])\n                self.budget -= self.pop_size\n                self.f_opt = np.min(fitness)\n                self.x_opt = population[np.argmin(fitness)]\n                stagnation_counter = 0\n                last_improvement = self.f_opt\n                de_phase = True\n\n            # Adaptive switching between DE and NM phases. Favor DE early and NM later\n            if remaining_ratio < 0.3:\n                de_phase = False\n            elif generation % 5 == 0: #alternate every 5 generations if not in final phase\n                de_phase = not de_phase\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "In the code, line 78, in __call__, the following error occurred:\nNameError: name 'minimize' is not defined\nOn line: result = minimize(func, population[i], bounds=func.bounds, method='Nelder-Mead', options={'maxiter': nm_iters_adaptive})", "error": "In the code, line 78, in __call__, the following error occurred:\nNameError: name 'minimize' is not defined\nOn line: result = minimize(func, population[i], bounds=func.bounds, method='Nelder-Mead', options={'maxiter': nm_iters_adaptive})", "parent_ids": ["9da799c3-0dfd-4aab-baf7-9529b5afb154"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "55ac5cad-40cd-45d2-9ec4-0ce083c2ff9f", "fitness": 0.690871268295951, "name": "AdaptiveCulturalDifferentialEvolution", "description": "Adaptive Cultural Differential Evolution with a self-adjusting belief space and mutation strategy based on the success rate of past generations, enhancing exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveCulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f=0.8, initial_belief_space_size=10, belief_space_decay=0.995, mutation_scaling=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = initial_belief_space_size # Size of the belief space for cultural learning\n        self.initial_belief_space_size = initial_belief_space_size\n        self.belief_space_decay = belief_space_decay\n        self.mutation_scaling = mutation_scaling\n        self.success_rate = 0.5  # Initialize success rate\n        self.success_history = []  # Keep track of recent success\n        self.success_window = 10 # Number of past generations to consider for success rate.\n        self.min_belief_space_size = 2 # Avoid belief space becoming too small\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space (best individuals observed so far)\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n        belief_fitness = np.sort(fitness)[:self.belief_space_size].copy()\n\n        generation = 0\n        while self.budget > 0:\n            successful_individuals = 0  # Count successful individuals in this generation\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning: Bias towards best from belief space, adaptively scaled\n                belief_idx = np.random.randint(self.belief_space_size)\n                x_trial = x_trial + self.mutation_scaling * (belief_space[belief_idx] - x_trial)\n                x_trial = np.clip(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    successful_individuals += 1  # Increment successful individuals count\n                    \n                    # Update belief space if necessary\n                    if f_trial < belief_fitness[-1]:\n                        belief_fitness[-1] = f_trial\n                        belief_space[-1] = x_trial\n                        \n                        # Re-sort belief space to maintain order\n                        sorted_indices = np.argsort(belief_fitness)\n                        belief_fitness = belief_fitness[sorted_indices]\n                        belief_space = belief_space[sorted_indices]\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n\n            # Update success rate and adapt mutation scaling\n            success_ratio = successful_individuals / self.pop_size\n            self.success_history.append(success_ratio)\n            if len(self.success_history) > self.success_window:\n                self.success_history.pop(0)\n            self.success_rate = np.mean(self.success_history)\n\n            # Adapt mutation scaling based on success rate\n            if self.success_rate > 0.6:\n                self.mutation_scaling *= 0.95  # Reduce scaling for exploitation\n            elif self.success_rate < 0.3:\n                self.mutation_scaling *= 1.05  # Increase scaling for exploration\n            \n            # Adapt belief space size\n            if generation % 10 == 0: # Adapt belief space size every 10 generations\n               if self.success_rate > 0.7 and self.belief_space_size > self.min_belief_space_size:\n                   self.belief_space_size = int(max(self.belief_space_size * self.belief_space_decay, self.min_belief_space_size)) # Reduce belief space size if success is high\n               elif self.success_rate < 0.2 and self.belief_space_size < self.initial_belief_space_size:\n                   self.belief_space_size = int(min(self.belief_space_size * (1/self.belief_space_decay), self.initial_belief_space_size)) # Increase belief space size if success is low\n\n\n            generation += 1\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveCulturalDifferentialEvolution scored 0.691 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.26333397276823134, 0.690181361969243, 0.6947612420055413, 0.8698247656950329, 0.7548935716031923, 0.7626092523650355, 0.756349440519401, 0.6674732766801096, 0.7185609317536319, 0.749091309434117, 0.8453457268086273, 0.9914938295270764, 0.3558792480513101, 0.792418926985231, 0.8995009384056704, 0.7697946438243908, 0.6691722850589235, 0.8255728009479982, 0.2117534156534041, 0.5294144258628495]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "4b81b125-824d-4eeb-9382-4bc4f5be3533", "fitness": 0.0, "name": "CulturalDifferentialEvolution", "description": "A simplified Cultural Differential Evolution with adaptive parameters and a focused belief space update, emphasizing exploration around the current best solution.", "code": "import numpy as np\n\nclass CulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, cr=0.7, f=0.8, belief_space_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = belief_space_size # Size of the belief space\n\n        self.lb = -5.0\n        self.ub = 5.0\n\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            # Adaptive parameter adjustment (example)\n            cr = self.cr * (0.9 + 0.1 * np.cos(2 * np.pi * generation / 100)) # modulate cr\n            f = self.f * (0.9 + 0.1 * np.sin(2 * np.pi * generation / 100))   # modulate f\n            \n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, self.lb, self.ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning: Bias towards best, but less aggressive\n                best_idx = np.argmin(fitness) # Use the best from current population.\n\n                x_trial = x_trial + 0.05 * (population[best_idx] - x_trial) # Less bias\n                x_trial = np.clip(x_trial, self.lb, self.ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n                if self.budget <= 0:\n                    break\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                    # Update belief space: Only replace worst if better than the worst *and* significantly better than existing best\n                    worst_belief_idx = np.argmax([func(x) for x in belief_space]) # Find the index of worst in belief space with func calls\n\n                    if f_trial < func(belief_space[worst_belief_idx]) and f_trial < self.f_opt * 0.99: #significant improvement check.\n                         belief_space[worst_belief_idx] = x_trial\n                         \n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm CulturalDifferentialEvolution scored 0.000 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "7c2912fe-c1b1-4f30-9d46-452f44934abc", "fitness": 0.4758253911027249, "name": "CulturalDifferentialEvolution", "description": "A simplified Cultural Differential Evolution strategy with adaptive parameter control and focused belief space influence.", "code": "import numpy as np\n\nclass CulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, cr=0.7, f=0.8, belief_space_size=5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = belief_space_size # Size of the belief space\n        self.exploration_rate = 0.1  # Controls the influence of the belief space\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space (best individuals observed so far)\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            \n            # Adaptive parameter control\n            adaptive_cr = self.cr * (0.5 + 0.5 * np.exp(-10 * generation / self.budget)) # Decrease cr over time\n            adaptive_f = self.f * (0.5 + 0.5 * np.exp(10 * generation / self.budget)) # Increase f over time\n\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + adaptive_f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < adaptive_cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning: Bias towards best from belief space, but only for some individuals\n                if np.random.rand() < self.exploration_rate:\n                    belief_idx = np.random.randint(self.belief_space_size)\n                    x_trial = x_trial + 0.1 * (belief_space[belief_idx] - x_trial)\n                    x_trial = np.clip(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                    # Update belief space (replace worst in belief space if trial is better)\n                    if f_trial < np.max(fitness[np.argsort(fitness)[:self.belief_space_size]]):\n                        worst_belief_idx = np.argmax(fitness[np.argsort(fitness)[:self.belief_space_size]])\n                        \n                        belief_space[worst_belief_idx] = x_trial\n                        fitness[np.argsort(fitness)[:self.belief_space_size][worst_belief_idx]] = f_trial\n\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n            \n            #Dynamically adjust exploration rate\n            if generation % 100 == 0:\n                if np.std(fitness) < 1e-6:\n                    self.exploration_rate = min(1.0, self.exploration_rate * 1.2)\n                else:\n                    self.exploration_rate = max(0.01, self.exploration_rate * 0.9)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm CulturalDifferentialEvolution scored 0.476 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.1767285199103349, 0.23994581465972786, 0.41792573720697734, 0.7452884368025013, 0.44488475588581555, 0.5622850546200029, 0.32585435989829004, 0.41784755341394164, 0.47710570292386834, 0.2791283498908972, 0.6536498566944773, 0.9904559893190938, 0.26882892180649653, 0.4296344592142477, 0.7800519387581838, 0.5485785607586238, 0.3602851412629553, 0.7100006225999806, 0.19008466209480057, 0.4979433843332808]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "b4b7c00a-f611-4ce5-b735-15bf8ba003ac", "fitness": 0.4840621406884189, "name": "SaDE_NS", "description": "A novel hybrid optimization algorithm that combines a self-adaptive Differential Evolution (SaDE) with a Neighborhood Search (NS) strategy, adaptively adjusting search parameters based on the local fitness landscape.", "code": "import numpy as np\n\nclass SaDE_NS:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9, ns_radius=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.ns_radius = ns_radius\n        self.population = None\n\n        # SaDE parameter history for self-adaptation\n        self.success_F = np.ones(2) * 0.5\n        self.success_CR = np.ones(2) * 0.9\n        self.strategy_success_count = np.zeros(2)\n        self.strategy_attempt_count = np.zeros(2)\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        while self.budget > 0:\n            new_population = np.copy(population)\n            new_fitness = np.copy(fitness)\n\n            for i in range(self.pop_size):\n                # Strategy Selection (SaDE)\n                strategy = np.random.randint(0, 2)\n\n                if strategy == 0:\n                    # DE strategy 1: DE/rand/1\n                    a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                    while a == i or b == i or c == i:\n                        a, b, c = np.random.choice(self.pop_size, 3, replace=False)\n                    \n                    mutant = population[a] + self.F * (population[b] - population[c])\n                    mutant = np.clip(mutant, lb, ub)\n                    \n                    # Crossover\n                    cross_mask = np.random.rand(self.dim) < self.CR\n                    trial_vector = np.where(cross_mask, mutant, population[i])\n\n\n                elif strategy == 1:\n                    # DE strategy 2: DE/current-to-rand/1\n                    a, b = np.random.choice(self.pop_size, 2, replace=False)\n                    while a == i or b == i:\n                        a, b = np.random.choice(self.pop_size, 2, replace=False)\n\n                    mutant = population[i] + self.F * (population[a] - population[b])\n                    mutant = np.clip(mutant, lb, ub)\n\n                    # Crossover\n                    cross_mask = np.random.rand(self.dim) < self.CR\n                    trial_vector = np.where(cross_mask, mutant, population[i])\n                \n                else:\n                    raise ValueError(\"Invalid strategy selected\")\n\n                # Evaluation\n                trial_fitness = func(trial_vector)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n                    self.strategy_success_count[strategy] += 1\n\n                self.strategy_attempt_count[strategy] += 1\n\n                # Neighborhood Search (NS) - applied with probability 0.2\n                if np.random.rand() < 0.2:\n                    neighbor = population[i] + np.random.uniform(-self.ns_radius, self.ns_radius, self.dim)\n                    neighbor = np.clip(neighbor, lb, ub)\n                    neighbor_fitness = func(neighbor)\n                    self.budget -= 1\n\n                    if neighbor_fitness < new_fitness[i]:\n                        new_population[i] = neighbor\n                        new_fitness[i] = neighbor_fitness\n\n                if self.budget <= 0:\n                    break\n\n            # Update population and fitness\n            population = new_population\n            fitness = new_fitness\n\n            # SaDE Parameter Adaptation\n            for strategy in range(2):\n                if self.strategy_attempt_count[strategy] > 0:\n                    success_rate = self.strategy_success_count[strategy] / self.strategy_attempt_count[strategy]\n                    if success_rate > 0:\n                        self.success_F[strategy] = 0.9 * self.success_F[strategy] + 0.1 * success_rate\n                        self.success_CR[strategy] = 0.9 * self.success_CR[strategy] + 0.1 * success_rate\n\n            self.F = np.mean(self.success_F)\n            self.CR = np.mean(self.success_CR)\n\n\n            # Reset success and attempt counts\n            self.strategy_success_count[:] = 0\n            self.strategy_attempt_count[:] = 0\n\n        best_index = np.argmin(fitness)\n        self.f_opt = fitness[best_index]\n        self.x_opt = population[best_index]\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "The algorithm SaDE_NS scored 0.484 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {"aucs": [0.16349072446424562, 0.3165472463031147, 0.5167698324978096, 0.485999036745579, 0.33919596235700067, 0.7554347032708053, 0.38755476559196766, 0.4662555839607332, 0.4706124883304227, 0.18901231315327127, 0.5346596690324266, 0.9986407661142185, 0.2625610679364542, 0.3100953206418563, 0.7512184494888996, 0.7712137094496463, 0.4183100948122779, 0.8226273988408968, 0.2128378369646282, 0.508205843812124]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "590b0dc2-beb8-4e9b-b4e1-87f6073e88ce", "fitness": 0.5451632176388606, "name": "AdaptiveACO", "description": "Adaptive ACO with dynamic pheromone scaling and solution perturbation, balancing exploration and exploitation using the best solution and pheromone information.", "code": "import numpy as np\n\nclass AdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.1, q=1.0, initial_exploration=0.3, perturbation_rate=0.05):\n        \"\"\"\n        Initializes the Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            perturbation_rate (float): Probability of perturbing a dimension in a solution.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.perturbation_rate = perturbation_rate\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim)  # Single pheromone value per dimension\n        evaluations = 0\n        convergence_count = 0\n        prev_best_fitness = np.inf\n        initial_pheromone = np.ones(self.dim) # Store initial pheromone\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0)\n\n            # Adaptive exploration range based on convergence\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                convergence_count += 1\n                if convergence_count > 5:\n                    self.exploration_range *= 0.7  # Reduce exploration if stuck\n                    self.pheromone = initial_pheromone * 0.5 #reset pheromone partly\n            else:\n                convergence_count = 0\n                self.exploration_range = 0.3  # Reset exploration range\n                self.pheromone = initial_pheromone # reset pheromone\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution.\n        \"\"\"\n        x = np.zeros(self.dim)\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            x = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n        else:\n            # Exploration around the best solution, guided by pheromones\n            x = self.best_solution.copy()\n            for i in range(self.dim):\n                if np.random.rand() < self.perturbation_rate:  # Perturbation\n                    x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n                else:\n                    lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                    ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                    x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions.\n        \"\"\"\n        avg_fitness = np.mean(fitnesses)\n\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n\n            # Pheromone deposit proportional to fitness improvement relative to average\n            if f < avg_fitness:\n                deposit = self.q * (avg_fitness - f) / (avg_fitness + 1e-9)  # Avoid division by zero\n                self.pheromone += deposit * np.abs(x - self.best_solution)\n\n        # Normalize pheromone updates\n        self.pheromone /= np.sum(self.pheromone) + 1e-9", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveACO scored 0.545 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["865217d9-70da-4225-8c7f-a34564f74097"], "operator": null, "metadata": {"aucs": [0.18824698312181376, 0.17749518183940305, 0.55931428312977, 0.927701324052217, 0.47369614342738053, 0.7978082577387838, 0.36100072118398174, 0.5692770659882507, 0.5949616279925423, 0.17183009021227913, 0.9284574776978344, 0.9984100069054309, 0.2500235963413112, 0.3056475236758661, 0.7698469753223307, 0.8260310187956633, 0.39722728761595694, 0.9125421653079198, 0.18771164132941343, 0.5060349810990612]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "94491ede-4777-45ba-b495-cfc2e6ba28a4", "fitness": 0.593866835667799, "name": "AdaptiveACO", "description": "An enhanced Ant Colony Optimization with adaptive pheromone updates, dynamic exploration range adjustment based on stagnation detection, and a solution perturbation mechanism guided by pheromone levels, promoting a balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.1, q=1.0, initial_exploration=0.3, perturbation_rate=0.05, stagnation_threshold=5):\n        \"\"\"\n        Initializes the Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            perturbation_rate (float): Probability of perturbing a dimension in a solution.\n            stagnation_threshold (int): Number of iterations without improvement before exploration range reduction.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.perturbation_rate = perturbation_rate\n        self.stagnation_threshold = stagnation_threshold\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim) * 0.5  # Initialize pheromone\n        evaluations = 0\n        stagnation_counter = 0\n        prev_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0)\n\n\n            # Stagnation detection and adaptive exploration range\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                stagnation_counter += 1\n                if stagnation_counter > self.stagnation_threshold:\n                    self.exploration_range *= 0.6  # Reduce exploration when stagnating\n                    stagnation_counter = 0  # Reset counter\n            else:\n                stagnation_counter = 0\n                self.exploration_range = min(0.3, self.exploration_range * 1.1)  # Increase exploration if improving, but cap it.\n\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution and pheromone.\n        \"\"\"\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            return np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n\n        x = self.best_solution.copy()\n        for i in range(self.dim):\n            if np.random.rand() < self.perturbation_rate:  # Perturbation\n                x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n            else:\n                # Pheromone-guided exploration\n                lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions.  Only update based on the single best ant in the current iteration.\n        \"\"\"\n        best_index = np.argmin(fitnesses)\n        best_solution_iteration = solutions[best_index]\n        best_fitness_iteration = fitnesses[best_index]\n\n        if best_fitness_iteration < np.mean(fitnesses): # ensure it's actually better than average to avoid misleading updates.\n          deposit = self.q * (np.mean(fitnesses) - best_fitness_iteration)\n          self.pheromone += deposit * np.abs(best_solution_iteration - self.best_solution)\n\n        # Normalize pheromone updates\n        self.pheromone /= np.sum(self.pheromone) + 1e-9", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveACO scored 0.594 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["590b0dc2-beb8-4e9b-b4e1-87f6073e88ce"], "operator": null, "metadata": {"aucs": [0.1076783632256334, 0.1759068806370898, 0.8411000727364062, 0.9512462434300806, 0.288653279962814, 0.8778102714934684, 0.3819299016443475, 0.5774297598223319, 0.7881861598636275, 0.14764645354725503, 0.9400205945182663, 0.9951908353509876, 0.2295984278984594, 0.7042481080246957, 0.8263054382096239, 0.8764849940608055, 0.5758178087377939, 0.9110815410884391, 0.1764952917531949, 0.5045062873506589]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "7bc2958a-0fe2-48c0-9b00-dd009a63d368", "fitness": "-inf", "name": "AdaptiveHybridPSO_CMAES", "description": "Combines PSO with CMA-ES, adaptively switching between exploration (PSO) and exploitation (CMA-ES) based on stagnation detection and dynamically adjusting parameters for both algorithms.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20,\n                 pso_inertia_start=0.9, pso_inertia_end=0.4,\n                 pso_cognitive=1.5, pso_social=1.5,\n                 cmaes_sigma=0.5, stagnation_threshold=100,\n                 exploration_prob=0.6):\n\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia_start = pso_inertia_start\n        self.pso_inertia_end = pso_inertia_end\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.stagnation_threshold = stagnation_threshold\n        self.exploration_prob = exploration_prob\n        self.population = None\n        self.stagnation_counter = 0\n        self.best_fitness_history = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim)) # initialize velocities\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n\n        self.best_fitness_history.append(global_best_fitness)\n\n        # Initialize CMA-ES parameters\n        mean = np.mean(population, axis=0)\n        covariance = np.eye(self.dim)\n\n        generation = 0  # Track the number of generations\n\n        while self.budget > 0:\n            generation += 1\n\n            # Adaptive Inertia Weight for PSO\n            inertia = self.pso_inertia_start - (self.pso_inertia_start - self.pso_inertia_end) * (generation / (self.budget / self.pop_size))\n\n            # PSO update\n            for i in range(self.pop_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocities[i] = (inertia * velocities[i] +\n                                 self.pso_cognitive * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.pso_social * r2 * (global_best_position - population[i]))\n                \n                population[i] = population[i] + velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n                \n                fitness = func(population[i])\n                self.budget -= 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_positions[i] = population[i].copy()\n                    \n                    if fitness < global_best_fitness:\n                        global_best_fitness = fitness\n                        global_best_position = population[i].copy()\n                        self.best_fitness_history.append(global_best_fitness)\n                else:\n                    self.best_fitness_history.append(global_best_fitness)\n\n            # Stagnation Detection\n            if len(self.best_fitness_history) > self.stagnation_threshold:\n                if np.std(self.best_fitness_history[-self.stagnation_threshold:]) < 1e-6:\n                    self.stagnation_counter += 1\n                else:\n                    self.stagnation_counter = 0\n\n            # CMA-ES adaptation with probability and stagnation\n            if (np.random.rand() > self.exploration_prob or self.stagnation_counter > 5) and self.budget > self.pop_size:\n                \n                z = np.random.multivariate_normal(np.zeros(self.dim), covariance, self.pop_size)\n                cmaes_samples = mean + self.cmaes_sigma * z\n                cmaes_samples = np.clip(cmaes_samples, lb, ub)\n\n                cmaes_fitness = np.zeros(self.pop_size)\n                for i in range(self.pop_size):\n                    cmaes_fitness[i] = func(cmaes_samples[i])\n                    self.budget -= 1\n\n                best_cmaes_indices = np.argsort(cmaes_fitness)[:self.pop_size // 2]\n                best_cmaes_samples = cmaes_samples[best_cmaes_indices]\n                \n                mean = np.mean(best_cmaes_samples, axis=0)\n\n                # Adaptive CMA-ES sigma\n                if self.stagnation_counter > 0:\n                    self.cmaes_sigma *= 0.8  # Reduce sigma for finer search\n                else:\n                    self.cmaes_sigma *= 1.1  # Increase sigma for broader search\n                    self.cmaes_sigma = min(self.cmaes_sigma, abs(ub-lb)/2) #Limit the value\n\n                covariance = np.cov(best_cmaes_samples, rowvar=False)\n                \n                worst_pso_indices = np.argsort(personal_best_fitness)[-self.pop_size // 2:]\n                population[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_positions[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices]\n                \n                global_best_index = np.argmin(personal_best_fitness)\n                global_best_position = personal_best_positions[global_best_index]\n                global_best_fitness = personal_best_fitness[global_best_index]\n                self.best_fitness_history.append(global_best_fitness)\n\n\n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "In the code, line 108, in __call__, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: self.cmaes_sigma = min(self.cmaes_sigma, abs(ub-lb)/2) #Limit the value", "error": "In the code, line 108, in __call__, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: self.cmaes_sigma = min(self.cmaes_sigma, abs(ub-lb)/2) #Limit the value", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "b562eb98-8a84-4ff2-a72d-b0231823a6fb", "fitness": "-inf", "name": "HybridDE_Sobol_TrustRegion", "description": "A novel hybrid algorithm combining Differential Evolution with a Sobol sequence-based initialization and a local search operator guided by a trust region, enhancing global exploration and local refinement.", "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import qmc\n\n\nclass HybridDE_Sobol_TrustRegion:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f=0.8, trust_region_size=0.5, trust_region_decay=0.95, local_search_frequency=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr\n        self.f = f\n        self.trust_region_size = trust_region_size\n        self.trust_region_decay = trust_region_decay\n        self.local_search_frequency = local_search_frequency\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize population using Sobol sequence for better coverage\n        sampler = qmc.Sobol(d=self.dim, scramble=True)\n        sample = sampler.random_sample(n=self.pop_size)\n        population = lb + (ub - lb) * sample\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n\n        generation = 0\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n\n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n\n                    if f_trial < self.f_opt:\n                        self.f_opt = f_trial\n                        self.x_opt = x_trial\n\n                if self.budget <= 0:\n                    break\n            \n            # Local search with trust region\n            if generation % self.local_search_frequency == 0:\n                \n                # Select best individual as starting point\n                best_idx = np.argmin(fitness)\n                x_local_start = population[best_idx].copy()\n                \n                # Define bounds for trust region\n                local_lb = np.maximum(lb, x_local_start - self.trust_region_size)\n                local_ub = np.minimum(ub, x_local_start + self.trust_region_size)\n\n                # Perform local optimization within trust region\n                bounds = [(local_lb[j], local_ub[j]) for j in range(self.dim)]\n                \n                result = minimize(func, x_local_start, method='L-BFGS-B', bounds=bounds, options={'maxfun': self.budget})  # Limit function evaluations\n                \n                if result.success and result.fun < self.f_opt:\n                    self.f_opt = result.fun\n                    self.x_opt = result.x\n                    \n                    # Update the population with the refined solution if it's better than the worst individual\n                    worst_idx = np.argmax(fitness)\n                    if result.fun < fitness[worst_idx]:\n                        fitness[worst_idx] = result.fun\n                        population[worst_idx] = result.x\n                        \n                self.budget -= result.nfev if hasattr(result, 'nfev') else 0  # Account for function evaluations in local search\n\n                # Decay trust region size\n                self.trust_region_size *= self.trust_region_decay\n\n            generation += 1\n            if self.budget <= 0:\n                break\n                \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "In the code, line 22, in __call__, the following error occurred:\nNameError: name 'qmc' is not defined\nOn line: sampler = qmc.Sobol(d=self.dim, scramble=True)", "error": "In the code, line 22, in __call__, the following error occurred:\nNameError: name 'qmc' is not defined\nOn line: sampler = qmc.Sobol(d=self.dim, scramble=True)", "parent_ids": ["55ac5cad-40cd-45d2-9ec4-0ce083c2ff9f"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "9de384f6-479e-446f-a62b-316a505a7076", "fitness": 0.564819360971309, "name": "AdaptiveHybridPSO_CMAES", "description": "Combines PSO's global search with CMA-ES's local refinement, adaptively switching between them based on performance stagnation.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20, pso_inertia=0.7, pso_cognitive=1.4, pso_social=1.4, cmaes_sigma=0.1, stagnation_threshold=10):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia = pso_inertia\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.stagnation_threshold = stagnation_threshold\n        self.population = None\n        self.pso_mode = True  # Start with PSO\n        self.stagnation_counter = 0\n        self.best_fitness_history = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n        self.best_fitness_history.append(global_best_fitness)\n\n        # Initialize CMA-ES parameters (only when switching to CMA-ES)\n        mean = np.mean(population, axis=0)\n        covariance = np.eye(self.dim)\n\n        while self.budget > 0:\n            if self.pso_mode:\n                # PSO update\n                for i in range(self.pop_size):\n                    r1 = np.random.rand(self.dim)\n                    r2 = np.random.rand(self.dim)\n                    \n                    velocities[i] = (self.pso_inertia * velocities[i] +\n                                     self.pso_cognitive * r1 * (personal_best_positions[i] - population[i]) +\n                                     self.pso_social * r2 * (global_best_position - population[i]))\n                    \n                    population[i] = population[i] + velocities[i]\n                    population[i] = np.clip(population[i], lb, ub)\n                    \n                    fitness = func(population[i])\n                    self.budget -= 1\n                    \n                    if fitness < personal_best_fitness[i]:\n                        personal_best_fitness[i] = fitness\n                        personal_best_positions[i] = population[i].copy()\n                        \n                        if fitness < global_best_fitness:\n                            global_best_fitness = fitness\n                            global_best_position = population[i].copy()\n            else:\n                # CMA-ES adaptation\n                z = np.random.multivariate_normal(np.zeros(self.dim), covariance, self.pop_size)\n                cmaes_samples = mean + self.cmaes_sigma * z\n                cmaes_samples = np.clip(cmaes_samples, lb, ub)\n\n                cmaes_fitness = np.zeros(self.pop_size)\n                for i in range(self.pop_size):\n                    cmaes_fitness[i] = func(cmaes_samples[i])\n                    self.budget -= 1\n\n                best_cmaes_indices = np.argsort(cmaes_fitness)[:self.pop_size // 2]\n                best_cmaes_samples = cmaes_samples[best_cmaes_indices]\n                \n                mean = np.mean(best_cmaes_samples, axis=0)\n                covariance = np.cov(best_cmaes_samples, rowvar=False) # Simplified covariance update\n\n                worst_pso_indices = np.argsort(personal_best_fitness)[-self.pop_size // 2:]\n                population[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_positions[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices]\n                \n                global_best_index = np.argmin(personal_best_fitness)\n                global_best_position = personal_best_positions[global_best_index]\n                global_best_fitness = personal_best_fitness[global_best_index]\n\n            # Adaptive Switching Logic\n            self.best_fitness_history.append(global_best_fitness)\n            if len(self.best_fitness_history) > self.stagnation_threshold:\n                if abs(self.best_fitness_history[-1] - self.best_fitness_history[-self.stagnation_threshold]) < 1e-6:\n                    self.stagnation_counter += 1\n                else:\n                    self.stagnation_counter = 0\n\n                if self.stagnation_counter >= self.stagnation_threshold:\n                    self.pso_mode = not self.pso_mode  # Switch modes\n                    self.stagnation_counter = 0\n                    # Reinitialize CMA-ES mean and covariance when switching to CMA-ES.\n                    if not self.pso_mode:\n                        mean = np.mean(population, axis=0)\n                        covariance = np.eye(self.dim)\n\n\n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveHybridPSO_CMAES scored 0.565 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {"aucs": [0.17418837866689152, 0.18824138352962927, 0.8696305407598703, 0.17254043089586735, 0.8918313537985993, 0.8766532065406859, 0.3331522784079204, 0.6157012646318099, 0.8091090247948032, 0.2354539359386315, 0.4663119219953613, 0.9992355048204716, 0.21596422036034968, 0.30610105957829814, 0.9252825428657039, 0.3625571881390901, 0.8041444541045201, 0.839353800671558, 0.7455956105218388, 0.4653391184042782]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "19232152-578c-478b-9345-7529963a67e5", "fitness": 0.31672143633617666, "name": "HybridCMAES_DE", "description": "A hybrid algorithm combining a simplified version of the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) with a mutation operator inspired by differential evolution for robust and efficient search.", "code": "import numpy as np\n\nclass HybridCMAES_DE:\n    def __init__(self, budget=10000, dim=10, pop_size=None, initial_sigma=0.2):\n        \"\"\"\n        Initializes the Hybrid CMA-ES with Differential Evolution Mutation algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            pop_size (int): The population size. If None, defaults to 4 + int(3 * np.log(dim)).\n            initial_sigma (float): Initial step size (standard deviation).\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size if pop_size is not None else 4 + int(3 * np.log(dim))\n        self.initial_sigma = initial_sigma\n        self.mean = None\n        self.sigma = None\n        self.bounds = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Hybrid CMA-ES with Differential Evolution Mutation.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n        self.bounds = func.bounds\n        self.mean = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)  # Initialize mean within bounds\n        self.sigma = self.initial_sigma\n\n        evaluations = 0\n\n        while evaluations < self.budget:\n            # Generate population\n            population = []\n            fitnesses = []\n            for _ in range(self.pop_size):\n                z = np.random.randn(self.dim)\n                x = self.mean + self.sigma * z\n                x = np.clip(x, self.bounds.lb, self.bounds.ub)  # Clip to bounds\n\n                f = func(x)\n                evaluations += 1\n\n                population.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            # Sort population by fitness\n            sorted_indices = np.argsort(fitnesses)\n            population = [population[i] for i in sorted_indices]\n            fitnesses = [fitnesses[i] for i in sorted_indices]\n\n            # Update mean (simplified CMA-ES selection)\n            num_selected = self.pop_size // 2 #Select top half\n            self.mean = np.mean(population[:num_selected], axis=0)\n\n            # Differential Evolution mutation for exploration\n            if evaluations < self.budget:\n                r1, r2, r3 = np.random.choice(self.pop_size, 3, replace=False)\n                mutant = population[0] + 0.5 * (population[r1] - population[r2]) #DE mutation with best as base\n                mutant = np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n                mutant_fitness = func(mutant)\n                evaluations += 1\n\n                if mutant_fitness < fitnesses[-1]: #Replace worst if better\n                    population[-1] = mutant\n                    fitnesses[-1] = mutant_fitness\n\n                    if mutant_fitness < self.best_fitness:\n                        self.best_fitness = mutant_fitness\n                        self.best_solution = mutant.copy()\n\n            # Adapt step size (simplified adaptation)\n            if fitnesses[0] < np.mean(fitnesses):\n                 self.sigma *= 1.05  # Increase step size if improvement\n            else:\n                self.sigma *= 0.95  # Decrease step size if no improvement\n            self.sigma = np.clip(self.sigma, self.initial_sigma/10, self.initial_sigma*10)\n\n        return self.best_fitness, self.best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm HybridCMAES_DE scored 0.317 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["590b0dc2-beb8-4e9b-b4e1-87f6073e88ce"], "operator": null, "metadata": {"aucs": [0.13762820637843232, 0.26487615798039543, 0.3108169056360509, 0.2427691255635268, 0.22807145389887462, 0.26575042606680455, 0.2688083956397018, 0.25109086102889, 0.22779110003895708, 0.18009813748811043, 0.26396453954696486, 0.973699272616584, 0.2887236449202921, 0.24007882992223417, 0.6447197082427331, 0.3056639486982614, 0.24558487513121785, 0.3403324173320982, 0.1851495734241394, 0.4688111471692643]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "ca9d8bb9-26e6-49c5-a56b-69e5e5b03a9d", "fitness": "-inf", "name": "EnhancedAdaptiveACO", "description": "Enhanced Adaptive ACO with dynamic parameter adjustments based on success rate and pheromone concentration, promoting balanced exploration and exploitation for continuous optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.1, q=1.0, initial_exploration=0.3, perturbation_rate=0.05, exploration_decay=0.95):\n        \"\"\"\n        Initializes the Enhanced Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            perturbation_rate (float): Probability of perturbing a dimension in a solution.\n            exploration_decay (float): Decay rate for the exploration range when convergence is detected.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.perturbation_rate = perturbation_rate\n        self.exploration_decay = exploration_decay\n        self.success_rate = 0.0\n        self.success_window = 10  # Track success over this many iterations\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Enhanced Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim) * 0.5  # Initialize pheromone to 0.5\n        evaluations = 0\n        convergence_count = 0\n        prev_best_fitness = np.inf\n        successful_iterations = 0\n        iteration = 0\n\n        while evaluations < self.budget:\n            iteration += 1\n            solutions = []\n            fitnesses = []\n            local_best_solution = None\n            local_best_fitness = np.inf\n\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < local_best_fitness:\n                    local_best_fitness = f\n                    local_best_solution = x\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n                    successful_iterations += 1  # Increment success count\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0)\n\n            # Adaptive exploration range and pheromone update based on convergence\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                convergence_count += 1\n                if convergence_count > 5:\n                    self.exploration_range *= self.exploration_decay  # Reduce exploration if stuck\n                    self.exploration_range = max(self.exploration_range, 0.01)  # Ensure minimum exploration\n                    self.pheromone *= 0.8  # Reduce pheromone to encourage exploration\n            else:\n                convergence_count = 0\n                self.exploration_range = min(self.exploration_range * 1.1, 0.3)  # Increase exploration slightly\n                #self.pheromone = np.ones(self.dim) * 0.5 #reset pheromone\n\n\n            # Update success rate\n            self.success_rate = successful_iterations / iteration if iteration <= self.success_window else (successful_iterations - max(0, successful_iterations - (iteration - self.success_window))) / self.success_window\n\n            # Dynamically adjust perturbation rate based on success rate\n            self.perturbation_rate = 0.05 + 0.1 * (1 - self.success_rate)\n            self.perturbation_rate = np.clip(self.perturbation_rate, 0.01, 0.2)\n\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution.\n        \"\"\"\n        x = np.zeros(self.dim)\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            x = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n        else:\n            # Exploration around the best solution, guided by pheromones\n            x = self.best_solution.copy()\n            for i in range(self.dim):\n                if np.random.rand() < self.perturbation_rate:  # Perturbation\n                    x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n                else:\n                    lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                    ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                    x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions.\n        \"\"\"\n        avg_fitness = np.mean(fitnesses)\n        delta_pheromone = np.zeros(self.dim)\n\n        for i in range(len(solutions)):\n            x = solutions[i]\n            f = fitnesses[i]\n\n            # Pheromone deposit proportional to fitness improvement relative to average\n            if f < avg_fitness:\n                deposit = self.q * (avg_fitness - f) / (avg_fitness + 1e-9)  # Avoid division by zero\n                delta_pheromone += deposit * np.abs(x - self.best_solution)\n\n        # Normalize pheromone updates - crucial for stability\n        delta_pheromone /= np.sum(delta_pheromone) + 1e-9\n\n        #Apply pheromone change\n        self.pheromone += delta_pheromone\n        self.pheromone = np.clip(self.pheromone, 0.01, 1.0) #Clip to avoid extremes", "configspace": "", "generation": 4, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["590b0dc2-beb8-4e9b-b4e1-87f6073e88ce"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "0fefafe6-e36d-439b-8c69-23bcc80fdf66", "fitness": 0.0833478469190187, "name": "BioGeoMigration", "description": "BioGeo inspired optimizer that uses habitat suitability (fitness) to drive migration of features between solutions, combined with a local search operator.", "code": "import numpy as np\n\nclass BioGeoMigration:\n    def __init__(self, budget=10000, dim=10, n_habitats=20, migration_rate=0.1, mutation_rate=0.01, local_search_radius=0.1):\n        \"\"\"\n        Initializes the BioGeoMigration algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_habitats (int): The number of habitats (solutions) in the population.\n            migration_rate (float): The probability of a feature migrating from one habitat to another.\n            mutation_rate (float): The probability of a feature mutating within a habitat.\n            local_search_radius (float): Radius for local search around the best solution.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_habitats = n_habitats\n        self.migration_rate = migration_rate\n        self.mutation_rate = mutation_rate\n        self.local_search_radius = local_search_radius\n        self.habitats = None\n        self.fitnesses = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.evaluations = 0\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using BioGeoMigration.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n        self.bounds = func.bounds\n        self.initialize_habitats()\n\n        while self.evaluations < self.budget:\n            self.migrate_features()\n            self.mutate_habitats()\n            self.local_search(func)  # Apply local search around the best solution\n\n            for i in range(self.n_habitats):\n                if self.evaluations >= self.budget:\n                    break\n\n                if self.fitnesses[i] is None:\n                    self.fitnesses[i] = func(self.habitats[i])\n                    self.evaluations += 1\n\n                if self.fitnesses[i] < self.best_fitness:\n                    self.best_fitness = self.fitnesses[i]\n                    self.best_solution = self.habitats[i].copy()\n\n        return self.best_fitness, self.best_solution\n\n    def initialize_habitats(self):\n        \"\"\"\n        Initializes the population of habitats (solutions) randomly.\n        \"\"\"\n        self.habitats = np.random.uniform(self.bounds.lb, self.bounds.ub, size=(self.n_habitats, self.dim))\n        self.fitnesses = [None] * self.n_habitats\n\n    def migrate_features(self):\n        \"\"\"\n        Simulates the migration of features between habitats based on fitness.\n        \"\"\"\n        for i in range(self.n_habitats):\n            for j in range(self.dim):\n                if np.random.rand() < self.migration_rate:\n                    # Select a donor habitat (excluding the current one)\n                    donor_index = np.random.choice([k for k in range(self.n_habitats) if k != i])\n\n                    # Move feature from donor to recipient\n                    self.habitats[i, j] = self.habitats[donor_index, j]\n\n                    # Ensure the value stays within bounds\n                    self.habitats[i, j] = np.clip(self.habitats[i, j], self.bounds.lb[j], self.bounds.ub[j])\n\n    def mutate_habitats(self):\n        \"\"\"\n        Introduces random mutations to the habitats.\n        \"\"\"\n        for i in range(self.n_habitats):\n            for j in range(self.dim):\n                if np.random.rand() < self.mutation_rate:\n                    # Mutate feature\n                    self.habitats[i, j] = np.random.uniform(self.bounds.lb[j], self.bounds.ub[j])\n\n    def local_search(self, func):\n        \"\"\"\n        Performs local search around the best solution.\n        \"\"\"\n        if self.best_solution is None:\n            return\n\n        for _ in range(5):  # Perform a few local search iterations\n            neighbor = self.best_solution.copy()\n            # Perturb each dimension with a probability\n            for i in range(self.dim):\n                neighbor[i] += np.random.uniform(-self.local_search_radius, self.local_search_radius) * (self.bounds.ub[i] - self.bounds.lb[i])\n                neighbor[i] = np.clip(neighbor[i], self.bounds.lb[i], self.bounds.ub[i])\n\n            neighbor_fitness = func(neighbor)\n            self.evaluations += 1\n\n            if neighbor_fitness < self.best_fitness:\n                self.best_fitness = neighbor_fitness\n                self.best_solution = neighbor.copy()\n                #Update fitnesses, if required\n                for i in range(self.n_habitats):\n                   if np.allclose(self.habitats[i], self.best_solution):\n                        self.fitnesses[i] = self.best_fitness\n                break # Early exit local search\n", "configspace": "", "generation": 4, "feedback": "The algorithm BioGeoMigration scored 0.083 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["590b0dc2-beb8-4e9b-b4e1-87f6073e88ce"], "operator": null, "metadata": {"aucs": [0.1666956938380374, 0]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "8a33edea-4747-4fc0-9e24-b7ee719487b0", "fitness": 0.44791809171537605, "name": "HybridPSO_CMAES", "description": "Dynamically adjusts PSO parameters based on performance and integrates a simplified CMA-ES for covariance-based exploration, adaptively switching between phases to refine solutions and escape local optima.", "code": "import numpy as np\n\nclass HybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20, pso_inertia=0.7, pso_cognitive=1.4, pso_social=1.4, cmaes_sigma=0.5, pso_adapt_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia = pso_inertia\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.pso_adapt_rate = pso_adapt_rate\n        self.population = None  # Initialize population\n        self.inertia_history = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim)) # initialize velocities\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n\n        # Initialize CMA-ES parameters\n        mean = np.mean(population, axis=0)\n        covariance = np.eye(self.dim)\n        \n        iteration = 0\n        while self.budget > 0:\n            iteration += 1\n\n            # PSO update\n            for i in range(self.pop_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocities[i] = (self.pso_inertia * velocities[i] +\n                                 self.pso_cognitive * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.pso_social * r2 * (global_best_position - population[i]))\n                \n                population[i] = population[i] + velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n                \n                fitness = func(population[i])\n                self.budget -= 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_positions[i] = population[i].copy()\n                    \n                    if fitness < global_best_fitness:\n                        global_best_fitness = fitness\n                        global_best_position = population[i].copy()\n            \n            # Adapt PSO inertia dynamically based on stagnation (no improvement in global best)\n            if iteration > 10 and global_best_fitness == np.min(personal_best_fitness): # global best stagnates\n                self.pso_inertia *= (1 - self.pso_adapt_rate)  # Reduce inertia to promote local search\n            else:\n                self.pso_inertia = min(0.9, self.pso_inertia * (1 + self.pso_adapt_rate/10))  # Increase inertia gradually\n\n            self.inertia_history.append(self.pso_inertia)\n\n            # CMA-ES adaptation - only adapt every 5 iterations (example) to allow PSO to explore\n            if self.budget % 500 < self.pop_size and self.budget > self.pop_size: # Check if sufficient budget is left to apply CMAES and perform function evaluations.\n                # Generate CMA-ES samples\n                z = np.random.multivariate_normal(np.zeros(self.dim), covariance, self.pop_size)\n                cmaes_samples = mean + self.cmaes_sigma * z\n                cmaes_samples = np.clip(cmaes_samples, lb, ub)\n\n                cmaes_fitness = np.zeros(self.pop_size)\n                for i in range(self.pop_size):\n                  cmaes_fitness[i] = func(cmaes_samples[i])\n                  self.budget -= 1\n\n                # Select best CMA-ES samples and update mean and covariance\n                best_cmaes_indices = np.argsort(cmaes_fitness)[:self.pop_size // 2]  # Select top 50%\n                best_cmaes_samples = cmaes_samples[best_cmaes_indices]\n                \n                mean = np.mean(best_cmaes_samples, axis=0)\n\n                # Update covariance (simplified - can be improved with CMA-ES update rules)\n                diff = best_cmaes_samples - mean\n                covariance = np.cov(best_cmaes_samples, rowvar=False) + 1e-9 * np.eye(self.dim) # avoid singular matrix\n\n                # Replace worst PSO particles with best CMA-ES particles (elitism)\n                worst_pso_indices = np.argsort(personal_best_fitness)[-self.pop_size // 2:]\n                population[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_positions[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices]\n                \n                # Update global best\n                global_best_index = np.argmin(personal_best_fitness)\n                global_best_position = personal_best_positions[global_best_index]\n                global_best_fitness = personal_best_fitness[global_best_index]\n                \n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSO_CMAES scored 0.448 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {"aucs": [0.13721409035091015, 0.2545507286512224, 0.5592562986584344, 0.257138494157214, 0.29622167945347333, 0.48659270951349465, 0.30662594178256786, 0.43217923173752704, 0.26882198776702726, 0.23077144323063647, 0.9609281876793853, 0.9970430205622619, 0.24525418821139744, 0.30849563725049556, 0.7241672051693736, 0.5494563856701034, 0.28427983134009616, 0.928784621616351, 0.21047163854941253, 0.5201085129561371]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "a0aa97ec-618d-45ec-acf1-2c9913ef6f5f", "fitness": "-inf", "name": "AdaptiveACO", "description": "An Adaptive ACO with dynamic parameters and a more focused pheromone update based on distance to the global best, incorporating a restart mechanism to escape local optima.", "code": "import numpy as np\n\nclass AdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.1, q=1.0, initial_exploration=0.3, perturbation_rate=0.05, stagnation_threshold=5, restart_trigger=20):\n        \"\"\"\n        Initializes the Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            perturbation_rate (float): Probability of perturbing a dimension in a solution.\n            stagnation_threshold (int): Number of iterations without improvement before exploration range reduction.\n            restart_trigger (int): Number of stagnation epochs to trigger a restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.perturbation_rate = perturbation_rate\n        self.stagnation_threshold = stagnation_threshold\n        self.restart_trigger = restart_trigger\n        self.restart_counter = 0\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim) * 0.5  # Initialize pheromone\n        evaluations = 0\n        stagnation_counter = 0\n        prev_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0)\n\n\n            # Stagnation detection and adaptive exploration range\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                stagnation_counter += 1\n                self.restart_counter += 1\n                if stagnation_counter > self.stagnation_threshold:\n                    self.exploration_range *= 0.7  # Reduce exploration when stagnating\n                    stagnation_counter = 0  # Reset counter\n                \n                if self.restart_counter > self.restart_trigger:\n                    self.restart()\n                    self.restart_counter = 0\n\n            else:\n                stagnation_counter = 0\n                self.exploration_range = min(0.3, self.exploration_range * 1.1)  # Increase exploration if improving, but cap it.\n                self.restart_counter = 0\n\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution and pheromone.\n        \"\"\"\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            return np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n\n        x = self.best_solution.copy()\n        for i in range(self.dim):\n            if np.random.rand() < self.perturbation_rate:  # Perturbation\n                x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n            else:\n                # Pheromone-guided exploration\n                lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions.  Reinforce pheromone based on distance to global best.\n        \"\"\"\n        best_index = np.argmin(fitnesses)\n        best_solution_iteration = solutions[best_index]\n        best_fitness_iteration = fitnesses[best_index]\n\n        if best_fitness_iteration < np.mean(fitnesses): # ensure it's actually better than average to avoid misleading updates.\n          deposit = self.q * (np.mean(fitnesses) - best_fitness_iteration)\n          # Focus pheromone update on proximity to global best\n          pheromone_update = deposit * np.exp(-np.abs(best_solution_iteration - self.best_solution))  # Exponential decay based on distance\n          self.pheromone += pheromone_update\n\n        # Normalize pheromone updates\n        self.pheromone /= np.sum(self.pheromone) + 1e-9\n    \n    def restart(self):\n        \"\"\"\n        Restarts the algorithm to escape local optima.\n        \"\"\"\n        self.pheromone = np.ones(self.dim) * 0.5  # Reset pheromone\n        self.exploration_range = 0.3             # Reset exploration range\n        self.best_solution = None\n        self.best_fitness = np.inf\n        print(\"Restarting ACO\")", "configspace": "", "generation": 5, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["94491ede-4777-45ba-b495-cfc2e6ba28a4"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "acecb8ce-e251-4aab-a92b-4a34ce1be12e", "fitness": 0.5787832417610512, "name": "AdaptiveCulturalDifferentialEvolution", "description": "Self-adaptive Cultural Differential Evolution with dynamic parameter control and a refined belief space update mechanism based on fitness landscape analysis.", "code": "import numpy as np\n\nclass AdaptiveCulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f=0.8, belief_space_size=10, local_search_prob=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = belief_space_size # Size of the belief space for cultural learning\n        self.local_search_prob = local_search_prob # Probability of performing local search\n\n        self.cr_history = []\n        self.f_history = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space (best individuals observed so far)\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n        belief_fitness = np.sort(fitness)[:self.belief_space_size].copy()\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            \n            # Adaptive Parameter Control\n            if generation > 10:\n                # Adjust CR and F based on historical success\n                if self.cr_history:\n                    self.cr = np.clip(np.mean(self.cr_history), 0.1, 0.9)  # Average successful CR values\n                if self.f_history:\n                    self.f = np.clip(np.mean(self.f_history), 0.1, 1.0)  # Average successful F values\n\n                self.cr_history = []\n                self.f_history = []\n\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning: Bias towards best from belief space\n                belief_idx = np.random.randint(self.belief_space_size)\n                x_trial = x_trial + 0.1 * (belief_space[belief_idx] - x_trial)\n                x_trial = np.clip(x_trial, lb, ub)\n                \n                # Local Search (perturbation around the trial solution)\n                if np.random.rand() < self.local_search_prob:\n                    x_trial = x_trial + np.random.normal(0, 0.01 * (ub - lb), self.dim)\n                    x_trial = np.clip(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    # Update CR/F history if successful\n                    self.cr_history.append(self.cr)\n                    self.f_history.append(self.f)\n                    \n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                    # Update belief space if necessary using landscape analysis\n                    if f_trial < belief_fitness[-1]:\n                        \n                        # Landscape Analysis: Check if the new solution significantly improves the belief space\n                        improvement_ratio = (belief_fitness[-1] - f_trial) / belief_fitness[-1]\n                        if improvement_ratio > 0.01: # Significant Improvement\n                            belief_fitness[-1] = f_trial\n                            belief_space[-1] = x_trial\n                            \n                            # Re-sort belief space to maintain order\n                            sorted_indices = np.argsort(belief_fitness)\n                            belief_fitness = belief_fitness[sorted_indices]\n                            belief_space = belief_space[sorted_indices]\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveCulturalDifferentialEvolution scored 0.579 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.2025913039151166, 0.34657041223105, 0.5370940819646026, 0.841321670159521, 0.6403005263691122, 0.695975791168171, 0.4200818288152929, 0.5309547156003698, 0.622553142697015, 0.5063013775584815, 0.7982683996383458, 0.9993673685296749, 0.32645691164466273, 0.5500380877995701, 0.8851685566028334, 0.6926902026387591, 0.4783106734268803, 0.792678407204037, 0.19025548213518373, 0.5186858951223438]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "ce590aa6-b5e0-4a2c-a407-c1885d51fbb0", "fitness": "-inf", "name": "LevyNelderMead", "description": "Population-based algorithm employing a Lvy flight-based exploration strategy and a local search mechanism using a Nelder-Mead simplex to balance global search with local refinement.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass LevyNelderMead:\n    def __init__(self, budget=10000, dim=10, n_population=10, levy_exponent=1.5, local_search_iterations=5):\n        \"\"\"\n        Initializes the Levy Flight with Nelder-Mead optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_population (int): The number of individuals in the population.\n            levy_exponent (float): The exponent for the Levy flight distribution.\n            local_search_iterations (int): Number of Nelder-Mead iterations.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_population = n_population\n        self.levy_exponent = levy_exponent\n        self.local_search_iterations = local_search_iterations\n        self.population = None\n        self.fitness = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Levy Flight with Nelder-Mead.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n        self.bounds = func.bounds\n        self.population = np.random.uniform(self.bounds.lb, self.bounds.ub, size=(self.n_population, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        evaluations = self.n_population\n\n        self.best_solution = self.population[np.argmin(self.fitness)]\n        self.best_fitness = np.min(self.fitness)\n\n\n        while evaluations < self.budget:\n            for i in range(self.n_population):\n                # Levy flight step\n                step = self.levy_flight(self.dim, self.levy_exponent)\n                new_solution = self.population[i] + step\n                new_solution = np.clip(new_solution, self.bounds.lb, self.bounds.ub)\n\n                # Local search with Nelder-Mead\n                local_result = minimize(func, new_solution, method='Nelder-Mead', bounds=func.bounds, options={'maxiter': self.local_search_iterations})\n                new_fitness = local_result.fun\n                new_solution = local_result.x\n\n                evaluations += local_result.nit #number of iterations used by Nelder-Mead\n\n                if new_fitness < self.fitness[i]:\n                    self.fitness[i] = new_fitness\n                    self.population[i] = new_solution\n\n                    if new_fitness < self.best_fitness:\n                        self.best_fitness = new_fitness\n                        self.best_solution = new_solution\n\n                if evaluations >= self.budget:\n                  break\n\n        return self.best_fitness, self.best_solution\n\n\n    def levy_flight(self, dim, beta):\n        \"\"\"\n        Generates a Levy flight step.\n\n        Args:\n            dim (int): The dimensionality of the space.\n            beta (float): The exponent for the Levy distribution.\n\n        Returns:\n            numpy.ndarray: A Levy flight step.\n        \"\"\"\n        num = np.random.normal(0, scale=(np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * (2 ** ((beta - 1) / 2)))) ** (1 / beta), size=dim)\n        den = np.random.normal(0, 1, size=dim)\n        step = num / (np.abs(den) ** (1 / beta))\n        return step * 0.01 #scaling the step\n", "configspace": "", "generation": 5, "feedback": "In the code, line 805, in __getattr__, the following error occurred:\nAttributeError: module 'numpy' has no attribute 'gamma'", "error": "In the code, line 805, in __getattr__, the following error occurred:\nAttributeError: module 'numpy' has no attribute 'gamma'", "parent_ids": ["94491ede-4777-45ba-b495-cfc2e6ba28a4"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "a3751ed3-852c-4dea-8289-312349f4779b", "fitness": 0.5126576021186157, "name": "AdaptiveCulturalDifferentialEvolution", "description": "Adaptive Differential Evolution with orthogonal learning and population diversity maintenance, dynamically adjusting mutation and crossover rates based on success and population entropy.", "code": "import numpy as np\n\nclass AdaptiveCulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=50, initial_cr=0.7, initial_f=0.8, entropy_threshold=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = initial_cr  # Initial Crossover rate\n        self.f = initial_f    # Initial Differential weight\n        self.entropy_threshold = entropy_threshold # Threshold for population entropy\n        self.success_history_cr = []\n        self.success_history_f = []\n        self.success_window = 10\n        self.archive_size = int(pop_size * 0.2)\n        self.archive = []\n        self.archive_fitness = []\n\n    def calculate_entropy(self, population):\n        \"\"\"Calculates the entropy of the population to assess diversity.\"\"\"\n        _, counts = np.unique(np.apply_along_axis(lambda x: tuple(x), 1, population), axis=0, return_counts=True)\n        probabilities = counts / len(population)\n        entropy = -np.sum(probabilities * np.log2(probabilities))\n        return entropy / np.log2(len(population))  # Normalized entropy\n\n    def orthogonal_learning(self, x, lb, ub):\n        \"\"\"Performs orthogonal learning to generate a better solution.\"\"\"\n        basis = np.random.randn(self.dim, self.dim)\n        q, _ = np.linalg.qr(basis)  # Orthogonal basis\n        new_x = x + 0.1 * np.dot(np.random.rand(self.dim), q.T) # Small step along orthogonal directions\n        return np.clip(new_x, lb, ub)\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        generation = 0\n        while self.budget > 0:\n            entropy = self.calculate_entropy(population)\n            \n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Orthogonal Learning\n                if np.random.rand() < 0.1: # Apply with a small probability\n                    x_trial = self.orthogonal_learning(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    delta_f = abs(f_trial - fitness[i])\n                    self.success_history_cr.append((delta_f, self.cr))\n                    self.success_history_f.append((delta_f, self.f))\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                    # Update archive\n                    if len(self.archive) < self.archive_size:\n                        self.archive.append(population[i].copy())\n                        self.archive_fitness.append(f_trial)\n                    else:\n                        max_archive_index = np.argmax(self.archive_fitness)\n                        if f_trial < self.archive_fitness[max_archive_index]:\n                            self.archive[max_archive_index] = population[i].copy()\n                            self.archive_fitness[max_archive_index] = f_trial\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n            \n            # Adapt parameters\n            if generation % 5 == 0:\n                # Adjust mutation factor F\n                if self.success_history_f:\n                    sorted_success = sorted(self.success_history_f, key=lambda x: x[0], reverse=True)\n                    best_f = sorted_success[0][1]\n                    self.f = np.clip(best_f * (1 + 0.1 * np.random.randn()), 0.1, 1.0)\n                    self.success_history_f = []\n\n                # Adjust crossover rate CR\n                if self.success_history_cr:\n                    sorted_success = sorted(self.success_history_cr, key=lambda x: x[0], reverse=True)\n                    best_cr = sorted_success[0][1]\n                    self.cr = np.clip(best_cr * (1 + 0.1 * np.random.randn()), 0.1, 1.0)\n                    self.success_history_cr = []\n\n                # Increase diversity if population collapses\n                if entropy < self.entropy_threshold:\n                    for i in range(self.pop_size):\n                        population[i] = np.random.uniform(lb, ub, size=self.dim)\n                    fitness = np.array([func(x) for x in population])\n                    self.budget -= self.pop_size\n                    \n\n            generation += 1\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveCulturalDifferentialEvolution scored 0.513 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["55ac5cad-40cd-45d2-9ec4-0ce083c2ff9f"], "operator": null, "metadata": {"aucs": [0.17749343951408503, 0.3296325450369869, 0.4580946455644127, 0.7787687272555104, 0.523406089052268, 0.7276263944955759, 0.31900161562261053, 0.4109889010389165, 0.5136572184447306, 0.2870848217827955, 0.6572209394706066, 0.9931882396065483, 0.29598022942781377, 0.374644734145377, 0.8444123883520072, 0.6399367572142292, 0.43421762663467545, 0.7900670927229058, 0.20010324535517943, 0.49762639163507816]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "d1b264fa-b5a0-4637-8450-4c90b7c39a87", "fitness": 0.43475593722886696, "name": "AdaptiveHybridPSO_CMAES", "description": "Adaptive Hybrid PSO-CMA-ES with dynamic parameter adjustment and population diversity maintenance, balancing exploration and exploitation effectively.", "code": "import numpy as np\n\nclass AdaptiveHybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20, pso_inertia=0.7, pso_cognitive=1.4, pso_social=1.4, cmaes_sigma=0.5, diversity_threshold=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia = pso_inertia\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.diversity_threshold = diversity_threshold\n        self.population = None\n        self.generation = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n\n        # Initialize CMA-ES parameters\n        mean = np.mean(population, axis=0)\n        covariance = np.eye(self.dim)\n        \n        while self.budget > 0:\n            self.generation += 1\n            # PSO update\n            for i in range(self.pop_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocities[i] = (self.pso_inertia * velocities[i] +\n                                 self.pso_cognitive * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.pso_social * r2 * (global_best_position - population[i]))\n                \n                population[i] = population[i] + velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n                \n                fitness = func(population[i])\n                self.budget -= 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_positions[i] = population[i].copy()\n                    \n                    if fitness < global_best_fitness:\n                        global_best_fitness = fitness\n                        global_best_position = population[i].copy()\n            \n            # CMA-ES adaptation with Diversity Check\n            if self.budget > self.pop_size and self.generation % 5 == 0:\n                diversity = np.std(population)\n                if diversity < self.diversity_threshold:  # Low diversity, engage CMA-ES more actively\n                    cmaes_pop_size = self.pop_size * 2  # Increase CMA-ES population size for better exploration\n                    if self.budget < cmaes_pop_size:\n                        cmaes_pop_size = self.budget\n\n                    z = np.random.multivariate_normal(np.zeros(self.dim), covariance, cmaes_pop_size)\n                    cmaes_samples = mean + self.cmaes_sigma * z\n                    cmaes_samples = np.clip(cmaes_samples, lb, ub)\n\n                    cmaes_fitness = np.zeros(cmaes_pop_size)\n                    for i in range(cmaes_pop_size):\n                      cmaes_fitness[i] = func(cmaes_samples[i])\n                      self.budget -= 1\n\n                    best_cmaes_indices = np.argsort(cmaes_fitness)[:self.pop_size // 2]\n                    best_cmaes_samples = cmaes_samples[best_cmaes_indices]\n\n                    mean = np.mean(best_cmaes_samples, axis=0)\n                    covariance = np.cov(best_cmaes_samples, rowvar=False)\n\n                    worst_pso_indices = np.argsort(personal_best_fitness)[-self.pop_size // 2:]\n                    population[worst_pso_indices] = best_cmaes_samples.copy()\n                    personal_best_positions[worst_pso_indices] = best_cmaes_samples.copy()\n                    personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices]\n\n                    global_best_index = np.argmin(personal_best_fitness)\n                    global_best_position = personal_best_positions[global_best_index]\n                    global_best_fitness = personal_best_fitness[global_best_index]\n                else:\n                    #Adapt pso parameters.\n                    self.pso_inertia = np.clip(self.pso_inertia + np.random.normal(0, 0.05), 0.1, 0.9)\n                    self.pso_cognitive = np.clip(self.pso_cognitive + np.random.normal(0, 0.1), 1.0, 2.0)\n                    self.pso_social = np.clip(self.pso_social + np.random.normal(0, 0.1), 1.0, 2.0)\n\n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveHybridPSO_CMAES scored 0.435 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {"aucs": [0.13272138929607358, 0.24914510680035495, 0.8995090476828614, 0.22178670898127073, 0.3153000048055874, 0.24422892887657888, 0.3332573537774861, 0.6257782983127252, 0.7444225328381139, 0.18706109679721394, 0.16609746888960963, 0.9971340590215573, 0.23124738664351496, 0.26611122790941677, 0.6480734308993201, 0.848904429651141, 0.4569916369455973, 0.2910824581780965, 0.3501600977276911, 0.48610608054312987]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "d827bbc6-861d-49c1-a88a-430185ea21eb", "fitness": 0.3903203654442264, "name": "HybridPSO_CMAES", "description": "Dynamically adjusts PSO parameters and CMA-ES adaptation frequency based on population diversity and stagnation detection for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size=20, pso_inertia_max=0.9, pso_inertia_min=0.4, pso_cognitive=1.5, pso_social=1.5, cmaes_sigma=0.5, stagnation_threshold=1e-6, diversity_threshold=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.pso_inertia_max = pso_inertia_max\n        self.pso_inertia_min = pso_inertia_min\n        self.pso_cognitive = pso_cognitive\n        self.pso_social = pso_social\n        self.cmaes_sigma = cmaes_sigma\n        self.stagnation_threshold = stagnation_threshold\n        self.diversity_threshold = diversity_threshold\n        self.population = None  # Initialize population\n        self.last_improvement = 0\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize PSO population and velocities\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        velocities = np.random.uniform(-abs(ub-lb)/10, abs(ub-lb)/10, size=(self.pop_size, self.dim)) # initialize velocities\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n        \n        global_best_index = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_fitness = personal_best_fitness[global_best_index]\n        self.last_improvement = 0 # Initialize last improvement iteration\n\n        # Initialize CMA-ES parameters\n        mean = np.mean(population, axis=0)\n        covariance = np.eye(self.dim)\n        \n        iteration = 0\n        while self.budget > 0:\n            iteration += 1\n\n            # Dynamic PSO inertia weight adjustment\n            inertia = self.pso_inertia_max - (self.pso_inertia_max - self.pso_inertia_min) * (iteration / (self.budget + iteration))\n\n            # PSO update\n            for i in range(self.pop_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                \n                velocities[i] = (inertia * velocities[i] +\n                                 self.pso_cognitive * r1 * (personal_best_positions[i] - population[i]) +\n                                 self.pso_social * r2 * (global_best_position - population[i]))\n                \n                population[i] = population[i] + velocities[i]\n                population[i] = np.clip(population[i], lb, ub)\n                \n                fitness = func(population[i])\n                self.budget -= 1\n                \n                if fitness < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness\n                    personal_best_positions[i] = population[i].copy()\n                    \n                    if fitness < global_best_fitness:\n                        global_best_fitness = fitness\n                        global_best_position = population[i].copy()\n                        self.last_improvement = iteration # update last improvement\n\n            # Stagnation detection and CMA-ES adaptation frequency\n            if iteration - self.last_improvement > 500: # stagnation detected\n                cmaes_adaptation_frequency = 1 # adapt every iteration\n            else:\n                cmaes_adaptation_frequency = 500 # adapt every 500 iterations\n\n            # CMA-ES adaptation - only adapt every cmaes_adaptation_frequency iterations\n            if self.budget % cmaes_adaptation_frequency < self.pop_size and self.budget > self.pop_size: # Check if sufficient budget is left to apply CMAES and perform function evaluations.\n                # Generate CMA-ES samples\n                z = np.random.multivariate_normal(np.zeros(self.dim), covariance, self.pop_size)\n                cmaes_samples = mean + self.cmaes_sigma * z\n                cmaes_samples = np.clip(cmaes_samples, lb, ub)\n\n                cmaes_fitness = np.zeros(self.pop_size)\n                for i in range(self.pop_size):\n                  cmaes_fitness[i] = func(cmaes_samples[i])\n                  self.budget -= 1\n\n                # Select best CMA-ES samples and update mean and covariance\n                best_cmaes_indices = np.argsort(cmaes_fitness)[:self.pop_size // 2]  # Select top 50%\n                best_cmaes_samples = cmaes_samples[best_cmaes_indices]\n                \n                mean = np.mean(best_cmaes_samples, axis=0)\n\n                # Update covariance (simplified - can be improved with CMA-ES update rules)\n                covariance = np.cov(best_cmaes_samples, rowvar=False)\n                \n                # Replace worst PSO particles with best CMA-ES particles (elitism)\n                worst_pso_indices = np.argsort(personal_best_fitness)[-self.pop_size // 2:]\n                population[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_positions[worst_pso_indices] = best_cmaes_samples.copy()\n                personal_best_fitness[worst_pso_indices] = cmaes_fitness[best_cmaes_indices]\n                \n                # Update global best\n                global_best_index = np.argmin(personal_best_fitness)\n                global_best_position = personal_best_positions[global_best_index]\n                global_best_fitness = personal_best_fitness[global_best_index]\n                \n\n            if self.budget <= 0:\n                break\n\n        self.f_opt = global_best_fitness\n        self.x_opt = global_best_position\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSO_CMAES scored 0.390 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f199cca-b70f-4191-97ef-3d3d13743c01"], "operator": null, "metadata": {"aucs": [0.19708101656424393, 0.21880959189490812, 0.40687604126198074, 0.5099507639366532, 0.2793050350732078, 0.40729158529438947, 0.29846323448810796, 0.34249490423085704, 0.3763535387666075, 0.22335055850500107, 0.5957335296840556, 0.9982478663773203, 0.3008928004626912, 0.25520825760311894, 0.6523937671490613, 0.3489891678021041, 0.2888570284360158, 0.4208577793531023, 0.20980481792923622, 0.4754460240718663]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "0d789cb4-ff31-4492-9904-188c5c08a7de", "fitness": 0.5658574842790569, "name": "CulturalDifferentialEvolution", "description": "A streamlined Cultural Differential Evolution with adaptive parameter control and belief space influence to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass CulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, cr=0.7, f=0.8, belief_space_size=8):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr\n        self.f = f\n        self.belief_space_size = belief_space_size\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                \n                # Adaptive F: Reduce F over time\n                adaptive_f = self.f * (1 - generation/ (self.budget/self.pop_size))\n\n                x_mutated = x_r1 + adaptive_f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning:  Dynamic influence from belief space\n                belief_idx = np.random.randint(self.belief_space_size)\n                influence = 0.1 * np.exp(-generation / (self.budget/self.pop_size)*5) #Decreasing influence over time\n                x_trial = x_trial + influence * (belief_space[belief_idx] - x_trial)\n                x_trial = np.clip(x_trial, lb, ub)\n\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n\n                # Update belief space using elitist replacement\n                if f_trial < np.max(fitness[np.argsort(fitness)[:self.belief_space_size]]):\n                    worst_belief_idx = np.argmax(fitness[np.argsort(fitness)[:self.belief_space_size]])\n                    \n                    belief_space[worst_belief_idx] = x_trial\n                    \n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "The algorithm CulturalDifferentialEvolution scored 0.566 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.2533947286631413, 0.4730381849273335, 0.4771805560437057, 0.826911534526031, 0.5758210846735541, 0.6276206528582383, 0.4475520088698648, 0.5299201559889346, 0.5851012967039205, 0.5112385125456606, 0.7950691437044719, 0.9965974375733186, 0.3465535136886806, 0.50286600862983, 0.8784790251454757, 0.5721073198097053, 0.4554144611928118, 0.6942993969618421, 0.23210500831311065, 0.5358796547615087]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "89835a5e-a177-4642-90da-d4d34df58dae", "fitness": "-inf", "name": "AdaptiveDE_CMAES", "description": "A hybrid algorithm combining Differential Evolution with a dynamically adapting population based on the fitness landscape and local search using CMA-ES for refinement.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveDE_CMAES:\n    def __init__(self, budget=10000, dim=10, pop_size_init=50, cr=0.7, f=0.8, local_search_prob=0.1, pop_adapt_freq=20, min_pop_size=10, max_pop_size=100):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_init\n        self.pop_size_init = pop_size_init\n        self.cr = cr\n        self.f = f\n        self.local_search_prob = local_search_prob\n        self.pop_adapt_freq = pop_adapt_freq\n        self.min_pop_size = min_pop_size\n        self.max_pop_size = max_pop_size\n        self.generation = 0\n        self.fitness_history = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n\n        while self.budget > 0:\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n\n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n\n                # Local Search with CMA-ES\n                if np.random.rand() < self.local_search_prob:\n                    try:\n                        res = minimize(func, x_trial, method='Nelder-Mead',\n                                       bounds=func.bounds)  # CMA-ES fails sometimes\n                        x_local = res.x\n                        f_local = res.fun\n                        if self.budget > 0:\n                             self.budget -= 1\n                    except:\n                        x_local = x_trial\n                        f_local = func(x_trial)\n                        if self.budget > 0:\n                            self.budget -= 1\n                    \n                    if f_local < fitness[i]:\n                        x_trial = x_local\n                        f_trial = f_local\n\n                # Evaluate trial vector\n                else:\n                    f_trial = func(x_trial)\n                    if self.budget > 0:\n                        self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    new_fitness.append(f_trial)\n                    new_population.append(x_trial)\n                else:\n                    new_fitness.append(fitness[i])\n                    new_population.append(population[i])\n\n                # Update overall best\n                if new_fitness[-1] < self.f_opt:\n                    self.f_opt = new_fitness[-1]\n                    self.x_opt = new_population[-1]\n\n                if self.budget <= 0:\n                    break\n            \n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            \n            self.fitness_history.append(self.f_opt)\n            \n            # Population Adaptation\n            if self.generation % self.pop_adapt_freq == 0:\n                fitness_std = np.std(fitness)\n                if fitness_std > 1e-3:  # Check for diversity\n                    self.pop_size = min(self.max_pop_size, int(self.pop_size * 1.1))  # Increase pop size\n                else:\n                    self.pop_size = max(self.min_pop_size, int(self.pop_size * 0.9))  # Decrease pop size\n                \n                # Regenerate population if size changes significantly\n                if self.pop_size != len(population):\n                    num_to_add = self.pop_size - len(population)\n                    if num_to_add > 0:\n                        new_individuals = np.random.uniform(lb, ub, size=(num_to_add, self.dim))\n                        new_fitnesses = np.array([func(x) for x in new_individuals])\n                        if self.budget > 0:\n                            self.budget -= len(new_individuals)\n                        population = np.concatenate((population, new_individuals))\n                        fitness = np.concatenate((fitness, new_fitnesses))\n                    elif num_to_add < 0:\n                        indices_to_remove = np.argsort(fitness)[num_to_add:] #remove worst\n                        population = np.delete(population, indices_to_remove, axis=0)\n                        fitness = np.delete(fitness, indices_to_remove)\n                    \n                    if self.budget <= 0:\n                        break\n            \n\n            self.generation += 1\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "In the code, line 8, in __init__, the following error occurred:\nNameError: name 'pop_init' is not defined\nOn line: self.pop_size = pop_init", "error": "In the code, line 8, in __init__, the following error occurred:\nNameError: name 'pop_init' is not defined\nOn line: self.pop_size = pop_init", "parent_ids": ["55ac5cad-40cd-45d2-9ec4-0ce083c2ff9f"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "af264b7e-d08b-46ed-86b7-88cd074668ec", "fitness": 0.38538658299761874, "name": "BacterialDifferentialEvolution", "description": "Bio-inspired optimization combining aspects of bacterial foraging and differential evolution with adaptive step sizes and chemotaxis based on individual and population fitness.", "code": "import numpy as np\n\nclass BacterialDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f=0.8, tumble_prob=0.1, step_size_adapt=0.95, elimination_dispersion=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr\n        self.f = f\n        self.tumble_prob = tumble_prob\n        self.step_size_adapt = step_size_adapt\n        self.elimination_dispersion = elimination_dispersion # Probability of randomly re-initializing individuals.\n        self.step_sizes = np.ones(pop_size) # Individual step sizes for chemotaxis\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n\n        while self.budget > 0:\n            # Chemotaxis and Reproduction\n            for i in range(self.pop_size):\n                # Bacterial Foraging - Chemotaxis\n                \n                # Tumble (random direction)\n                if np.random.rand() < self.tumble_prob:\n                    delta = np.random.uniform(-1, 1, size=self.dim)\n                    delta /= np.linalg.norm(delta)  # Normalize\n                else: # Run (move in the same direction)\n                    delta = self.last_delta[i] if hasattr(self, 'last_delta') and i < len(self.last_delta) else np.random.uniform(-1, 1, size=self.dim)\n                    delta /= np.linalg.norm(delta)\n\n                x_new = population[i] + self.step_sizes[i] * delta\n                x_new = np.clip(x_new, lb, ub)\n                f_new = func(x_new)\n                self.budget -= 1\n                \n                if self.budget <= 0:\n                    break\n\n                if f_new < fitness[i]:\n                    fitness[i] = f_new\n                    population[i] = x_new\n                    self.last_delta = population - np.roll(population, 1, axis=0) # Crude estimate, not actual directions taken\n                    self.step_sizes[i] *= (1 + self.step_size_adapt)  # Increase step size if successful\n                else:\n                    self.step_sizes[i] *= self.step_size_adapt # Decrease step size if unsuccessful.\n\n                # Update overall best\n                if f_new < self.f_opt:\n                    self.f_opt = f_new\n                    self.x_opt = x_new\n            \n            if self.budget <= 0:\n                break\n            \n            # Differential Evolution Mutation\n            for i in range(self.pop_size):\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n\n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                f_trial = func(x_trial)\n                self.budget -= 1\n                if self.budget <= 0:\n                    break\n                \n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n            \n            if self.budget <= 0:\n                break\n\n            # Elimination and Dispersal\n            worst_fitness_idx = np.argmax(fitness)\n            if np.random.rand() < self.elimination_dispersion:\n              population[worst_fitness_idx] = np.random.uniform(lb, ub, size=self.dim)\n              fitness[worst_fitness_idx] = func(population[worst_fitness_idx])\n              self.budget -= 1\n\n              if fitness[worst_fitness_idx] < self.f_opt:\n                self.f_opt = fitness[worst_fitness_idx]\n                self.x_opt = population[worst_fitness_idx]\n        \n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm BacterialDifferentialEvolution scored 0.385 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["55ac5cad-40cd-45d2-9ec4-0ce083c2ff9f"], "operator": null, "metadata": {"aucs": [0.14822889801116157, 0.20923284014904475, 0.35739703999164585, 0.46419379344057465, 0.3156134970968808, 0.4281122455375739, 0.29206667523577534, 0.32109367046084714, 0.3165201286371794, 0.20103659545604746, 0.4550060062609844, 0.9990405724123594, 0.2818089737615923, 0.33000753588577414, 0.7299451051765491, 0.40083402783672606, 0.30453278851452714, 0.4794591883849837, 0.19183234939716176, 0.481769728304987]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "e0070898-7714-4115-aaeb-a813e54a527d", "fitness": 0.5554330620799343, "name": "AdaptiveACO", "description": "A simplified Ant Colony Optimization with adaptive pheromone and a focus on intensifying search around the best solution found so far.", "code": "import numpy as np\n\nclass AdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.1, q=1.0, initial_exploration=0.3, stagnation_threshold=5):\n        \"\"\"\n        Initializes the Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            stagnation_threshold (int): Number of iterations without improvement before exploration range reduction.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.stagnation_threshold = stagnation_threshold\n        self.pheromone = np.ones(self.dim) * 0.5  # Initialize pheromone\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        evaluations = 0\n        stagnation_counter = 0\n        prev_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n\n            # Stagnation detection and adaptive exploration range\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                stagnation_counter += 1\n                if stagnation_counter > self.stagnation_threshold:\n                    self.exploration_range *= 0.75  # Reduce exploration when stagnating, less aggressive\n                    stagnation_counter = 0  # Reset counter\n            else:\n                stagnation_counter = 0\n                self.exploration_range = min(0.3, self.exploration_range * 1.05)  # Increase exploration if improving, but cap it. less aggressive\n\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution.\n        \"\"\"\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            return np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n\n        x = np.zeros(self.dim)\n        for i in range(self.dim):\n            lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n            ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n            x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions. Simplified pheromone update.\n        \"\"\"\n        best_index = np.argmin(fitnesses)\n        best_solution_iteration = solutions[best_index]\n        best_fitness_iteration = fitnesses[best_index]\n\n        if best_fitness_iteration < self.best_fitness:\n            # Pheromone deposit proportional to the improvement\n            deposit = self.q * (self.best_fitness - best_fitness_iteration)\n            # Directly update pheromone based on the difference from the current best.\n            pheromone_update = deposit * (best_solution_iteration - self.best_solution) # changed to a direction.\n\n            self.pheromone += pheromone_update\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0) #ensure bounds\n            self.pheromone *= (1 - self.evaporation_rate)  # Apply evaporation\n\n", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveACO scored 0.555 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["94491ede-4777-45ba-b495-cfc2e6ba28a4"], "operator": null, "metadata": {"aucs": [0.18864931692413278, 0.3729800550564645, 0.7574899103372665, 0.8966294177066817, 0.7485236078587632, 0.8005085958950889, 0.2500732572307245, 0.6711234254146676, 0.32328790802643925, 0.1903847554046425, 0.8868111698968238, 0.9944243226713387, 0.2387179468647912, 0.2787528365439217, 0.8978758939912722, 0.41656759827790035, 0.661772015561335, 0.8487476327577395, 0.17983289946247083, 0.5055086757162206]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "42193ac8-cb8a-47d1-aa8a-ed307889b556", "fitness": "-inf", "name": "AdaptiveACO", "description": "An enhanced Ant Colony Optimization with adaptive pheromone updates based on solution diversity and age, dynamic exploration range adjustment based on stagnation detection and a local search mechanism guided by pheromone levels.", "code": "import numpy as np\n\nclass AdaptiveACO:\n    def __init__(self, budget=10000, dim=10, n_ants=15, evaporation_rate=0.1, q=1.0, initial_exploration=0.3, perturbation_rate=0.05, stagnation_threshold=5, local_search_probability=0.1):\n        \"\"\"\n        Initializes the Adaptive Ant Colony Optimization algorithm.\n\n        Args:\n            budget (int): The maximum number of function evaluations.\n            dim (int): The dimensionality of the search space.\n            n_ants (int): The number of ants in the colony.\n            evaporation_rate (float): The rate at which pheromone evaporates.\n            q (float): Parameter controlling pheromone deposit amount.\n            initial_exploration (float): Initial range for exploration (fraction of search space).\n            perturbation_rate (float): Probability of perturbing a dimension in a solution.\n            stagnation_threshold (int): Number of iterations without improvement before exploration range reduction.\n            local_search_probability (float): Probability of performing a local search around a solution.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.n_ants = n_ants\n        self.evaporation_rate = evaporation_rate\n        self.q = q\n        self.pheromone = None\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.bounds = None\n        self.exploration_range = initial_exploration\n        self.perturbation_rate = perturbation_rate\n        self.stagnation_threshold = stagnation_threshold\n        self.local_search_probability = local_search_probability\n        self.solution_ages = {}  # Track age of solutions\n\n\n    def __call__(self, func):\n        \"\"\"\n        Optimizes the given function using Adaptive Ant Colony Optimization.\n\n        Args:\n            func (callable): The black-box function to optimize.\n\n        Returns:\n            tuple: A tuple containing the best fitness value found and the corresponding solution.\n        \"\"\"\n\n        self.bounds = func.bounds\n        self.pheromone = np.ones(self.dim) * 0.5  # Initialize pheromone\n        evaluations = 0\n        stagnation_counter = 0\n        prev_best_fitness = np.inf\n\n        while evaluations < self.budget:\n            solutions = []\n            fitnesses = []\n            for _ in range(self.n_ants):\n                x = self.generate_solution()\n                f = func(x)\n                evaluations += 1\n\n                solutions.append(x)\n                fitnesses.append(f)\n\n                if f < self.best_fitness:\n                    self.best_fitness = f\n                    self.best_solution = x\n                    self.solution_ages[tuple(x)] = 0  # Reset age when a solution is updated\n                else:\n                    # Increment the age of the current solution if it is not the best\n                    if tuple(x) in self.solution_ages:\n                        self.solution_ages[tuple(x)] += 1\n                    else:\n                        self.solution_ages[tuple(x)] = 0\n\n\n                if np.random.rand() < self.local_search_probability:\n                    x_local = self.local_search(x, func, evaluations)\n                    f_local = func(x_local)\n                    evaluations += 1\n\n                    if f_local < f:\n                        x = x_local\n                        f = f_local\n                        solutions[-1] = x\n                        fitnesses[-1] = f\n\n\n                    if f < self.best_fitness:\n                        self.best_fitness = f\n                        self.best_solution = x\n                        self.solution_ages[tuple(x)] = 0 # Reset age\n\n                if evaluations >= self.budget:\n                    break\n\n            self.update_pheromone(solutions, fitnesses)\n            self.pheromone *= (1 - self.evaporation_rate)\n            self.pheromone = np.clip(self.pheromone, 0.01, 1.0)\n\n\n            # Stagnation detection and adaptive exploration range\n            if abs(self.best_fitness - prev_best_fitness) < 1e-6:\n                stagnation_counter += 1\n                if stagnation_counter > self.stagnation_threshold:\n                    self.exploration_range *= 0.6  # Reduce exploration when stagnating\n                    stagnation_counter = 0  # Reset counter\n            else:\n                stagnation_counter = 0\n                self.exploration_range = min(0.3, self.exploration_range * 1.1)  # Increase exploration if improving, but cap it.\n\n\n            prev_best_fitness = self.best_fitness\n\n        return self.best_fitness, self.best_solution\n\n    def generate_solution(self):\n        \"\"\"\n        Generates a solution for an ant, biased towards the current best solution and pheromone.\n        \"\"\"\n        if self.best_solution is None:\n            # Initial exploration: random solution\n            return np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n\n        x = self.best_solution.copy()\n        for i in range(self.dim):\n            if np.random.rand() < self.perturbation_rate:  # Perturbation\n                x[i] = np.random.uniform(self.bounds.lb[i], self.bounds.ub[i])\n            else:\n                # Pheromone-guided exploration\n                lb = max(self.bounds.lb[i], self.best_solution[i] - self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                ub = min(self.bounds.ub[i], self.best_solution[i] + self.exploration_range * (self.bounds.ub[i] - self.bounds.lb[i]) * self.pheromone[i])\n                x[i] = np.random.uniform(lb, ub)\n        return x\n\n    def update_pheromone(self, solutions, fitnesses):\n        \"\"\"\n        Updates pheromone trails, rewarding better solutions, considering solution diversity and age.\n        \"\"\"\n        best_index = np.argmin(fitnesses)\n        best_solution_iteration = solutions[best_index]\n        best_fitness_iteration = fitnesses[best_index]\n\n        # Calculate solution diversity (e.g., average distance to other solutions)\n        diversity = 0\n        for i in range(self.n_ants):\n            if i != best_index:\n                diversity += np.linalg.norm(np.array(best_solution_iteration) - np.array(solutions[i]))\n        diversity /= (self.n_ants - 1 + 1e-9)\n\n        # Adjust pheromone deposit based on fitness improvement, diversity and age\n        age = self.solution_ages.get(tuple(best_solution_iteration), 0) # Age of the solution\n        age_factor = np.exp(-age / 10)  # Penalize older solutions\n\n        if best_fitness_iteration < np.mean(fitnesses): # ensure it's actually better than average to avoid misleading updates.\n            deposit = self.q * (np.mean(fitnesses) - best_fitness_iteration) * diversity * age_factor\n            self.pheromone += deposit * np.abs(best_solution_iteration - self.best_solution)\n\n\n        # Normalize pheromone updates\n        self.pheromone /= np.sum(self.pheromone) + 1e-9\n\n\n    def local_search(self, solution, func, evaluations, radius=0.1):\n        \"\"\"\n        Performs a local search around a solution.\n\n        Args:\n            solution (np.ndarray): The solution to search around.\n            func (callable): The black-box function to optimize.\n            evaluations (int): Number of function evaluations so far.\n            radius (float): The radius of the local search.\n\n        Returns:\n            np.ndarray: The improved solution.\n        \"\"\"\n        best_solution = solution.copy()\n        best_fitness = func(best_solution)\n        evaluations += 1\n\n        for _ in range(5):  # Limited local evaluations\n            neighbor = solution.copy()\n            for i in range(self.dim):\n                neighbor[i] += np.random.uniform(-radius, radius) * (self.bounds.ub[i] - self.bounds.lb[i])\n                neighbor[i] = np.clip(neighbor[i], self.bounds.lb[i], self.bounds.ub[i])\n\n            fitness = func(neighbor)\n            evaluations += 1\n\n            if fitness < best_fitness:\n                best_fitness = fitness\n                best_solution = neighbor\n\n        return best_solution", "configspace": "", "generation": 6, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["94491ede-4777-45ba-b495-cfc2e6ba28a4"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "b74c2b0d-4c48-4477-a287-77e6ab627c01", "fitness": 0.7373788991217323, "name": "AdaptiveCulturalDifferentialEvolution", "description": "A simplified self-adaptive Cultural Differential Evolution with dynamic parameter control based on success history and belief space adaptation, focusing on efficiency and exploration.", "code": "import numpy as np\n\nclass AdaptiveCulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=40, cr=0.7, f=0.8, belief_space_size=5, local_search_prob=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = belief_space_size # Size of the belief space\n        self.local_search_prob = local_search_prob # Probability of local search\n\n        self.cr_history = []\n        self.f_history = []\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n        belief_fitness = np.sort(fitness)[:self.belief_space_size].copy()\n\n        generation = 0\n        while self.budget > 0:\n            generation += 1\n            \n            # Adaptive Parameter Control (simplified)\n            if generation > 5 and self.cr_history and self.f_history:\n                self.cr = np.clip(np.mean(self.cr_history), 0.2, 0.9)\n                self.f = np.clip(np.mean(self.f_history), 0.2, 1.0)\n                self.cr_history = []\n                self.f_history = []\n\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning (simplified influence)\n                belief_idx = np.random.randint(self.belief_space_size)\n                x_trial = 0.8 * x_trial + 0.2 * belief_space[belief_idx]  # Weighted average\n                x_trial = np.clip(x_trial, lb, ub)\n                \n                # Local Search (less frequent)\n                if np.random.rand() < self.local_search_prob:\n                    x_trial = x_trial + np.random.normal(0, 0.01 * (ub - lb), self.dim)\n                    x_trial = np.clip(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    # Update CR/F history\n                    self.cr_history.append(self.cr)\n                    self.f_history.append(self.f)\n                    \n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    \n                    # Simplified Belief Space Update\n                    if f_trial < belief_fitness[-1]:\n                        belief_fitness[-1] = f_trial\n                        belief_space[-1] = x_trial\n                        \n                        # Re-sort belief space\n                        sorted_indices = np.argsort(belief_fitness)\n                        belief_fitness = belief_fitness[sorted_indices]\n                        belief_space = belief_space[sorted_indices]\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n            \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveCulturalDifferentialEvolution scored 0.737 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["acecb8ce-e251-4aab-a92b-4a34ce1be12e"], "operator": null, "metadata": {"aucs": [0.3221755796665017, 0.6810726725133507, 0.7773666870207309, 0.9082693328095413, 0.8336458795754655, 0.8561324399410427, 0.7456807621628245, 0.7643018161937823, 0.82624127806947, 0.7786380625701927, 0.9032494589056242, 0.9959419880335441, 0.4411464043625075, 0.7872545926071123, 0.9357327806850363, 0.8604343179523692, 0.6867838759268489, 0.902470897555584, 0.20581351880542353, 0.5352256370776899]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "67e4e96a-a31b-4145-8426-e90bcd0cfdd3", "fitness": 0.27979890221588766, "name": "SocialDistanceMutation", "description": "A hybrid algorithm combining Social Learning Optimization with a Distance-based Mutation strategy for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass SocialDistanceMutation:\n    def __init__(self, budget=10000, dim=10, pop_size=50, social_rate=0.5, mutation_rate=0.3, distance_factor=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.social_rate = social_rate  # Probability of social learning\n        self.mutation_rate = mutation_rate  # Probability of distance-based mutation\n        self.distance_factor = distance_factor # Scaling factor for distance-based mutation\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n\n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n\n        while self.budget > 0:\n            for i in range(self.pop_size):\n                # Social Learning Phase\n                if np.random.rand() < self.social_rate:\n                    # Select a random learner (excluding the current individual)\n                    learner_idx = np.random.choice([j for j in range(self.pop_size) if j != i])\n                    \n                    # Learn from the better individual\n                    if fitness[learner_idx] < fitness[i]:\n                        x_new = population[i] + np.random.rand() * (population[learner_idx] - population[i])\n                    else:\n                         x_new = population[i] + np.random.rand() * (self.x_opt - population[i])   # Learn from best\n                    \n                    x_new = np.clip(x_new, lb, ub)\n                else:\n                    x_new = population[i].copy() # No social learning\n\n\n                # Distance-Based Mutation Phase\n                if np.random.rand() < self.mutation_rate:\n                    # Calculate distances to other individuals\n                    distances = np.linalg.norm(population - population[i], axis=1)\n                    \n                    # Select a neighbor based on inverse distance (closer neighbors have higher probability)\n                    probabilities = 1.0 / (distances + 1e-8)  # Avoid division by zero\n                    probabilities[i] = 0  # Exclude the current individual\n                    probabilities /= np.sum(probabilities)\n                    \n                    neighbor_idx = np.random.choice(self.pop_size, p=probabilities)\n                    \n                    # Mutate based on the difference with the neighbor and best solution\n                    x_new = x_new + self.distance_factor * (population[neighbor_idx] - x_new) + np.random.rand()*(self.x_opt - x_new)\n                    x_new = np.clip(x_new, lb, ub)\n\n                # Evaluate the new solution\n                f_new = func(x_new)\n                self.budget -= 1\n\n                # Selection\n                if f_new < fitness[i]:\n                    fitness[i] = f_new\n                    population[i] = x_new\n\n                    # Update overall best\n                    if f_new < self.f_opt:\n                        self.f_opt = f_new\n                        self.x_opt = x_new\n\n                if self.budget <= 0:\n                    break\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm SocialDistanceMutation scored 0.280 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["acecb8ce-e251-4aab-a92b-4a34ce1be12e"], "operator": null, "metadata": {"aucs": [0.12455481926938228, 0.21314233544866734, 0.3255578420696763, 0.19481607718088412, 0.1751019521015913, 0.18224506292929, 0.22313916478631324, 0.2367849223466867, 0.21416800860001717, 0.1870284043002608, 0.17521511018316016, 0.9975597320133116, 0.2684576516938608, 0.18221804076221793, 0.5646638956090162, 0.2603816285849654, 0.21846849518017697, 0.21321663242057964, 0.18147811969933036, 0.4577801491383626]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "4a8ddfee-37b1-4860-aad2-a0845cd2cb09", "fitness": 0.5696949966909471, "name": "AdaptiveCulturalDifferentialEvolution", "description": "Adaptive Cultural Differential Evolution with dynamic parameter adjustment and a refined belief space update mechanism based on generational success, promoting better convergence and exploration.", "code": "import numpy as np\n\nclass AdaptiveCulturalDifferentialEvolution:\n    def __init__(self, budget=10000, dim=10, pop_size=50, cr=0.7, f=0.8, belief_space_size=10, learning_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.cr = cr  # Crossover rate\n        self.f = f    # Differential weight\n        self.belief_space_size = belief_space_size # Size of the belief space for cultural learning\n        self.learning_rate = learning_rate # Learning rate for belief space adaptation\n        self.success_rate = 0.0\n        self.success_history = []\n        self.history_length = 10\n\n    def __call__(self, func):\n        lb = func.bounds.lb\n        ub = func.bounds.ub\n        \n        # Initialize population\n        population = np.random.uniform(lb, ub, size=(self.pop_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        self.budget -= self.pop_size\n\n        self.f_opt = np.min(fitness)\n        self.x_opt = population[np.argmin(fitness)]\n        \n        # Initialize belief space (best individuals observed so far)\n        belief_space = population[np.argsort(fitness)[:self.belief_space_size]].copy()\n        belief_fitness = np.sort(fitness)[:self.belief_space_size].copy()\n\n        generation = 0\n        while self.budget > 0:\n            successful_individuals = 0\n            for i in range(self.pop_size):\n                # Differential Evolution Mutation\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = population[idxs]\n                x_mutated = x_r1 + self.f * (x_r2 - x_r3)\n                x_mutated = np.clip(x_mutated, lb, ub)\n                \n                # Crossover\n                x_trial = population[i].copy()\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.cr or j == j_rand:\n                        x_trial[j] = x_mutated[j]\n                \n                # Cultural Learning: Bias towards best from belief space\n                belief_idx = np.random.randint(self.belief_space_size)\n                x_trial = x_trial + self.learning_rate * (belief_space[belief_idx] - x_trial)\n                x_trial = np.clip(x_trial, lb, ub)\n\n                # Evaluate trial vector\n                f_trial = func(x_trial)\n                self.budget -= 1\n\n                # Selection\n                if f_trial < fitness[i]:\n                    fitness[i] = f_trial\n                    population[i] = x_trial\n                    successful_individuals += 1\n                    \n                    # Update belief space if necessary\n                    if f_trial < belief_fitness[-1]:\n                        belief_fitness[-1] = f_trial\n                        belief_space[-1] = x_trial\n                        \n                        # Re-sort belief space to maintain order\n                        sorted_indices = np.argsort(belief_fitness)\n                        belief_fitness = belief_fitness[sorted_indices]\n                        belief_space = belief_space[sorted_indices]\n\n                # Update overall best\n                if f_trial < self.f_opt:\n                    self.f_opt = f_trial\n                    self.x_opt = x_trial\n                    \n                if self.budget <= 0:\n                    break\n            \n            # Adaptive Parameter Control\n            success_rate = successful_individuals / self.pop_size\n            self.success_history.append(success_rate)\n            if len(self.success_history) > self.history_length:\n                self.success_history.pop(0)\n            \n            avg_success_rate = np.mean(self.success_history)\n\n            # Adjust F and CR based on success rate\n            if avg_success_rate > 0.3:\n                self.f = min(self.f + 0.05, 1.0)\n                self.cr = min(self.cr + 0.05, 1.0)\n            else:\n                self.f = max(self.f - 0.05, 0.1)\n                self.cr = max(self.cr - 0.05, 0.1)\n            \n            # Adapt Learning Rate\n            if avg_success_rate < 0.1:\n                self.learning_rate = min(self.learning_rate + 0.02, 0.5)  # Increase influence of belief space if low success\n            else:\n                self.learning_rate = max(self.learning_rate - 0.01, 0.01) # Decrease influence if high\n\n            generation += 1\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveCulturalDifferentialEvolution scored 0.570 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["05656a4c-0409-47f2-a4a8-145337fceb02"], "operator": null, "metadata": {"aucs": [0.2679918974305415, 0.42885930774754843, 0.5575392030240536, 0.7913909316782592, 0.6688378990418321, 0.6744162864789063, 0.3900694797545414, 0.5007865903839552, 0.6496600691656623, 0.4456877873870133, 0.6450090401849888, 0.9897985007440214, 0.26746911921221805, 0.44797735262105975, 0.7308425147341182, 0.6985419389508666, 0.4639986510329379, 0.7810765113275504, 0.47527692459867044, 0.5186699283201992]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
