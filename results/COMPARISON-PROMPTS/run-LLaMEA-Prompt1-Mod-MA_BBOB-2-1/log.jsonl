{"id": "76cbb891-f2f7-48b1-acb4-6546b9e07479", "fitness": 0.46369309212160087, "name": "AdaptiveDE", "description": "An Adaptive Differential Evolution strategy that adjusts its parameters based on the success rate of previous generations.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9):\n        \"\"\"\n        Adaptive Differential Evolution.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        \n        \n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x_r1, x_r2, x_r3 = pop[indices]\n            mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n        \n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                \n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on success history.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            if success_rate > 0.2:  # Adjust aggressively if doing well\n                self.F *= 1.05\n                self.CR *= 1.05\n            elif success_rate < 0.1:  # Adjust conservatively if not doing well\n                self.F *= 0.95\n                self.CR *= 0.95\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n        \n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n            \n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n            \n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n            \n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n            \n            old_fitness = self.fitness.copy() #keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n            \n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n                \n            self.adapt_parameters()\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDE scored 0.464 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.21407298399575758, 0.27890046190477924, 0.4264166204305142, 0.6836198271911686, 0.4249081318868566, 0.45974195204890755, 0.35255238069663086, 0.35452481265457003, 0.3886523933962934, 0.3861526500017195, 0.652618504656395, 0.9849892229411877, 0.309428893378596, 0.44284452529929486, 0.789550591008507, 0.4575964899094743, 0.3568189675856288, 0.5469623357317714, 0.2603781285399537, 0.5031319691740102]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "496e5c38-a548-41f2-a339-6bfb925dfbda", "fitness": "-inf", "name": "NovelAdaptiveDE", "description": "Self-Adaptive Differential Evolution with ensemble of mutation strategies and archive for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass NovelAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        \"\"\"\n        Self-Adaptive Differential Evolution with mutation ensemble and archive.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            archive_size (int): Size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.archive = []\n        self.archive_fitness = []\n\n        # Mutation strategy probabilities (initialized equally)\n        self.mutation_probs = np.array([0.3, 0.3, 0.4]) # Probabilities for DE/rand/1, DE/current-to-rand/1, and DE/best/1\n        self.mutation_strategies = [self.mutate_rand1, self.mutate_current_to_rand1, self.mutate_best1]\n\n        # Learning rates for mutation probabilities\n        self.prob_learning_rate = 0.1\n\n        # Parameters\n        self.F = 0.5\n        self.CR = 0.9\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        \n        \n    def mutate_rand1(self, pop, F):\n        \"\"\"DE/rand/1 mutation strategy.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x_r1, x_r2, x_r3 = pop[indices]\n            mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n        return mutated_pop\n\n    def mutate_current_to_rand1(self, pop, F):\n        \"\"\"DE/current-to-rand/1 mutation.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x_r1, x_r2 = pop[indices]\n            mutated_pop[i] = pop[i] + F * (x_r1 - pop[i]) + F * (x_r2 - pop[i])\n        return mutated_pop\n    \n    def mutate_best1(self, pop, F):\n        \"\"\"DE/best/1 mutation.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        best_index = np.argmin(self.fitness)\n        x_best = pop[best_index]\n        for i in range(self.pop_size):\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x_r1, x_r2 = pop[indices]\n            mutated_pop[i] = x_best + F * (x_r1 - x_r2)\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop, mutation_index):\n        \"\"\"Performs the selection operation and updates archive.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n        \n        improved_indices = []\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                improved_indices.append(i)\n                \n                # Update archive\n                if len(self.archive) < self.archive_size:\n                    self.archive.append(self.pop[i].copy())\n                    self.archive_fitness.append(self.fitness[i])\n                else:\n                    worst_arch_index = np.argmax(self.archive_fitness)\n                    if self.fitness[i] < self.archive_fitness[worst_arch_index]:\n                        self.archive[worst_arch_index] = self.pop[i].copy()\n                        self.archive_fitness[worst_arch_index] = self.fitness[i]\n                \n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n        \n        # Update mutation probabilities\n        if improved_indices:\n            self.mutation_probs[mutation_index] += self.prob_learning_rate * np.mean(new_fitness[improved_indices] < self.fitness[improved_indices])\n        else:\n            self.mutation_probs[mutation_index] -= self.prob_learning_rate * 0.1 #small penalty if no improvement\n\n        self.mutation_probs = np.maximum(0, self.mutation_probs)  # Ensure probabilities are non-negative\n        self.mutation_probs /= np.sum(self.mutation_probs)      # Normalize to sum to 1\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on success history.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            if success_rate > 0.2:  # Adjust aggressively if doing well\n                self.F *= 1.05\n                self.CR *= 1.05\n            elif success_rate < 0.1:  # Adjust conservatively if not doing well\n                self.F *= 0.95\n                self.CR *= 0.95\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n        \n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n            \n            # Choose mutation strategy based on probabilities\n            mutation_index = np.random.choice(len(self.mutation_strategies), p=self.mutation_probs)\n            mutate = self.mutation_strategies[mutation_index]\n\n            mutated_pop = mutate(self.pop, F)\n            \n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n            \n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n            \n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n            \n            old_fitness = self.fitness.copy() #keep old fitness for success rate calculation\n            self.selection(func, crossed_pop, mutation_index)\n            \n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n                \n            self.adapt_parameters()\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 1, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["76cbb891-f2f7-48b1-acb4-6546b9e07479"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "bf8749ff-3475-4e54-a3f6-ef2fd0897f9a", "fitness": "-inf", "name": "EnhancedAdaptiveDE", "description": "An enhanced Adaptive Differential Evolution strategy that incorporates a self-adaptive population size and covariance matrix adaptation for mutation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, initial_pop_size=50, F=0.5, CR=0.9, pop_size_adaptation_rate=0.05):\n        \"\"\"\n        Enhanced Adaptive Differential Evolution with self-adaptive population size and CMA-based mutation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            initial_pop_size (int): Initial population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            pop_size_adaptation_rate (float): Rate at which population size adapts.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = initial_pop_size\n        self.pop_size = initial_pop_size  # Current population size\n        self.F = F\n        self.CR = CR\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.pop_size_adaptation_rate = pop_size_adaptation_rate\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n        # CMA-ES related parameters\n        self.C = np.eye(dim)  # Covariance matrix\n        self.mean = None\n        self.sigma = 0.1 #overall standard deviation\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.mean = self.x_opt.copy()  # Initialize mean for CMA\n\n    def mutate(self, func):\n        \"\"\"Performs the mutation operation using CMA.\"\"\"\n        mutated_pop = np.zeros_like(self.pop)\n        for i in range(self.pop_size):\n            z = np.random.randn(self.dim)  # Sample from standard normal\n            mutated_pop[i] = self.mean + self.sigma * np.dot(self.C**0.5, z) # Apply CMA\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop[i] = np.clip(mutated_pop[i], func.bounds.lb, func.bounds.ub)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        improved_indices = new_fitness < self.fitness\n        self.pop[improved_indices] = crossed_pop[improved_indices]\n        self.fitness[improved_indices] = new_fitness[improved_indices]\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n            self.mean = self.x_opt.copy()\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F, CR, and population size based on success history.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            if success_rate > 0.2:  # Adjust aggressively if doing well\n                self.F *= 1.05\n                self.CR *= 1.05\n                self.pop_size = int(self.pop_size * (1 + self.pop_size_adaptation_rate))  # Increase pop size\n\n            elif success_rate < 0.1:  # Adjust conservatively if not doing well\n                self.F *= 0.95\n                self.CR *= 0.95\n                self.pop_size = max(10, int(self.pop_size * (1 - self.pop_size_adaptation_rate)))  # Decrease pop size, but ensure it doesnt go below 10\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n        #Adapt sigma\n        if self.success_history:\n            if np.mean(self.success_history[-5:])>0.4:\n                self.sigma*=1.05\n            elif np.mean(self.success_history[-5:])<0.05:\n                self.sigma*=0.95\n            self.sigma = np.clip(self.sigma, 0.0001, 1) #avoid sigma becoming 0\n\n    def adapt_covariance_matrix(self):\n        \"\"\"Simple adaptation of the covariance matrix.\"\"\"\n        if self.success_history:\n            if len(self.success_history) > 5 and np.mean(self.success_history[-5:]) > 0.3:\n                # Increase exploration along successful directions\n                best_individuals = self.pop[np.argsort(self.fitness)[:min(5, self.pop_size)]]\n                for individual in best_individuals:\n                    diff = individual - self.mean\n                    self.C += 0.01 * np.outer(diff, diff)\n                # Ensure C remains positive definite\n                self.C = np.linalg.cholesky(self.C).T @ np.linalg.cholesky(self.C)\n\n            elif len(self.success_history) > 5 and np.mean(self.success_history[-5:]) < 0.1:\n                # Reduce exploration if not improving\n                self.C *= 0.99\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(func)  # CMA-ES based mutation\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.adapt_covariance_matrix()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 2, "feedback": "In the code, line 55, in mutate, the following error occurred:\nIndexError: index 50 is out of bounds for axis 0 with size 50\nOn line: mutated_pop[i] = self.mean + self.sigma * np.dot(self.C**0.5, z) # Apply CMA", "error": "In the code, line 55, in mutate, the following error occurred:\nIndexError: index 50 is out of bounds for axis 0 with size 50\nOn line: mutated_pop[i] = self.mean + self.sigma * np.dot(self.C**0.5, z) # Apply CMA", "parent_ids": ["76cbb891-f2f7-48b1-acb4-6546b9e07479"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "956e6ce2-4368-48c9-ba0d-5c1f62ee8df6", "fitness": "-inf", "name": "AdaptiveDE", "description": "An adaptive differential evolution strategy with self-adaptive population size and parameter control based on individual success.", "code": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size_initial=50, F_initial=0.5, CR_initial=0.9, pop_size_min=10, pop_size_max=100):\n        \"\"\"\n        Adaptive Differential Evolution with self-adaptive population size and parameter control.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size_initial (int): Initial population size.\n            F_initial (float): Initial scaling factor.\n            CR_initial (float): Initial crossover rate.\n            pop_size_min (int): Minimum population size.\n            pop_size_max (int): Maximum population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size_initial\n        self.pop_size_initial = pop_size_initial\n        self.pop_size_min = pop_size_min\n        self.pop_size_max = pop_size_max\n        self.F = F_initial\n        self.CR = CR_initial\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.individual_success = None # Track success rate of each individual\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.individual_success = np.zeros(self.pop_size) # Initialize individual success rates\n\n        \n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x_r1, x_r2, x_r3 = pop[indices]\n            mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n        \n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.individual_success[i] += 1 # Increment success count\n            else:\n                self.individual_success[i] = max(0, self.individual_success[i] - 0.1) # Decay if not improving\n                \n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F, CR, and population size based on success history and individual success.\"\"\"\n        # Adjust F and CR based on average success rate\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            if success_rate > 0.2:  # Adjust aggressively if doing well\n                self.F *= 1.05\n                self.CR *= 1.05\n            elif success_rate < 0.1:  # Adjust conservatively if not doing well\n                self.F *= 0.95\n                self.CR *= 0.95\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n        # Adjust population size based on individual success.\n        success_threshold = 0.2\n        successful_individuals = np.sum(self.individual_success / np.sum(self.success_history[-10:]) > success_threshold) if len(self.success_history) > 10 else 0\n        \n        if successful_individuals > self.pop_size * 0.6 and self.pop_size < self.pop_size_max:\n            self.pop_size = min(self.pop_size + 5, self.pop_size_max) # Increase if many successful individuals\n            \n            # Resize the population to add some random individuals\n            new_individuals = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(5, self.dim))\n            new_fitnesses = np.array([func(x) for x in new_individuals])\n            self.evals += 5\n\n            self.pop = np.concatenate((self.pop, new_individuals))\n            self.fitness = np.concatenate((self.fitness, new_fitnesses))\n            self.individual_success = np.concatenate((self.individual_success, np.zeros(5)))\n\n        elif successful_individuals < self.pop_size * 0.2 and self.pop_size > self.pop_size_min:\n            self.pop_size = max(self.pop_size - 5, self.pop_size_min) # Decrease if few successful individuals\n\n            # Remove the least successful individuals (lowest success rates)\n            individual_success_rates = self.individual_success / np.sum(self.success_history[-10:]) if len(self.success_history) > 10 else self.individual_success / np.max(self.success_history) if len(self.success_history) > 0 else self.individual_success\n            \n            indices_to_remove = np.argsort(individual_success_rates)[:5]\n            self.pop = np.delete(self.pop, indices_to_remove, axis=0)\n            self.fitness = np.delete(self.fitness, indices_to_remove)\n            self.individual_success = np.delete(self.individual_success, indices_to_remove)\n            \n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n        \n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n            \n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n            \n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n            \n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n            \n            old_fitness = self.fitness.copy() #keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n            \n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n            \n            self.adapt_parameters()\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        \n        return self.f_opt, self.x_opt", "configspace": "", "generation": 3, "feedback": "In the code, line 113, in adapt_parameters, the following error occurred:\nNameError: name 'func' is not defined\nOn line: new_individuals = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(5, self.dim))", "error": "In the code, line 113, in adapt_parameters, the following error occurred:\nNameError: name 'func' is not defined\nOn line: new_individuals = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(5, self.dim))", "parent_ids": ["76cbb891-f2f7-48b1-acb4-6546b9e07479"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "b240a947-805b-4d5f-85c0-ad7f37b91f55", "fitness": "-inf", "name": "SelfAdaptiveEnsembleDE", "description": "Self-adaptive Differential Evolution with Ensemble of Mutation Strategies, utilizing a learning mechanism to dynamically adjust mutation strategy probabilities based on their observed success, combined with a mirrored sampling technique to enhance population diversity.", "code": "import numpy as np\n\nclass SelfAdaptiveEnsembleDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, num_mutation_strategies=4):\n        \"\"\"\n        Self-Adaptive Differential Evolution with Ensemble of Mutation Strategies.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            num_mutation_strategies (int): Number of mutation strategies to use.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.num_mutation_strategies = num_mutation_strategies\n        self.mutation_probs = np.ones(self.num_mutation_strategies) / self.num_mutation_strategies\n        self.mutation_successes = np.zeros(self.num_mutation_strategies)\n        self.mutation_counts = np.zeros(self.num_mutation_strategies)\n        self.mirrored_pop_ratio = 0.1 # Ratio of mirrored population\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds and adds mirrored samples.\"\"\"\n        initial_pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        \n        # Mirrored sampling\n        num_mirrored = int(self.pop_size * self.mirrored_pop_ratio)\n        mirrored_samples = func.bounds.ub + func.bounds.lb - initial_pop[:num_mirrored]\n        \n        self.pop = np.concatenate([initial_pop, mirrored_samples], axis=0)[:self.pop_size] # Keep pop_size individuals\n        \n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n        \n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n    def mutate(self, pop, F, strategy_index):\n        \"\"\"Performs the mutation operation based on the chosen strategy.\"\"\"\n        if strategy_index == 0:\n            # DE/rand/1\n            indices = np.random.choice(self.pop_size, 5, replace=False)\n            x_r1, x_r2, x_r3, x_r4, x_r5 = pop[indices]\n            mutated_pop = x_r1 + F * (x_r2 - x_r3)\n        elif strategy_index == 1:\n            # DE/current-to-rand/1\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x_r1, x_r2, x_r3 = pop[indices]\n            mutated_pop = pop[np.random.randint(self.pop_size)] + F * (x_r1 - pop[np.random.randint(self.pop_size)]) + F*(x_r2 - x_r3)\n        elif strategy_index == 2:\n            # DE/best/1\n            best_index = np.argmin(self.fitness)\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x_r1, x_r2, x_r3 = pop[indices]\n            mutated_pop = self.pop[best_index] + F * (x_r2 - x_r3)\n        elif strategy_index == 3:\n            #DE/current-to-best/1\n            best_index = np.argmin(self.fitness)\n            mutated_pop = pop + F * (self.pop[best_index] - pop) + F * (pop[np.random.randint(self.pop_size)] - pop[np.random.randint(self.pop_size)])\n        else:\n            raise ValueError(\"Invalid mutation strategy index\")\n\n        return mutated_pop\n\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n        \n        improved_indices = new_fitness < self.fitness\n        \n        self.pop[improved_indices] = crossed_pop[improved_indices]\n        self.fitness[improved_indices] = new_fitness[improved_indices]\n                \n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n    \n    def update_mutation_probs(self):\n        \"\"\"Updates the probabilities of selecting each mutation strategy based on success.\"\"\"\n        total_success = np.sum(self.mutation_successes)\n        if total_success > 0:\n            normalized_successes = self.mutation_successes / total_success\n            self.mutation_probs = 0.9 * self.mutation_probs + 0.1 * normalized_successes  # Smooth update\n        else:\n            self.mutation_probs = np.ones(self.num_mutation_strategies) / self.num_mutation_strategies  # Reset if no success\n\n        self.mutation_probs /= np.sum(self.mutation_probs)  # Normalize\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n        \n        while self.evals < self.budget:\n            \n            # Reset success counts for each generation\n            self.mutation_successes[:] = 0\n            self.mutation_counts[:] = 0\n            \n            for i in range(self.pop_size): # each individual uses possibly different mutation strategy\n                # Choose a mutation strategy based on probabilities\n                strategy_index = np.random.choice(self.num_mutation_strategies, p=self.mutation_probs)\n                self.mutation_counts[strategy_index] += 1\n\n                mutated_pop = self.mutate(self.pop[i], self.F, strategy_index) #Mutate each individual separately\n                \n                # Boundary Handling: Clip values to remain within bounds\n                mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n                \n                crossed_pop = self.crossover(self.pop[i:i+1], mutated_pop[np.newaxis,:], self.CR)  #crossover with one individual\n\n                # Boundary Handling: Clip values to remain within bounds\n                crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n                \n                new_fitness = func(crossed_pop[0])\n                self.evals += 1\n                \n                if new_fitness < self.fitness[i]:\n                    self.pop[i] = crossed_pop[0]\n                    self.fitness[i] = new_fitness\n                    self.mutation_successes[strategy_index] += 1  # Increment success for the used strategy\n\n                    if new_fitness < self.f_opt:\n                        self.f_opt = new_fitness\n                        self.x_opt = self.pop[i]\n                \n                if self.evals >= self.budget:\n                    break\n            \n            self.update_mutation_probs()\n            \n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 4, "feedback": "In the code, line 70, in mutate, the following error occurred:\nIndexError: index 35 is out of bounds for axis 0 with size 2\nOn line: mutated_pop = pop + F * (self.pop[best_index] - pop) + F * (pop[np.random.randint(self.pop_size)] - pop[np.random.randint(self.pop_size)])", "error": "In the code, line 70, in mutate, the following error occurred:\nIndexError: index 35 is out of bounds for axis 0 with size 2\nOn line: mutated_pop = pop + F * (self.pop[best_index] - pop) + F * (pop[np.random.randint(self.pop_size)] - pop[np.random.randint(self.pop_size)])", "parent_ids": ["76cbb891-f2f7-48b1-acb4-6546b9e07479"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "e7979343-bcb1-4921-b57d-76092ce7d281", "fitness": "-inf", "name": "EnsembleArchiveSADE", "description": "Self-Adaptive Differential Evolution with ensemble of mutation strategies and archive for enhanced exploration.", "code": "import numpy as np\n\nclass EnsembleArchiveSADE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=25):\n        \"\"\"\n        Self-Adaptive Differential Evolution with Ensemble of Mutation Strategies and Archive.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            archive_size (int): Size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.archive = None\n        self.archive_fitness = None\n\n        # Strategy probabilities (initially uniform)\n        self.mutation_strategies = [self.mutate_rand1, self.mutate_current_to_rand1, self.mutate_best1]\n        self.strategy_probs = np.ones(len(self.mutation_strategies)) / len(self.mutation_strategies)\n        self.memory_F = np.ones(len(self.mutation_strategies)) * 0.5\n        self.memory_CR = np.ones(len(self.mutation_strategies)) * 0.9\n        self.success_count = np.zeros(len(self.mutation_strategies))\n        self.archive_full = False\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population and archive randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        # Initialize Archive\n        self.archive = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.archive_size, self.dim))\n        self.archive_fitness = np.array([np.inf] * self.archive_size) # Initialize archive fitness with inf\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n\n    def mutate_rand1(self, pop, F, i):\n        \"\"\"Classic rand/1 mutation.\"\"\"\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        x_r1, x_r2, x_r3 = pop[indices]\n        return x_r1 + F * (x_r2 - x_r3)\n\n    def mutate_current_to_rand1(self, pop, F, i):\n         \"\"\"Current-to-rand/1 mutation.\"\"\"\n         indices = np.random.choice(self.pop_size, 3, replace=False)\n         x_r1, x_r2, x_r3 = pop[indices]\n         return pop[i] + F * (x_r1 - pop[i]) + F * (x_r2 - x_r3)\n\n    def mutate_best1(self, pop, F, i):\n         \"\"\"Best/1 mutation.\"\"\"\n         best_index = np.argmin(self.fitness)\n         indices = np.random.choice(self.pop_size, 2, replace=False)\n         x_r1, x_r2 = pop[indices]\n         return self.pop[best_index] + F * (x_r1 - x_r2)\n\n    def crossover(self, pop, mutated_pop, CR, i):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop[i])\n        for j in range(self.dim):\n            if np.random.rand() < CR or j == np.random.randint(self.dim):\n                crossed_pop[j] = mutated_pop[j]\n            else:\n                crossed_pop[j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop, i):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = func(crossed_pop)\n        self.evals += 1\n\n        if new_fitness < self.fitness[i]:\n            # Update population\n            self.pop[i] = crossed_pop\n            self.fitness[i] = new_fitness\n\n            # Update Archive\n            if self.archive_full:\n                worst_archive_index = np.argmax(self.archive_fitness)\n                if new_fitness < self.archive_fitness[worst_archive_index]:\n                    self.archive[worst_archive_index] = crossed_pop\n                    self.archive_fitness[worst_archive_index] = new_fitness\n            else:\n                archive_index = self.evals % self.archive_size #simple circular indexing\n                self.archive[archive_index] = crossed_pop\n                self.archive_fitness[archive_index] = new_fitness\n                if self.evals > self.archive_size:\n                    self.archive_full = True\n            \n            # Update best solution\n            if new_fitness < self.f_opt:\n                self.f_opt = new_fitness\n                self.x_opt = crossed_pop\n            return 1 # success\n        return 0 #failure\n\n    def adapt_parameters(self, strategy_index):\n        \"\"\"Adapts F and CR based on success history using a Lehmer mean.\"\"\"\n        if np.sum(self.success_count) > 0:\n            weights = self.success_count / np.sum(self.success_count)\n            # Lehmer mean for F and CR adaptation\n            self.memory_F[strategy_index] = np.sum(weights * self.memory_F) / np.sum(weights)\n            self.memory_CR[strategy_index] = np.sum(weights * self.memory_CR) / np.sum(weights)\n\n        self.success_count[:] = 0  # Reset success counts\n\n    def update_strategy_probabilities(self):\n        \"\"\"Updates the probabilities of choosing each mutation strategy.\"\"\"\n        performance = np.exp(self.success_count)  # Use exponential to amplify differences\n        self.strategy_probs = performance / np.sum(performance)\n        self.strategy_probs = np.clip(self.strategy_probs, 0.05, 0.95) #avoid strategy starvation\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            self.update_strategy_probabilities()\n            for i in range(self.pop_size):\n                # Strategy Selection\n                strategy_index = np.random.choice(len(self.mutation_strategies), p=self.strategy_probs)\n                mutation_strategy = self.mutation_strategies[strategy_index]\n\n                # Parameter adaptation (F and CR)\n                F = np.random.normal(self.memory_F[strategy_index], 0.1)\n                CR = np.random.normal(self.memory_CR[strategy_index], 0.1)\n                F = np.clip(F, 0.1, 1.0)\n                CR = np.clip(CR, 0.1, 1.0)\n\n                # Mutation\n                mutated_vector = mutation_strategy(self.pop, F, i)\n\n                # Boundary Handling\n                mutated_vector = np.clip(mutated_vector, func.bounds.lb, func.bounds.ub)\n\n                # Crossover\n                crossed_vector = self.crossover(self.pop, mutated_vector, CR, i)\n\n                # Boundary Handling\n                crossed_vector = np.clip(crossed_vector, func.bounds.lb, func.bounds.ub)\n\n                # Selection\n                success = self.selection(func, crossed_vector, i)\n                self.success_count[strategy_index] += success\n\n            self.adapt_parameters(strategy_index)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 5, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["76cbb891-f2f7-48b1-acb4-6546b9e07479"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "5cd98e1c-e54d-4f27-8cdc-619e99923e9f", "fitness": 0.6362165113509181, "name": "SelfAdaptiveRankDE", "description": "A Differential Evolution strategy with self-adaptive parameters F and CR controlled by a sigmoid function based on recent improvement, and using a modified mutation strategy with ranking.", "code": "import numpy as np\n\nclass SelfAdaptiveRankDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2):\n        \"\"\"\n        Self-Adaptive Differential Evolution with Ranking-based Mutation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio  # Ratio of top individuals to consider for ranking\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n        \n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n            \n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices)\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n            \n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 6, "feedback": "The algorithm SelfAdaptiveRankDE scored 0.636 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["76cbb891-f2f7-48b1-acb4-6546b9e07479"], "operator": null, "metadata": {"aucs": [0.2445189720298664, 0.3394754595434164, 0.6494207884073921, 0.8544519709394546, 0.7192663138118067, 0.7326107992688654, 0.6087008057349484, 0.5969048195709878, 0.6794264460153122, 0.6478932081208983, 0.8337229226266505, 1.0, 0.29293112378822317, 0.6887759165220154, 0.9043647879130183, 0.7296012091098417, 0.6191738683376402, 0.8054366792709726, 0.2548168001840223, 0.5228373358230312]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "8b871f39-997c-4eb4-a25f-15bb628d7271", "fitness": 0.5182406779361711, "name": "SuccessHistoryAdaptiveRankDE", "description": "A Differential Evolution strategy with self-adaptive parameters F and CR controlled by a success-history-based adaptation, a ranking-based mutation, and a tournament selection for improved exploitation.", "code": "import numpy as np\n\nclass SuccessHistoryAdaptiveRankDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, memory_size=10, rank_ratio=0.2, tournament_size=3):\n        \"\"\"\n        Success-History based Adaptive Differential Evolution with Ranking-based Mutation and Tournament Selection.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            memory_size (int): Size of the memory for storing successful F and CR values.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            tournament_size (int): Size of the tournament for selection.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.memory_size = memory_size\n        self.rank_ratio = rank_ratio\n        self.tournament_size = tournament_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Memory for successful F and CR values\n        self.F_memory = np.full(self.memory_size, 0.5)\n        self.CR_memory = np.full(self.memory_size, 0.9)\n        self.memory_index = 0\n\n        self.success_count = 0 # Number of successful offspring in the last generation\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n    def mutate(self, pop):\n        \"\"\"Performs the mutation operation using ranking.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n        \n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n            \n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals\n            r1_idx = np.random.choice(top_indices)\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n            \n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n            \n            # Sample F from memory\n            F = np.random.choice(self.F_memory)\n\n            mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop):\n        \"\"\"Performs the crossover operation.\"\"\"\n        CR = np.random.choice(self.CR_memory)\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def tournament_selection(self, func, crossed_pop):\n        \"\"\"Performs tournament selection.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n        \n        successful_offspring = []\n\n        for i in range(self.pop_size):\n            # Tournament selection\n            tournament_indices = np.random.choice(self.pop_size, self.tournament_size, replace=False)\n            tournament_fitness = new_fitness[tournament_indices]\n            winner_index = tournament_indices[np.argmin(tournament_fitness)]\n\n            if new_fitness[winner_index] < self.fitness[i]:\n                self.pop[i] = crossed_pop[winner_index]\n                self.fitness[i] = new_fitness[winner_index]\n                successful_offspring.append(True)\n            else:\n                successful_offspring.append(False)\n                \n        self.success_count = np.sum(successful_offspring)\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def update_memory(self):\n        \"\"\"Updates the F and CR memory based on success.\"\"\"\n        if self.success_count > 0:\n            # Update memory with current F and CR, weighted by success\n            success_ratio = self.success_count / self.pop_size #success ratio\n            \n            # Update F and CR memory based on success\n            self.F_memory[self.memory_index] = 0.5 # Reset the F memory for exploration purposes\n            self.CR_memory[self.memory_index] = np.random.uniform(0, 1) # Reset CR memory for more diversity\n\n            self.memory_index = (self.memory_index + 1) % self.memory_size\n            self.success_count = 0\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            mutated_pop = self.mutate(self.pop)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            self.tournament_selection(func, crossed_pop)\n            \n            self.update_memory()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 7, "feedback": "The algorithm SuccessHistoryAdaptiveRankDE scored 0.518 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5cd98e1c-e54d-4f27-8cdc-619e99923e9f"], "operator": null, "metadata": {"aucs": [0.13831586452662048, 0.25470146745661415, 0.5358352882080142, 0.5085631400880006, 0.43797239955193623, 0.7049657159332754, 0.3353629889760289, 0.5982070811492373, 0.6422036222235046, 0.2133953653039048, 0.9463533539962754, 0.9929351888872089, 0.2836370281260352, 0.4734603339684009, 0.7067752226191875, 0.3338721645569248, 0.6152131667132266, 0.9430385810375289, 0.17945019678325203, 0.5205553886182459]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "3e152cf4-6441-4c7a-ab51-c85e13d2942a", "fitness": "-inf", "name": "FuzzyAdaptiveRankDE", "description": "A Differential Evolution strategy with self-adaptive parameters F and CR controlled by a fuzzy logic controller, and using a modified mutation strategy with ranking and stochastic universal sampling for parent selection.", "code": "import numpy as np\nimport skfuzzy as fuzz\nfrom skfuzzy import control as ctrl\n\nclass FuzzyAdaptiveRankDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, rank_ratio=0.2):\n        \"\"\"\n        Self-Adaptive Differential Evolution with Ranking-based Mutation and Fuzzy Logic Parameter Adaptation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n\n        # Fuzzy Logic Controller Setup\n        self.setup_fuzzy_controller()\n\n        self.F = 0.5  # Initial value for F\n        self.CR = 0.9  # Initial value for CR\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def setup_fuzzy_controller(self):\n        \"\"\"Sets up the fuzzy logic controller for adapting F and CR.\"\"\"\n        # Define fuzzy variables and membership functions\n        success_rate = ctrl.Antecedent(np.linspace(0, 1, 100), 'success_rate')\n        generation = ctrl.Antecedent(np.linspace(0, 1, 100), 'generation') # Normalized generation number\n        F_change = ctrl.Consequent(np.linspace(-0.5, 0.5, 100), 'F_change')\n        CR_change = ctrl.Consequent(np.linspace(-0.5, 0.5, 100), 'CR_change')\n\n        # Membership functions for success rate (example)\n        success_rate['low'] = fuzz.trimf(success_rate.universe, [0, 0, 0.5])\n        success_rate['medium'] = fuzz.trimf(success_rate.universe, [0, 0.5, 1])\n        success_rate['high'] = fuzz.trimf(success_rate.universe, [0.5, 1, 1])\n\n        # Membership functions for generation (example) - added generation as input\n        generation['early'] = fuzz.trimf(generation.universe, [0, 0, 0.5])\n        generation['late'] = fuzz.trimf(generation.universe, [0.5, 1, 1])\n        \n        # Membership functions for F and CR change (example)\n        F_change['decrease'] = fuzz.trimf(F_change.universe, [-0.5, -0.5, 0])\n        F_change['stable'] = fuzz.trimf(F_change.universe, [-0.1, 0, 0.1])\n        F_change['increase'] = fuzz.trimf(F_change.universe, [0, 0.5, 0.5])\n\n        CR_change['decrease'] = fuzz.trimf(CR_change.universe, [-0.5, -0.5, 0])\n        CR_change['stable'] = fuzz.trimf(CR_change.universe, [-0.1, 0, 0.1])\n        CR_change['increase'] = fuzz.trimf(CR_change.universe, [0, 0.5, 0.5])\n        \n        # Define fuzzy rules (example)\n        rule1 = ctrl.Rule(success_rate['low'] & generation['early'], (F_change['increase'], CR_change['increase']))\n        rule2 = ctrl.Rule(success_rate['high'] & generation['late'], (F_change['decrease'], CR_change['decrease']))\n        rule3 = ctrl.Rule(success_rate['medium'], (F_change['stable'], CR_change['stable'])) #If success is medium and generation does not matter\n\n        # Create the control system\n        self.fuzzy_ctrl = ctrl.ControlSystem([rule1, rule2, rule3])\n        self.fuzzy_sim = ctrl.ControlSystemSimulation(self.fuzzy_ctrl)\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n    def mutate(self, pop):\n        \"\"\"Performs the mutation operation using ranking and stochastic universal sampling.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n        \n        # Ranking-based selection\n        ranked_indices = np.argsort(self.fitness)\n        top_indices = ranked_indices[:num_ranked]\n\n        # Create selection probabilities using fitness ranking\n        fitness_ranks = np.argsort(np.argsort(self.fitness))\n        selection_probs = fitness_ranks / np.sum(fitness_ranks)\n\n        for i in range(self.pop_size):\n            # Choose parents using stochastic universal sampling (SUS)\n            indices = list(range(self.pop_size))\n            r1_idx = self.stochastic_universal_sampling(selection_probs,1)[0]\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n            mutated_pop[i] = x_r1 + self.F * (x_r2 - x_r3)\n        return mutated_pop\n\n    def stochastic_universal_sampling(self, probs, num_samples):\n        \"\"\"Performs stochastic universal sampling.\"\"\"\n        cumulative_probs = np.cumsum(probs)\n        pointer_spacing = 1.0 / num_samples\n        first_pointer = np.random.uniform(0, pointer_spacing)\n        pointers = [first_pointer + i * pointer_spacing for i in range(num_samples)]\n        sampled_indices = []\n        j = 0\n        for pointer in pointers:\n            while pointer > cumulative_probs[j]:\n                j += 1\n            sampled_indices.append(j)\n        return sampled_indices\n\n    def crossover(self, pop, mutated_pop):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < self.CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self, generation_num, total_generations):\n        \"\"\"Adapts F and CR using the fuzzy logic controller.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])\n            normalized_generation = generation_num / total_generations\n\n            # Pass inputs to the Fuzzy Logic Controller\n            self.fuzzy_sim.input['success_rate'] = success_rate\n            self.fuzzy_sim.input['generation'] = normalized_generation\n\n            # Compute the result\n            self.fuzzy_sim.compute()\n\n            # Get the changes for F and CR\n            F_change = self.fuzzy_sim.output['F_change']\n            CR_change = self.fuzzy_sim.output['CR_change']\n\n            # Apply the changes to F and CR\n            self.F += F_change\n            self.CR += CR_change\n\n            # Clip the values to ensure they are within bounds\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        total_generations = self.budget // self.pop_size\n        generation_num = 0\n\n        while self.evals < self.budget:\n            generation_num += 1\n\n            mutated_pop = self.mutate(self.pop)\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)  # Boundary Handling\n            crossed_pop = self.crossover(self.pop, mutated_pop)\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)  # Boundary Handling\n\n            old_fitness = self.fitness.copy()\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters(generation_num, total_generations)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 8, "feedback": "In the code, line 2, in <module>, the following error occurred:\nModuleNotFoundError: No module named 'skfuzzy'\nOn line: import skfuzzy as fuzz", "error": "In the code, line 2, in <module>, the following error occurred:\nModuleNotFoundError: No module named 'skfuzzy'\nOn line: import skfuzzy as fuzz", "parent_ids": ["5cd98e1c-e54d-4f27-8cdc-619e99923e9f"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "5defeb4c-b380-4295-a314-429ddc70a304", "fitness": 0.6585609029707725, "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with a novel mutation strategy incorporating information from both top-ranked and randomly selected individuals, along with an aging mechanism to promote exploration.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with a novel mutation strategy and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 9, "feedback": "The algorithm NovelSelfAdaptiveDE scored 0.659 on AOCC (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5cd98e1c-e54d-4f27-8cdc-619e99923e9f"], "operator": null, "metadata": {"aucs": [0.2553671910435318, 0.5848515852968648, 0.6783819776236826, 0.8356628526338267, 0.6891315700238864, 0.7288566874928084, 0.6110462915326347, 0.6091710329410993, 0.6797744336700381, 0.6778284740771117, 0.8376201868612299, 0.9966067638797419, 0.27015723553725435, 0.6752478844090211, 0.8762159613440003, 0.7482742333749505, 0.5696090210530754, 0.8063981249052119, 0.5165969514252851, 0.524419600290196]}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "441b0bf1-b3cb-4e81-b708-08b09f9fd9b2", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with a novel mutation strategy incorporating information from both top-ranked and randomly selected individuals, along with an aging mechanism to promote exploration, and a more robust adaptive parameter control using a windowed approach.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, adapt_window=10):\n        \"\"\"\n        Self-Adaptive Differential Evolution with a novel mutation strategy and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            adapt_window (int): Window size for adaptive parameter control.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.adapt_window = adapt_window\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.F_values = np.full(self.pop_size, F)\n        self.CR_values = np.full(self.pop_size, CR)\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            F = self.F_values[i]  # Individual F\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals\n            r1_idx = np.random.choice(top_indices)\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx)\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            CR = self.CR_values[i]  # Individual CR\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n        success = np.zeros(self.pop_size, dtype=bool)\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                success[i] = True\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n        return success\n\n    def adapt_parameters(self, success):\n        \"\"\"Adapts F and CR for each individual based on recent success.\"\"\"\n        for i in range(self.pop_size):\n            if self.success_history:\n                windowed_success = [s[i] for s in self.success_history[-self.adapt_window:]]\n                success_rate = np.mean(windowed_success) if windowed_success else 0\n\n                # Adjust F and CR based on success rate\n                if success[i]:\n                    # If successful, slightly decrease F and increase CR\n                    self.F_values[i] *= np.random.uniform(0.9, 1.0)\n                    self.CR_values[i] *= np.random.uniform(1.0, 1.1)\n                else:\n                    # If unsuccessful, slightly increase F and decrease CR\n                    self.F_values[i] *= np.random.uniform(1.0, 1.1)\n                    self.CR_values[i] *= np.random.uniform(0.9, 1.0)\n                # Keep F and CR within bounds\n                self.F_values[i] = np.clip(self.F_values[i], 0.1, 1.0)\n                self.CR_values[i] = np.clip(self.CR_values[i], 0.1, 1.0)\n        self.F_history.append(success)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            mutated_pop = self.mutate(self.pop)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            success = self.selection(func, crossed_pop)\n            self.adapt_parameters(success)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 10, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "33f18bd2-aa15-4635-9c3e-ddab3afd18e8", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a diversity maintenance mechanism to improve exploration and convergence.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components = 5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and diversity maintenance.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components to use in orthogonal design.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n            \n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to refine solutions.\"\"\"\n        # Select the best individual\n        best_index = np.argmin(self.fitness)\n        best_individual = self.pop[best_index].copy()\n\n        # Select components for orthogonal design\n        selected_components = np.random.choice(self.dim, self.orthogonal_components, replace=False)\n\n        # Generate orthogonal array (example using a simple full factorial design)\n        levels = 2  # Two levels for each component\n        orthogonal_array = np.array(np.meshgrid(*([[-1, 1]] * self.orthogonal_components))).T.reshape(-1, self.orthogonal_components)\n\n        # Evaluate solutions based on orthogonal array\n        for row in orthogonal_array:\n            new_solution = best_individual.copy()\n            for i, component_index in enumerate(selected_components):\n                # Adjust component value based on the level in the orthogonal array\n                step_size = 0.05 * (func.bounds.ub - func.bounds.lb)  # Reduced step size\n                new_solution[component_index] = best_individual[component_index] + row[i] * step_size\n                new_solution[component_index] = np.clip(new_solution[component_index], func.bounds.lb, func.bounds.ub)\n\n            new_fitness = func(new_solution)\n            self.evals += 1\n\n            # Update the best solution if a better one is found\n            if new_fitness < self.f_opt:\n                self.f_opt = new_fitness\n                self.x_opt = new_solution\n            \n    def diversity_maintenance(self, func):\n        \"\"\"Maintains diversity by re-initializing poorly performing individuals.\"\"\"\n        fitness_threshold = np.percentile(self.fitness, 75)  # Threshold at the 75th percentile\n\n        for i in range(self.pop_size):\n            if self.fitness[i] > fitness_threshold:\n                # Re-initialize individual\n                self.pop[i] = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n                self.fitness[i] = func(self.pop[i])\n                self.evals += 1\n                self.age[i] = 0\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            \n            # Apply orthogonal learning every few generations\n            if self.evals % (2 * self.pop_size) == 0:\n                self.orthogonal_learning(func)\n                \n            # Apply diversity maintenance every few generations\n            if self.evals % (5 * self.pop_size) == 0:\n                self.diversity_maintenance(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 11, "feedback": "In the code, line 1025, in numpy.random.mtrand.RandomState.choice, the following error occurred:\nValueError: Cannot take a larger sample than population when 'replace=False'", "error": "In the code, line 1025, in numpy.random.mtrand.RandomState.choice, the following error occurred:\nValueError: Cannot take a larger sample than population when 'replace=False'", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "bd8b9462-fdd8-43f8-8115-f32aa4b1be8f", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism to escape local optima.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, restart_trigger=0.05):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning and restart.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            restart_trigger (float): Threshold for fitness stagnation triggering restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.restart_trigger = restart_trigger\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.stagnation_counter = 0\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        improved = False #check if the population has improved\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                improved = True\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n        return improved\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"\n        Performs orthogonal learning to generate a new individual.\n        \"\"\"\n        best_index = np.argmin(self.fitness)\n        x_best = self.pop[best_index]\n        \n        # Generate orthogonal array (OA)\n        oa = self.generate_orthogonal_array(self.dim)\n        \n        # Generate new individuals based on the OA\n        new_individual = np.copy(x_best) # start from the best individual\n        for i in range(self.dim):\n            level = oa[0, i]  # Use the first row of OA as an example\n\n            #perturbation\n            perturbation = np.random.uniform(-0.1, 0.1) \n            new_individual[i] = x_best[i] + perturbation\n\n        # Evaluate the new individual\n        new_fitness = func(new_individual)\n        self.evals += 1\n\n        # If the new individual is better, replace the worst individual in the population\n        worst_index = np.argmax(self.fitness)\n        if new_fitness < self.fitness[worst_index]:\n            self.pop[worst_index] = new_individual\n            self.fitness[worst_index] = new_fitness\n            if new_fitness < self.f_opt:\n                self.f_opt = new_fitness\n                self.x_opt = new_individual\n            self.age[worst_index] = 0\n\n    def generate_orthogonal_array(self, dim):\n        \"\"\"\n        Generates a simple orthogonal array (OA) for orthogonal learning.\n        For simplicity, we use a fixed OA. In practice, more robust OAs can be used.\n        \"\"\"\n        # This is a minimal example, consider using a proper OA library or a more complete OA.\n        oa = np.random.randint(0, 2, size=(1, dim))  # Minimal OA with 2 levels\n        return oa\n            \n    def restart_population(self, func):\n        \"\"\"Restarts the population if stagnation is detected.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.stagnation_counter = 0\n        self.success_history = []\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n        initial_fopt = self.f_opt #Store the initial f_opt for stagnation check\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            improved = self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            \n            # Orthogonal Learning\n            self.orthogonal_learning(func)\n            \n            #Stagnation Check\n            relative_improvement = abs(self.f_opt - initial_fopt) / (abs(initial_fopt) + 1e-9) #Avoid division by zero\n\n            if relative_improvement < self.restart_trigger and improved == False:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                initial_fopt = self.f_opt #reset the initial fopt if improved\n                \n            if self.stagnation_counter > 20: # If stagnant for too long, restart\n                self.restart_population(func)\n                initial_fopt = self.f_opt #reset the initial fopt\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 12, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "5e3926ff-555f-43cf-9166-62144d207d97", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning, archive, and improved parameter adaptation.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, archive_size=10):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning, archive, and improved parameter adaptation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            archive_size (int): Size of the archive for storing diverse solutions.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.archive = []  # Archive for storing diverse solutions\n        self.archive_size = archive_size\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking, aging, and archive.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices)  # top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx)  # ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n            # Archive interaction: Introduce diversity by occasionally pulling vectors from the archive\n            if len(self.archive) > 0 and np.random.rand() < 0.1:\n                arch_idx = np.random.randint(len(self.archive))\n                x_arch = self.archive[arch_idx]\n                mutated_pop[i] = 0.5 * mutated_pop[i] + 0.5 * x_arch  # Blend with archive vector\n\n        return mutated_pop\n\n    def orthogonal_learning(self, pop, func):\n        \"\"\"Performs orthogonal learning to improve promising solutions.\"\"\"\n        num_samples = 5  # Number of samples for orthogonal design\n        orthogonal_matrix = self.generate_orthogonal_array(num_samples)\n\n        for i in range(self.pop_size):\n            best_fitness = self.fitness[i]\n            best_solution = pop[i].copy()\n\n            for j in range(num_samples):\n                new_solution = pop[i].copy()\n                for k in range(self.dim):\n                    # Perturb each dimension based on orthogonal array\n                    perturbation = (orthogonal_matrix[j, k % orthogonal_matrix.shape[1]] - 0.5) * 0.1  # Small perturbation\n                    new_solution[k] += perturbation\n\n                # Clip to bounds and evaluate\n                new_solution = np.clip(new_solution, func.bounds.lb, func.bounds.ub)\n                new_fitness = func(new_solution)\n                self.evals += 1\n\n                if new_fitness < best_fitness:\n                    best_fitness = new_fitness\n                    best_solution = new_solution.copy()\n\n            # Replace the individual with the best found solution\n            if best_fitness < self.fitness[i]:\n                pop[i] = best_solution\n                self.fitness[i] = best_fitness\n\n    def generate_orthogonal_array(self, num_samples):\n        \"\"\"Generates a simple orthogonal array (Latin Hypercube)\"\"\"\n        return np.random.rand(num_samples, self.dim)\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n        # Update archive with diverse solutions\n        self.update_archive()\n\n    def update_archive(self):\n        \"\"\"Updates the archive with diverse individuals.\"\"\"\n        for i in range(self.pop_size):\n            if len(self.archive) < self.archive_size:\n                self.archive.append(self.pop[i].copy())\n            else:\n                # Replace a random element in the archive with a small probability\n                if np.random.rand() < 0.1:\n                    index_to_replace = np.random.randint(self.archive_size)\n                    self.archive[index_to_replace] = self.pop[i].copy()\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on a more responsive success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-5:])  # Consider last 5 generations\n\n            # Dynamic Adjustment of F and CR based on Success\n            if success_rate > 0.5:\n                # High success, reduce exploration\n                self.F *= 0.95\n                self.CR *= 1.05\n            else:\n                # Low success, increase exploration\n                self.F *= 1.05\n                self.CR *= 0.95\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            # Apply orthogonal learning to promising solutions\n            if self.evals < self.budget * 0.5:\n                self.orthogonal_learning(crossed_pop, func)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 13, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "5c19416d-4eee-4058-8b73-13344dedc0d2", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism to escape local optima.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, restart_patience=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and restart.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            restart_patience (int): Number of generations without improvement before restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.restart_patience = restart_patience\n        self.no_improvement_count = 0\n        self.last_improvement_gen = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        improved = False\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                improved = True\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n            self.no_improvement_count = 0  # Reset no improvement count\n            self.last_improvement_gen = self.evals\n        else:\n            self.no_improvement_count += self.pop_size\n\n        return improved  # Return if any improvement happened\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to generate new candidate solutions.\"\"\"\n        # Select two parents randomly\n        parent_indices = np.random.choice(self.pop_size, 2, replace=False)\n        parent1 = self.pop[parent_indices[0]]\n        parent2 = self.pop[parent_indices[1]]\n\n        # Generate a new candidate solution using orthogonal design\n        candidate = 0.5 * (parent1 + parent2)  # Midpoint\n        orthogonal_direction = np.random.uniform(-1, 1, size=self.dim)\n        candidate = candidate + 0.1 * orthogonal_direction\n\n        # Clip values to remain within bounds\n        candidate = np.clip(candidate, func.bounds.lb, func.bounds.ub)\n\n        fitness = func(candidate)\n        self.evals += 1\n\n        # Replace the worst individual if the candidate is better\n        worst_index = np.argmax(self.fitness)\n        if fitness < self.fitness[worst_index]:\n            self.pop[worst_index] = candidate\n            self.fitness[worst_index] = fitness\n\n            if fitness < self.f_opt:\n                self.f_opt = fitness\n                self.x_opt = candidate\n\n    def restart_population(self, func):\n        \"\"\"Restarts the population if no improvement for a while.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.no_improvement_count = 0\n        self.last_improvement_gen = self.evals\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            improved = self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n            # Orthogonal learning every few generations\n            if self.evals % (2 * self.pop_size) == 0:\n                self.orthogonal_learning(func)\n\n            # Restart mechanism\n            if (self.evals - self.last_improvement_gen) > self.restart_patience * self.pop_size:\n                self.restart_population(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 14, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "c4523705-3c32-4e3d-bb5f-25fce10d355d", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, restart_trigger=0.1):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and restart mechanism.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            restart_trigger (float): Threshold for triggering population restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.restart_trigger = restart_trigger\n        self.no_improvement_count = 0\n        self.last_improvement = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning based on the current population.\"\"\"\n        for i in range(self.pop_size):\n            # Select two random individuals from the population\n            idx1, idx2 = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.pop[idx1], self.pop[idx2]\n\n            # Create an orthogonal array (OA)\n            oa = self.generate_orthogonal_array(2, self.dim)  # OA(4, dim, 2, 2)\n\n            # Generate new candidate solutions based on the OA\n            candidates = np.zeros((4, self.dim))\n            for j in range(4):\n                for k in range(self.dim):\n                    if oa[j, k] == 0:\n                        candidates[j, k] = x1[k]\n                    else:\n                        candidates[j, k] = x2[k]\n\n            # Evaluate the candidate solutions\n            candidate_fitness = np.array([func(x) for x in candidates])\n            self.evals += 4\n\n            # Select the best candidate and update the current individual\n            best_candidate_idx = np.argmin(candidate_fitness)\n            if candidate_fitness[best_candidate_idx] < self.fitness[i]:\n                self.pop[i] = candidates[best_candidate_idx]\n                self.fitness[i] = candidate_fitness[best_candidate_idx]\n                self.age[i] = 0  # Reset age if improved\n\n                if self.fitness[i] < self.f_opt:\n                  self.f_opt = self.fitness[i]\n                  self.x_opt = self.pop[i]\n\n\n    def generate_orthogonal_array(self, strength, factors):\n        \"\"\"Generates an orthogonal array of strength 2.\"\"\"\n        # For simplicity, using a predefined OA(4, dim, 2, 2) structure.\n        oa = np.array([[0, 0, 0, 0],\n                       [0, 0, 1, 1],\n                       [1, 1, 0, 1],\n                       [1, 1, 1, 0]])\n\n        # Repeat and transpose to match the desired number of factors\n        oa = np.tile(oa[:, :2], (1, (factors + 1) // 2))[:, :factors]\n\n        return oa\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n            self.no_improvement_count = 0 # Reset no_improvement_count when the best fitness is improved\n            self.last_improvement = self.evals\n        else:\n            self.no_improvement_count += self.pop_size\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def restart_population(self, func):\n        \"\"\"Restarts the population randomly.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.no_improvement_count = 0\n        self.last_improvement = self.evals\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Perform orthogonal learning\n            self.orthogonal_learning(func)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n            # Restart mechanism\n            if self.no_improvement_count > self.restart_trigger * self.budget:\n                self.restart_population(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 15, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "affe1faa-eaee-4dd5-8377-d530ea2b18c4", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal design-based crossover and archive to enhance exploration and exploitation.", "code": "import numpy as np\nfrom scipy.stats import norm\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, archive_size=10, orthogonal_levels=3):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal crossover and archive.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            archive_size (int): Size of the archive.\n            orthogonal_levels (int): Number of levels for orthogonal design.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.archive = []\n        self.archive_fitness = []\n        self.archive_size = archive_size\n        self.orthogonal_levels = orthogonal_levels\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n            mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def orthogonal_crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs crossover using orthogonal design.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        orthogonal_matrix = self.generate_orthogonal_array(self.dim, self.orthogonal_levels)\n\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                level = orthogonal_matrix[j % orthogonal_matrix.shape[0], i % orthogonal_matrix.shape[1]]\n                if level == 0:\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]  # Use original pop value\n\n        return crossed_pop\n\n    def generate_orthogonal_array(self, n, k):\n        \"\"\"Generates an orthogonal array L_n(k^n)\"\"\"\n        if n == 0:\n            return np.empty((0, 0), dtype=int)\n\n        if n == 1:\n            return np.zeros((1, k), dtype=int)\n\n        if n == 2:\n            array = np.zeros((k, k), dtype=int)\n            for i in range(k):\n                array[i, :] = i\n            return array\n\n        if k == 2 and n <= 7:\n           if n == 3: return np.array([[0,0,0,0],[0,1,1,1],[1,0,1,1],[1,1,0,1]])[:,:n]\n           if n == 4: return np.array([[0,0,0,0,0,0,0,0],[0,0,1,1,1,1,0,0],[0,1,0,1,1,0,1,0],[0,1,1,0,0,1,1,0]])[:,:n]\n           if n == 5: return np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]])[:,:n]\n           if n == 6: return np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1]])[:,:n]\n\n\n        orthogonal_matrix = np.random.randint(0, k, size=(n, n))\n        return orthogonal_matrix\n\n\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation with archive.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                # Replacement in main population\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n\n                # Update archive if better than worst archive member\n                if len(self.archive) < self.archive_size:\n                    self.archive.append(crossed_pop[i])\n                    self.archive_fitness.append(new_fitness[i])\n                else:\n                    worst_archive_index = np.argmax(self.archive_fitness)\n                    if new_fitness[i] < self.archive_fitness[worst_archive_index]:\n                        self.archive[worst_archive_index] = crossed_pop[i]\n                        self.archive_fitness[worst_archive_index] = new_fitness[i]\n\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])\n\n            # Sigmoid function for parameter adaptation\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2)))\n\n            self.F = 0.1 + 0.9 * sigmoid_output\n            self.CR = 0.1 + 0.9 * sigmoid_output\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n            crossed_pop = self.orthogonal_crossover(self.pop, mutated_pop, CR)\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()\n            self.selection(func, crossed_pop)\n\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 16, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "6985987e-4cd6-4552-a162-ae7d5e56ca17", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal design-based crossover and a niching mechanism to maintain diversity.", "code": "import numpy as np\nfrom scipy.stats import ortho_group\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, niche_radius=0.5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal crossover and niching.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            niche_radius (float): Radius of the niche for niching DE.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.niche_radius = niche_radius\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.archive = [] #archive for niching\n        self.archive_fitness = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def orthogonal_crossover(self, pop, mutated_pop):\n        \"\"\"Performs crossover based on orthogonal design.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            # Create an orthogonal matrix\n            orthogonal_matrix = ortho_group.rvs(self.dim)\n\n            # Combine parent and mutant using the orthogonal matrix\n            for j in range(self.dim):\n                crossed_pop[i, j] = 0\n                for k in range(self.dim):\n                    crossed_pop[i, j] += orthogonal_matrix[j, k] * (mutated_pop[i,k] if k < self.dim/2 else pop[i,k])\n\n        return crossed_pop\n    \n    def niching(self, individual):\n        \"\"\"Applies niching to maintain diversity.\"\"\"\n        \n        # Check distance to existing archive members\n        if self.archive:\n            distances = np.linalg.norm(np.array(self.archive) - individual, axis=1)\n            if np.any(distances < self.niche_radius):\n                return False  # Too close to an existing niche\n        return True\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n\n                # Niching: add to archive if good and not too close to existing members\n                if self.niching(self.pop[i]):\n                    self.archive.append(self.pop[i])\n                    self.archive_fitness.append(self.fitness[i])\n                    \n                    # Limit archive size to prevent excessive memory usage\n                    if len(self.archive) > self.pop_size:\n                        worst_archived_idx = np.argmax(self.archive_fitness)\n                        del self.archive[worst_archived_idx]\n                        del self.archive_fitness[worst_archived_idx]\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.orthogonal_crossover(self.pop, mutated_pop)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 17, "feedback": "In the code, line 86, in orthogonal_crossover, the following error occurred:\nNameError: name 'ortho_group' is not defined\nOn line: orthogonal_matrix = ortho_group.rvs(self.dim)", "error": "In the code, line 86, in orthogonal_crossover, the following error occurred:\nNameError: name 'ortho_group' is not defined\nOn line: orthogonal_matrix = ortho_group.rvs(self.dim)", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "e627098c-d764-4d47-94f4-cf56bd85b93a", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning, aging, and a success-history based parameter adaptation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components=5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with a novel mutation strategy, aging, and orthogonal learning.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components used in orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def orthogonal_learning(self, func, pop):\n        \"\"\"Performs orthogonal learning on a subset of individuals.\"\"\"\n        num_individuals = min(self.orthogonal_components, self.pop_size)\n        indices = np.random.choice(self.pop_size, size=num_individuals, replace=False)\n\n        for i in indices:\n            original_position = pop[i].copy()\n            best_position = original_position.copy()\n            best_fitness = self.fitness[i]\n\n            # Generate orthogonal array (simplified)\n            levels = 3  # Each dimension can take 3 values: original, slightly higher, slightly lower\n            orthogonal_array = np.array([[-1, -1], [-1, 1], [1, -1], [1, 1], [0, 0]]) #2 dimensions, 5 levels. Adapt for higher dims.\n\n            for j in range(min(self.dim, orthogonal_array.shape[0])):  # iterate through dimension.\n                new_position = original_position.copy()\n                perturbation = 0.05 * (func.bounds.ub - func.bounds.lb) #0.05 is perturbation factor\n                if j < orthogonal_array.shape[0]:\n                    for k in range(self.dim):\n                        if k == j:\n                            new_position[k] = original_position[k] + perturbation * orthogonal_array[j][0]\n                        else:\n                            new_position[k] = original_position[k] + perturbation * orthogonal_array[j][1]\n\n                    new_position = np.clip(new_position, func.bounds.lb, func.bounds.ub)\n                    new_fitness = func(new_position)\n                    self.evals += 1\n\n                    if new_fitness < best_fitness:\n                        best_fitness = new_fitness\n                        best_position = new_position.copy()\n\n            if best_fitness < self.fitness[i]:\n                pop[i] = best_position\n                self.fitness[i] = best_fitness\n\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            #Orthogonal Learning\n            self.orthogonal_learning(func, crossed_pop)\n            \n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 18, "feedback": "In the code, line 109, in orthogonal_learning, the following error occurred:\nValueError: setting an array element with a sequence.\nOn line: new_position[k] = original_position[k] + perturbation * orthogonal_array[j][0]", "error": "In the code, line 109, in orthogonal_learning, the following error occurred:\nValueError: setting an array element with a sequence.\nOn line: new_position[k] = original_position[k] + perturbation * orthogonal_array[j][0]", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "97a7c28f-c019-4084-9d91-ee2ccc395619", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism based on stagnation detection.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, stagnation_threshold=1e-6, stagnation_generations=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and stagnation-based restart.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            stagnation_threshold (float): Threshold for detecting stagnation.\n            stagnation_generations (int): Number of generations to wait before restarting after stagnation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.stagnation_threshold = stagnation_threshold\n        self.stagnation_generations = stagnation_generations\n        self.last_improvement_gen = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.fitness_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.fitness_history.append(self.f_opt)\n        self.last_improvement_gen = 0\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        improved = False\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                improved = True\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n            self.last_improvement_gen = len(self.fitness_history)\n\n        return improved\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"\n        Performs orthogonal learning to improve population diversity.\n        \"\"\"\n        num_samples = min(self.pop_size, 10)  # Reduce computational overhead\n        sample_indices = np.random.choice(self.pop_size, size=num_samples, replace=False)\n        samples = self.pop[sample_indices]\n\n        for i in range(self.dim):\n            # Find the best and worst values for each dimension\n            best_val = np.min(samples[:, i])\n            worst_val = np.max(samples[:, i])\n\n            # Generate orthogonal array (simplified for speed)\n            levels = 2\n            orthogonal_array = np.array([[-1, 1], [1, -1]])  # Simple 2-level OA\n\n            for j in range(num_samples):  # Explore around the sampled individuals\n                level_index = np.random.randint(levels)\n                new_val = best_val + 0.5 * (worst_val - best_val) * (orthogonal_array[0, level_index] + 1) # scale -1,1 to 0,1\n\n                # Create a candidate solution\n                candidate = self.pop[sample_indices[j]].copy()\n                candidate[i] = new_val\n\n                # Clip to bounds\n                candidate = np.clip(candidate, func.bounds.lb, func.bounds.ub)\n\n                # Evaluate the candidate\n                fitness = func(candidate)\n                self.evals += 1\n\n                # Replace if better\n                if fitness < self.fitness[sample_indices[j]]:\n                    self.pop[sample_indices[j]] = candidate\n                    self.fitness[sample_indices[j]] = fitness\n                    if fitness < self.f_opt:\n                        self.f_opt = fitness\n                        self.x_opt = candidate\n                        self.last_improvement_gen = len(self.fitness_history)\n\n    def check_stagnation(self):\n        \"\"\"Checks if the optimization has stagnated and restarts the population if needed.\"\"\"\n        if len(self.fitness_history) > self.stagnation_generations:\n            # Calculate the improvement over the past n generations\n            recent_fitness = self.fitness_history[-self.stagnation_generations:]\n            improvement = np.max(recent_fitness) - np.min(recent_fitness)  #max fitness - min fitness\n\n            if improvement < self.stagnation_threshold:\n                return True\n        return False\n\n    def restart_population(self, func):\n        \"\"\"Restarts the population to escape local optima.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        print(\"Restarting population due to stagnation\")\n        self.last_improvement_gen = len(self.fitness_history)  #reset last improvement\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            improved = self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n            self.fitness_history.append(self.f_opt)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)\n\n            if self.check_stagnation() and (len(self.fitness_history) - self.last_improvement_gen) > self.stagnation_generations:\n                self.restart_population(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 19, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "12792805-0bf9-4fb4-9407-2914376e6198", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and covariance matrix adaptation for better exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components=5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning and CMA.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.covariance_matrix = None\n        self.learning_rate_covariance = 0.1\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.covariance_matrix = np.eye(self.dim)  # Initialize covariance matrix\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices)  # top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx)  # ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.multivariate_normal(np.zeros(self.dim), self.covariance_matrix) #use CMA\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add CMA-based perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2)))  # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to enhance exploration.\"\"\"\n        # Select the best individual\n        best_individual = self.x_opt\n\n        # Generate orthogonal array\n        orthogonal_array = self.generate_orthogonal_array(self.orthogonal_components, self.dim)\n\n        # Generate new candidate solutions based on orthogonal array\n        candidate_solutions = np.zeros((len(orthogonal_array), self.dim))\n        for i, row in enumerate(orthogonal_array):\n            candidate = best_individual.copy()\n            for j, level in enumerate(row):\n                # Adjust each dimension based on orthogonal level\n                range_j = func.bounds.ub[j] - func.bounds.lb[j]\n                candidate[j] = func.bounds.lb[j] + level / (self.orthogonal_components - 1) * range_j\n            candidate_solutions[i] = candidate\n\n        # Evaluate candidate solutions\n        candidate_fitness = np.array([func(x) for x in candidate_solutions])\n        self.evals += len(candidate_solutions)\n\n        # Select the best candidate and update the population\n        best_candidate_index = np.argmin(candidate_fitness)\n        if candidate_fitness[best_candidate_index] < self.f_opt:\n            self.f_opt = candidate_fitness[best_candidate_index]\n            self.x_opt = candidate_solutions[best_candidate_index]\n\n            # Replace a randomly chosen individual in the population\n            replace_index = np.random.randint(self.pop_size)\n            self.pop[replace_index] = self.x_opt\n            self.fitness[replace_index] = self.f_opt\n            self.age[replace_index] = 0\n\n    def generate_orthogonal_array(self, levels, factors):\n          \"\"\"Generates an orthogonal array (L_levels^factors).\n          This is a simplified version. For real applications, use a dedicated library or a pre-computed OA.\n          \"\"\"\n          array = np.zeros((levels**2, factors), dtype=int)  #simplified, L4 array, must ensure pop_size > levels**2\n          for i in range(levels**2):\n              for j in range(factors):\n                  array[i,j] = i % levels\n          return array\n\n    def update_covariance_matrix(self):\n        \"\"\"Updates the covariance matrix based on successful mutations (CMA-ES like).\"\"\"\n        if self.success_history and len(self.success_history) > 5:\n            # Calculate the mean change in successful individuals\n            num_ranked = int(self.rank_ratio * self.pop_size)\n            ranked_indices = np.argsort(self.fitness)\n            top_individuals = self.pop[ranked_indices[:num_ranked]]\n            mean_change = np.mean(top_individuals - self.pop[ranked_indices[:num_ranked]], axis=0)\n\n            # Update the covariance matrix\n            self.covariance_matrix = (1 - self.learning_rate_covariance) * self.covariance_matrix + \\\n                                     self.learning_rate_covariance * np.outer(mean_change, mean_change)\n\n            # Ensure the covariance matrix is positive semi-definite (add a small value to the diagonal)\n            self.covariance_matrix += 1e-6 * np.eye(self.dim)\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)\n            self.update_covariance_matrix()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 20, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "6787faf1-582d-413d-b76a-fc84a0f5c1d2", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal design-based crossover and archive-based mutation for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, archive_size=10):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal design-based crossover and archive-based mutation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            archive_size (int): Size of the archive to store diverse solutions.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.archive = None  # Archive for storing diverse solutions\n        self.archive_size = archive_size\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n        # Initialize Archive\n        self.archive = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.archive_size, self.dim))\n\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking, aging, and archive.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards archive or random direction\n            if self.age[i] > self.age_limit:\n                 if np.random.rand() < 0.5: #50% chance of archive mutation\n                    r_archive_idx = np.random.randint(self.archive_size)\n                    x_archive = self.archive[r_archive_idx]\n                    mutated_pop[i] = x_r1 + F * (x_archive - x_r3) #Archive-guided mutation\n                 else:\n                    random_direction = np.random.uniform(-1, 1, size=self.dim)\n                    mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n       \"\"\"Performs the crossover operation using orthogonal design.\"\"\"\n       crossed_pop = np.zeros_like(pop)\n       \n       # Orthogonal Design parameters (L9 array)\n       design = np.array([\n           [1, 1, 1, 1, 1, 1, 1, 1, 1],\n           [1, 2, 2, 2, 2, 2, 2, 2, 2],\n           [1, 3, 3, 3, 3, 3, 3, 3, 3],\n           [2, 1, 2, 3, 1, 2, 3, 1, 2],\n           [2, 2, 3, 1, 2, 3, 1, 2, 3],\n           [2, 3, 1, 2, 3, 1, 2, 3, 1],\n           [3, 1, 3, 2, 2, 1, 3, 2, 1],\n           [3, 2, 1, 3, 3, 2, 1, 1, 3],\n           [3, 3, 2, 1, 1, 3, 2, 3, 1]\n       ])\n       \n       num_factors = 9\n       factor_len = self.dim // num_factors # Number of dimensions each factor controls\n       \n       for i in range(self.pop_size):\n           for j in range(num_factors):\n               start_idx = j * factor_len\n               end_idx = (j + 1) * factor_len\n               \n               if design[i % 9, j] == 1:\n                   crossed_pop[i, start_idx:end_idx] = mutated_pop[i, start_idx:end_idx]\n               elif design[i % 9, j] == 2:\n                   crossed_pop[i, start_idx:end_idx] = pop[i, start_idx:end_idx]\n               else:\n                   crossed_pop[i, start_idx:end_idx] = self.archive[i % self.archive_size, start_idx:end_idx]\n\n           # Remaining dimensions (if dim is not a multiple of 9) use standard crossover\n           for j in range(num_factors * factor_len, self.dim):\n                if np.random.rand() < CR:\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n\n       return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation and archive update.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n        # Update Archive with diverse solutions\n        for i in range(self.pop_size):\n            if np.random.rand() < 0.1: #10% chance to replace archive member\n                rand_index = np.random.randint(self.archive_size)\n                self.archive[rand_index] = self.pop[i]\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 21, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "e2814e6f-ea11-4895-878d-0160f8d21351", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and aging for diversified exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, ortho_groups=5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            ortho_groups: Number of groups to split dimensions for orthogonal learning\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.ortho_groups = ortho_groups\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def orthogonal_learning(self, func, pop):\n        \"\"\"Performs orthogonal learning on the population.\"\"\"\n        group_size = self.dim // self.ortho_groups\n        for g in range(self.ortho_groups):\n            start = g * group_size\n            end = (g + 1) * group_size if g < self.ortho_groups - 1 else self.dim\n            group_dim = end - start\n\n            # Select 4 random individuals\n            indices = np.random.choice(self.pop_size, 4, replace=False)\n            sample = pop[indices, start:end]\n\n            # Generate an orthogonal array (OA).  Using L9 OA\n            oa = np.array([\n                [-1, -1, -1, -1, -1, -1, -1, -1],\n                [-1, -1, -1, 1, 1, 1, 1, 1],\n                [-1, 1, 1, -1, -1, 1, 1, -1],\n                [-1, 1, 1, 1, 1, -1, -1, 1],\n                [1, -1, 1, -1, 1, -1, 1, -1],\n                [1, -1, 1, 1, -1, 1, -1, 1],\n                [1, 1, -1, -1, 1, 1, -1, -1],\n                [1, 1, -1, 1, -1, -1, 1, 1]\n            ])\n\n            # Scale OA to the range of the selected dimensions\n            lb = func.bounds.lb * np.ones(group_dim)\n            ub = func.bounds.ub * np.ones(group_dim)\n\n            oa_scaled = np.zeros((oa.shape[0], group_dim))\n            for i in range(group_dim):\n                oa_scaled[:, i] = (oa[:, i%8] + 1) / 2 * (ub[i] - lb[i]) + lb[i]  # Scale between lb and ub\n\n\n            # Create candidate solutions based on the OA and the sample\n            candidates = np.zeros((oa.shape[0], group_dim))\n            for k in range(oa.shape[0]):\n                for j in range(group_dim):\n                    candidates[k, j] = sample[0,j] + oa_scaled[k,j]\n\n\n            # Evaluate the candidates\n            candidate_fitness = np.array([func(np.concatenate((pop[indices[0], :start], x, pop[indices[0], end:]))) for x in candidates])\n            self.evals += len(candidates)\n\n\n            # Select the best candidate and replace the worst individual in the sample\n            best_candidate_index = np.argmin(candidate_fitness)\n            worst_sample_index = np.argmax(self.fitness[indices])  #indices array contains indices of original pop\n\n            if candidate_fitness[best_candidate_index] < self.fitness[indices[worst_sample_index]]:\n                pop[indices[worst_sample_index], start:end] = candidates[best_candidate_index]\n                self.fitness[indices[worst_sample_index]] = candidate_fitness[best_candidate_index]\n\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            # Apply orthogonal learning\n            self.orthogonal_learning(func, crossed_pop)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 22, "feedback": "In the code, line 114, in orthogonal_learning, the following error occurred:\nValueError: operands could not be broadcast together with shapes (2,) (0,) \nOn line: lb = func.bounds.lb * np.ones(group_dim)", "error": "In the code, line 114, in orthogonal_learning, the following error occurred:\nValueError: operands could not be broadcast together with shapes (2,) (0,) \nOn line: lb = func.bounds.lb * np.ones(group_dim)", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "7f61082e-940b-43a9-9ba1-6d37e170f4e8", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_component=0.05):\n        \"\"\"\n        Self-Adaptive Differential Evolution with a novel mutation strategy, aging, and orthogonal learning.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_component (float): Magnitude of the orthogonal perturbation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_component = orthogonal_component\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking, aging, and orthogonal learning.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n            # Orthogonal Learning\n            orthogonal_direction = self.calculate_orthogonal_direction(pop[i], self.x_opt)\n            mutated_pop[i] += self.orthogonal_component * orthogonal_direction\n\n        return mutated_pop\n\n    def calculate_orthogonal_direction(self, x, x_opt):\n        \"\"\"Calculates a direction orthogonal to the vector from x to x_opt.\"\"\"\n        v = x_opt - x\n        # Generate a random vector\n        t = np.random.randn(self.dim)\n        # Project t onto v\n        t_proj_v = (np.dot(t, v) / np.dot(v, v)) * v if np.dot(v, v) > 0 else np.zeros(self.dim)\n\n        # Orthogonal component\n        t_orth = t - t_proj_v\n        return t_orth\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 23, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "c17abe6c-51de-4e1d-820e-e9fd9ed45d51", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism based on stagnation detection.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, stagnation_limit=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and stagnation restart.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            stagnation_limit (int): Number of iterations without improvement before restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.stagnation_counter = 0\n        self.stagnation_limit = stagnation_limit\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.best_fitness_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.best_fitness_history.append(self.f_opt)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n            self.stagnation_counter = 0 #reset stagnation counter\n        else:\n            self.stagnation_counter += 1\n\n        self.best_fitness_history.append(self.f_opt)\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning on the population.\"\"\"\n        num_samples = 5  # Number of orthogonal samples\n        for i in range(self.pop_size):\n            # Select two random dimensions\n            dims = np.random.choice(self.dim, 2, replace=False)\n            dim1, dim2 = dims[0], dims[1]\n\n            # Generate orthogonal array (example using L9 array - could be L4, L8, etc.)\n            orthogonal_array = np.array([\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1]\n            ])\n\n            best_fitness = self.fitness[i]\n            best_sample = self.pop[i].copy()\n\n            for j in range(orthogonal_array.shape[0]):\n                sample = self.pop[i].copy()\n                # Map -1/1 to the range of the selected dimensions\n                sample[dim1] = self.pop[i][dim1] + 0.1 * orthogonal_array[j, 0] * (func.bounds.ub - func.bounds.lb) #perturb the current dimension\n                sample[dim2] = self.pop[i][dim2] + 0.1 * orthogonal_array[j, 1] * (func.bounds.ub - func.bounds.lb) #perturb the current dimension\n                sample = np.clip(sample, func.bounds.lb, func.bounds.ub)\n                fitness = func(sample)\n                self.evals += 1\n\n                if fitness < best_fitness:\n                    best_fitness = fitness\n                    best_sample = sample\n\n                if fitness < self.f_opt:\n                    self.f_opt = fitness\n                    self.x_opt = sample\n\n            if best_fitness < self.fitness[i]:\n                self.pop[i] = best_sample\n                self.fitness[i] = best_fitness\n\n    def restart_population(self, func):\n        \"\"\"Restarts the population.\"\"\"\n        print(\"Restarting population...\")\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.stagnation_counter = 0\n        self.F = 0.5 # Reset F\n        self.CR = 0.9 # Reset CR\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.best_fitness_history.append(self.f_opt)\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n            # Apply orthogonal learning every few iterations\n            if self.evals % 500 < self.pop_size and self.evals + self.pop_size <= self.budget:\n                self.orthogonal_learning(func)\n            \n            if self.stagnation_counter > self.stagnation_limit and self.evals + self.pop_size <= self.budget:\n                self.restart_population(func)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 24, "feedback": "In the code, line 153, in orthogonal_learning, the following error occurred:\nValueError: setting an array element with a sequence.\nOn line: sample[dim1] = self.pop[i][dim1] + 0.1 * orthogonal_array[j, 0] * (func.bounds.ub - func.bounds.lb) #perturb the current dimension", "error": "In the code, line 153, in orthogonal_learning, the following error occurred:\nValueError: setting an array element with a sequence.\nOn line: sample[dim1] = self.pop[i][dim1] + 0.1 * orthogonal_array[j, 0] * (func.bounds.ub - func.bounds.lb) #perturb the current dimension", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "742f26f9-5155-4096-b9e4-7aa78c8494fb", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism to escape local optima.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, restart_trigger=100):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            restart_trigger (int): Number of iterations without improvement to trigger a restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.restart_trigger = restart_trigger\n        self.no_improvement_count = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        improved = False\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                improved = True\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n            self.no_improvement_count = 0 # Reset counter if improvement is found\n        else:\n            self.no_improvement_count += 1 # Increment if no improvement\n\n        return improved\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to generate new candidate solutions.\"\"\"\n        num_candidates = 5  # Number of candidate solutions to generate\n\n        # Select two random parents\n        parent1_idx, parent2_idx = np.random.choice(self.pop_size, 2, replace=False)\n        parent1, parent2 = self.pop[parent1_idx], self.pop[parent2_idx]\n\n        candidates = []\n        for _ in range(num_candidates):\n            # Generate a candidate solution by combining information from the parents\n            candidate = parent1 + np.random.rand(self.dim) * (parent2 - parent1)\n            candidate = np.clip(candidate, func.bounds.lb, func.bounds.ub)  # Boundary handling\n            candidates.append(candidate)\n\n        # Evaluate the candidate solutions\n        candidate_fitness = np.array([func(x) for x in candidates])\n        self.evals += num_candidates\n\n        # Select the best candidate\n        best_candidate_idx = np.argmin(candidate_fitness)\n        best_candidate = candidates[best_candidate_idx]\n        best_candidate_fitness = candidate_fitness[best_candidate_idx]\n\n\n        # Replace the worst individual in the population with the best candidate\n        worst_index = np.argmax(self.fitness)\n        if best_candidate_fitness < self.fitness[worst_index]:\n            self.pop[worst_index] = best_candidate\n            self.fitness[worst_index] = best_candidate_fitness\n            if best_candidate_fitness < self.f_opt:\n                self.f_opt = best_candidate_fitness\n                self.x_opt = best_candidate\n\n    def restart_population(self, func):\n        \"\"\"Restarts the population if no improvement is observed for a certain number of iterations.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.no_improvement_count = 0\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            improved = self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n            # Apply orthogonal learning every few iterations\n            if self.evals % 500 < self.pop_size:\n                self.orthogonal_learning(func)\n\n            # Restart if no improvement\n            if self.no_improvement_count > self.restart_trigger:\n                 self.restart_population(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 25, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "dae01075-c626-4c82-b17c-caaf5f2aff48", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning, periodic population rejuvenation and adaptive mutation factor decay.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, ortho_trials=5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning,\n        periodic population rejuvenation and adaptive mutation factor decay.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            ortho_trials (int): Number of trials for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.ortho_trials = ortho_trials\n        self.generation = 0\n        self.rejuvenation_interval = 50  # Rejuvenate every N generations\n        self.F_decay = 0.995 # Decay factor for mutation scaling factor\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to improve the population.\"\"\"\n        for _ in range(self.ortho_trials):\n            # Select two random individuals\n            idx1, idx2 = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.pop[idx1], self.pop[idx2]\n\n            # Generate a new solution by combining x1 and x2\n            alpha = np.random.rand(self.dim)\n            x_new = alpha * x1 + (1 - alpha) * x2\n\n            # Clip values to remain within bounds\n            x_new = np.clip(x_new, func.bounds.lb, func.bounds.ub)\n\n            # Evaluate the new solution\n            f_new = func(x_new)\n            self.evals += 1\n\n            # Replace the worse of x1 and x2 with x_new if it's better\n            if f_new < max(self.fitness[idx1], self.fitness[idx2]):\n                if self.fitness[idx1] > self.fitness[idx2]:\n                    self.pop[idx1] = x_new\n                    self.fitness[idx1] = f_new\n                    self.age[idx1] = 0\n                else:\n                    self.pop[idx2] = x_new\n                    self.fitness[idx2] = f_new\n                    self.age[idx2] = 0\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def periodic_rejuvenation(self, func):\n        \"\"\"Rejuvenates the population by replacing a portion with random individuals.\"\"\"\n        rejuvenation_ratio = 0.1  # Percentage of population to rejuvenate\n        num_to_rejuvenate = int(rejuvenation_ratio * self.pop_size)\n\n        # Find the worst individuals in the population\n        worst_indices = np.argsort(self.fitness)[-num_to_rejuvenate:]\n\n        # Replace them with new random individuals\n        new_individuals = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(num_to_rejuvenate, self.dim))\n        new_fitness = np.array([func(x) for x in new_individuals])\n        self.evals += num_to_rejuvenate\n\n        self.pop[worst_indices] = new_individuals\n        self.fitness[worst_indices] = new_fitness\n        self.age[worst_indices] = 0  # Reset age\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            self.generation += 1\n\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.F *= self.F_decay  # Decay the mutation factor\n\n            # Perform orthogonal learning\n            self.orthogonal_learning(func)\n\n            # Periodic Rejuvenation\n            if self.generation % self.rejuvenation_interval == 0:\n                self.periodic_rejuvenation(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 26, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "3d92cf4b-b9e4-4371-b3ff-7ccb95438a69", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal crossover and archive-based mutation to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, archive_size=10):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal crossover and archive-based mutation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            archive_size (int): Size of the archive to store diverse solutions.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.archive = []\n        self.archive_size = archive_size\n        self.archive_fitness = []\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking, aging and archive.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals\n            r1_idx = np.random.choice(top_indices)\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx)\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards the archive\n            if self.age[i] > self.age_limit and self.archive:\n                archive_idx = np.random.randint(len(self.archive))\n                x_archive = self.archive[archive_idx]\n                mutated_pop[i] = x_r1 + F * (x_archive - pop[i])  # Mutation towards archive\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def orthogonal_crossover(self, pop, mutated_pop):\n        \"\"\"Performs orthogonal crossover.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        orthogonal_matrix = np.random.randn(self.dim, self.dim)\n        q, r = np.linalg.qr(orthogonal_matrix)\n\n        for i in range(self.pop_size):\n            # Create a linear combination of parent and mutant using orthogonal matrix\n            crossed_pop[i] = 0.5 * (pop[i] + mutated_pop[i]) + 0.5 * np.dot(q, (mutated_pop[i] - pop[i])) #linear combination with q\n\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation and updates the archive.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                # Improved fitness, update population and reset age\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0\n            else:\n                # No improvement, increment age\n                self.age[i] += 1\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n        # Update archive\n        for i in range(self.pop_size):\n            if len(self.archive) < self.archive_size:\n                self.archive.append(self.pop[i])\n                self.archive_fitness.append(self.fitness[i])\n            else:\n                # Replace the worst element in the archive if the current element is better and not already in archive\n                max_archive_index = np.argmax(self.archive_fitness)\n                if self.fitness[i] < self.archive_fitness[max_archive_index] and not np.any(np.all(self.archive == self.pop[i], axis=1)):\n                    self.archive[max_archive_index] = self.pop[i]\n                    self.archive_fitness[max_archive_index] = self.fitness[i]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.orthogonal_crossover(self.pop, mutated_pop)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 27, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "67bf1d32-8891-429d-8ecf-a4a4aa164e36", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a Cauchy mutation operator for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_pairs=5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and Cauchy mutation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_pairs (int): Number of pairs for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_pairs = orthogonal_pairs\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking, aging, and Cauchy.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, use Cauchy mutation\n            if self.age[i] > self.age_limit:\n                cauchy_mutation = np.random.standard_cauchy(size=self.dim) * 0.1 #Cauchy distribution for wider jumps\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + cauchy_mutation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to improve population diversity.\"\"\"\n        for _ in range(self.orthogonal_pairs):\n            # Select two random individuals\n            i, j = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.pop[i], self.pop[j]\n\n            # Generate a new point orthogonal to the line connecting x1 and x2\n            direction = x2 - x1\n            orthogonal_direction = np.random.randn(self.dim)\n            orthogonal_direction -= orthogonal_direction.dot(direction) * direction / np.linalg.norm(direction)**2\n            orthogonal_direction /= np.linalg.norm(orthogonal_direction)\n\n            # Create a new candidate point\n            alpha = np.random.uniform(-1, 1)  # Random step size\n            new_x = x1 + alpha * orthogonal_direction\n\n            # Clip to bounds\n            new_x = np.clip(new_x, func.bounds.lb, func.bounds.ub)\n\n            new_fitness = func(new_x)\n            self.evals += 1\n\n            # Replace the worse of the two individuals if the new point is better\n            if new_fitness < max(self.fitness[i], self.fitness[j]):\n                if self.fitness[i] > self.fitness[j]:\n                    if new_fitness < self.fitness[i]:\n                        self.pop[i] = new_x\n                        self.fitness[i] = new_fitness\n                        self.age[i] = 0\n                else:\n                    if new_fitness < self.fitness[j]:\n                        self.pop[j] = new_x\n                        self.fitness[j] = new_fitness\n                        self.age[j] = 0\n\n                best_index = np.argmin(self.fitness)\n                if self.fitness[best_index] < self.f_opt:\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.pop[best_index]\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)  # Apply orthogonal learning\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 28, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "ff95d761-963a-4524-9d90-b0759c3be96f", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal design-based crossover and improved parameter adaptation using success history.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with a novel mutation strategy, aging, and orthogonal crossover.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.archive = []  # Archive for storing successful solutions\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices)  # top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx)  # ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def orthogonal_crossover(self, pop, mutated_pop):\n        \"\"\"Performs orthogonal design-based crossover.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        L = 4  # Orthogonal array size (L4 array)\n        factors = 2  # Number of factors\n\n        # Generate L4 orthogonal array (assuming dim is multiple of factors)\n        if self.dim % factors != 0:\n            return self.crossover(pop, mutated_pop, self.CR) #revert to binomial\n\n        num_experiments = self.dim // factors\n        for i in range(self.pop_size):\n            for j in range(num_experiments):\n                # L4 array: [[0, 0], [0, 1], [1, 0], [1, 1]]\n                oa = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])\n                indices = range(j*factors, (j+1)*factors)\n                for k in range(L):\n                    temp_vector = np.copy(pop[i])\n                    for l in range(factors):\n                        if oa[k, l] == 1:\n                            temp_vector[indices[l]] = mutated_pop[i, indices[l]]\n                    temp_fitness = self.evaluate(func, temp_vector)\n                    if temp_fitness < self.fitness[i]:\n                         crossed_pop[i] = temp_vector\n                         break #only improve once in orthogonal experiment\n                    else:\n                        crossed_pop[i] = pop[i] #no improvement then keep current pop\n        return crossed_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                self.archive.append(crossed_pop[i].copy())  # Store successful solutions\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on success history, considering the archive.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n            # Adjust based on archive size\n            if len(self.archive) > 0.5 * self.budget:\n                self.F *= 0.95  # Reduce F to encourage exploitation if archive is large\n                self.CR *= 1.05  # Increase CR to allow more variation\n                self.F = np.clip(self.F, 0.1, 1.0)\n                self.CR = np.clip(self.CR, 0.1, 1.0)\n\n    def evaluate(self, func, x):\n        \"\"\"Evaluates the given solution and increments the evaluation counter.\"\"\"\n        if self.evals < self.budget:\n            fitness = func(x)\n            self.evals += 1\n            return fitness\n        else:\n            return np.inf\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.orthogonal_crossover(self.pop, mutated_pop) #apply orthogonal design crossover\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 29, "feedback": "In the code, line 98, in orthogonal_crossover, the following error occurred:\nNameError: name 'func' is not defined\nOn line: temp_fitness = self.evaluate(func, temp_vector)", "error": "In the code, line 98, in orthogonal_crossover, the following error occurred:\nNameError: name 'func' is not defined\nOn line: temp_fitness = self.evaluate(func, temp_vector)", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "5fb9407f-f9c7-449f-955d-044e9747ff69", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal crossover, archive for stagnation avoidance, and adaptive population size.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, pop_resize_freq=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal crossover, archive for stagnation avoidance, and adaptive population size.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Initial population size.\n            archive_size (int): Size of the archive.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            pop_resize_freq (int): Frequency of population resizing.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.archive = []  # Archive for storing diverse solutions\n        self.archive_fitness = []\n        self.pop_resize_freq = pop_resize_freq\n        self.generation = 0  # Current generation number\n        self.min_pop_size = 10  # Minimum population size\n        self.max_pop_size = 100 # Maximum population size\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n\n            #Select r2 and r3 from either population or archive\n            if len(self.archive) > 0 and np.random.rand() < 0.2:  # 20% chance to use archive\n                r2_idx = np.random.randint(len(self.archive))\n                x_r2 = self.archive[r2_idx]\n            else:\n                r2_idx = np.random.choice(available_indices)\n                x_r2 = pop[r2_idx]\n                available_indices.remove(r2_idx) # ensure r3 is different\n\n            if len(self.archive) > 0 and np.random.rand() < 0.2:  # 20% chance to use archive\n                r3_idx = np.random.randint(len(self.archive))\n                x_r3 = self.archive[r3_idx]\n            else:\n                r3_idx = np.random.choice(available_indices)\n                x_r3 = pop[r3_idx]\n\n            x_r1 = pop[r1_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def orthogonal_crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs orthogonal crossover.\"\"\"\n        crossed_pop = np.copy(pop)\n        num_pairs = self.pop_size // 2\n        for i in range(num_pairs):\n            idx1 = 2 * i\n            idx2 = 2 * i + 1\n\n            # Create an orthogonal array (OA) - Simple 2-level OA\n            oa = np.array([[1, 1], [1, -1], [-1, 1], [-1, -1]])\n\n            # Sample a random OA row\n            oa_row_idx = np.random.randint(0, 4)\n            oa_row = oa[oa_row_idx]\n\n            # Create two new individuals based on the OA\n            new_ind1 = 0.5 * ((1 + oa_row[0]) * mutated_pop[idx1] + (1 - oa_row[0]) * mutated_pop[idx2])\n            new_ind2 = 0.5 * ((1 + oa_row[1]) * mutated_pop[idx1] + (1 - oa_row[1]) * mutated_pop[idx2])\n\n            crossed_pop[idx1] = new_ind1\n            crossed_pop[idx2] = new_ind2\n\n        # If odd population size, do standard crossover for the last individual\n        if self.pop_size % 2 != 0:\n            i = self.pop_size - 1\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n\n        return crossed_pop\n\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                # Add replaced individuals to the archive\n                if len(self.archive) < self.archive_size:\n                    self.archive.append(self.pop[i].copy())\n                else: #Replace a random element in the archive if it is full.\n                    replace_idx = np.random.randint(self.archive_size)\n                    self.archive[replace_idx] = self.pop[i].copy()\n\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n                # Add the mutated but unselected solution into archive to improve the diversity\n                if len(self.archive) < self.archive_size:\n                    self.archive.append(crossed_pop[i].copy())\n                else: #Replace a random element in the archive if it is full.\n                    replace_idx = np.random.randint(self.archive_size)\n                    self.archive[replace_idx] = crossed_pop[i].copy()\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n        # Keep archive size under control.\n        if len(self.archive) > self.archive_size:\n            self.archive = self.archive[:self.archive_size]\n\n    def adapt_parameters(self):\n         \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n         if self.success_history:\n             success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n             # Sigmoid function to map success rate to F/CR adjustments\n             sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n             # Use sigmoid output to adjust F and CR more smoothly and robustly\n             self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n             self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n             self.F = np.clip(self.F, 0.1, 1.0)\n             self.CR = np.clip(self.CR, 0.1, 1.0)\n\n    def adapt_population_size(self):\n        \"\"\"Adapts the population size based on stagnation.\"\"\"\n        if self.generation % self.pop_resize_freq == 0:\n            # Calculate the standard deviation of the fitness values\n            fitness_std = np.std(self.fitness)\n\n            # If the population has stagnated (low fitness diversity)\n            if fitness_std < 1e-6:  #Stagnation threshold\n                self.pop_size = max(self.min_pop_size, int(self.pop_size * 0.8))  # Reduce population size\n                print(f\"Reducing population size to {self.pop_size}\")\n            else:\n                self.pop_size = min(self.max_pop_size, int(self.pop_size * 1.2))  # Increase population size\n                print(f\"Increasing population size to {self.pop_size}\")\n\n            # Re-initialize the population with the new size\n            self.pop_size = int(self.pop_size)\n            \n            #Ensure the population size is within the bounds\n            self.pop_size = max(self.min_pop_size, min(self.pop_size, self.max_pop_size))\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.orthogonal_crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.generation += 1\n\n            if self.generation % self.pop_resize_freq == 0:\n                self.adapt_population_size()\n                # Reinitialize Population\n                old_pop = self.pop\n                old_fitness = self.fitness\n                self.initialize_population(func)\n\n                # Merge the old and new population, keeping the best\n                combined_pop = np.concatenate((old_pop, self.pop), axis=0)\n                combined_fitness = np.concatenate((old_fitness, self.fitness))\n                sorted_indices = np.argsort(combined_fitness)\n                best_indices = sorted_indices[:self.pop_size]\n                self.pop = combined_pop[best_indices]\n                self.fitness = combined_fitness[best_indices]\n                best_index = np.argmin(self.fitness)\n                self.f_opt = self.fitness[best_index]\n                self.x_opt = self.pop[best_index]\n                self.age = np.zeros(self.pop_size, dtype=int)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 30, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "da58281a-b9f2-4762-bc7b-2180e1ee6adc", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal design-based crossover and a combined mutation strategy (current-to-best and random) to enhance exploration and exploitation.", "code": "import numpy as np\nfrom scipy.stats import norm\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_design_size=5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal design-based crossover and a combined mutation strategy.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_design_size (int): Number of factors to consider in orthogonal design crossover.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_design_size = min(orthogonal_design_size, dim)  # Ensure it's not larger than dimension\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n        # Generate Orthogonal Design matrix (L9 or similar) - using a simple example\n        self.orthogonal_design = self.generate_orthogonal_design(self.orthogonal_design_size)\n\n\n    def generate_orthogonal_design(self, num_factors):\n        \"\"\"\n        Generates a simple orthogonal design matrix.  For larger designs, use dedicated libraries.\n        This example generates a simple L9 design (3 levels, up to 4 factors).  It can be adapted for different sizes.\n        \"\"\"\n        if num_factors <= 0:\n            return np.array([])\n        if num_factors > 4:\n            num_factors = 4\n\n        # A simplified L9 orthogonal array (3 levels, 4 factors)\n        design = np.array([\n            [0, 0, 0, 0],\n            [0, 1, 1, 1],\n            [0, 2, 2, 2],\n            [1, 0, 1, 2],\n            [1, 1, 2, 0],\n            [1, 2, 0, 1],\n            [2, 0, 2, 1],\n            [2, 1, 0, 2],\n            [2, 2, 1, 0]\n        ])\n\n        return design[:, :num_factors] # Return appropriate portion for the number of factors\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using a combined strategy: current-to-best and random.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        # Find best individual\n        best_index = np.argmin(self.fitness)\n        x_best = pop[best_index]\n\n        for i in range(self.pop_size):\n            # Current-to-best mutation\n            r1_idx = i\n            while r1_idx == i:\n                r1_idx = np.random.randint(self.pop_size)\n            r2_idx = np.random.randint(self.pop_size)\n            x_r1, x_r2 = pop[r1_idx], pop[r2_idx]\n\n            # Random mutation (for exploration)\n            random_individual = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)\n\n            # Combine current-to-best and random mutation\n            if np.random.rand() < 0.5:  # 50% chance of each mutation type\n                 mutated_pop[i] = pop[i] + F * (x_best - pop[i]) + F * (x_r1 - x_r2)\n            else:\n                mutated_pop[i] = pop[i] + F * (random_individual - pop[i])\n\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = pop[i] + 0.1 * random_direction  # Add random perturbation\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation using orthogonal design.\"\"\"\n        crossed_pop = np.copy(pop)\n        for i in range(self.pop_size):\n            # Select a row from the orthogonal design matrix\n            design_row_index = np.random.randint(self.orthogonal_design.shape[0])\n            design_row = self.orthogonal_design[design_row_index]\n\n            # Apply crossover based on the orthogonal design\n            for j in range(self.orthogonal_design_size):  # Iterate through the factors\n                dimension_index = j #simplified, assuming first dimensions are more important\n                if np.random.rand() < CR:\n                     crossed_pop[i, dimension_index] = mutated_pop[i, dimension_index]\n\n                # Example: Using orthogonal levels as probabilities\n                #if design_row[j] == 0:\n                #    if np.random.rand() < 0.2:\n                #        crossed_pop[i, j] = mutated_pop[i, j]\n                #elif design_row[j] == 1:\n                #    if np.random.rand() < 0.5:\n                #        crossed_pop[i, j] = mutated_pop[i, j]\n                #else:\n                #   crossed_pop[i,j] = mutated_pop[i,j]\n\n\n            #Standard Crossover for remaining dimensions\n            for j in range(self.orthogonal_design_size, self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                     crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                     crossed_pop[i, j] = pop[i, j]\n\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 31, "feedback": "In the code, line 96, in mutate, the following error occurred:\nNameError: name 'func' is not defined\nOn line: random_individual = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)", "error": "In the code, line 96, in mutate, the following error occurred:\nNameError: name 'func' is not defined\nOn line: random_individual = np.random.uniform(func.bounds.lb, func.bounds.ub, size=self.dim)", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "d7364000-e0fb-475b-89a6-ca2d3d9ebbc1", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and dynamic population size adjustment based on stagnation detection.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, stagnation_threshold=1e-6, stagnation_generations=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with Orthogonal Learning and Dynamic Population Size.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Initial population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            stagnation_threshold (float): Threshold for detecting stagnation.\n            stagnation_generations (int): Number of generations to wait before increasing population size if stagnated.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None\n        self.age_limit = age_limit\n        self.stagnation_threshold = stagnation_threshold\n        self.stagnation_generations = stagnation_generations\n        self.stagnation_counter = 0\n        self.best_fitness_history = []\n        self.pop_sizes = [] #stores pop size\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.best_fitness_history.append(self.f_opt)\n        self.pop_sizes.append(self.pop_size)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n            r1_idx = np.random.choice(top_indices)\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx)\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def orthogonal_learning(self, func, pop, num_samples=5):\n        \"\"\"Performs orthogonal learning to generate better solutions.\"\"\"\n        best_index = np.argmin(self.fitness)\n        best_individual = self.pop[best_index].copy()\n\n        for _ in range(num_samples):\n            orthogonal_vector = np.random.normal(0, 1, self.dim)\n            orthogonal_vector /= np.linalg.norm(orthogonal_vector)  # Normalize\n\n            # Generate a new candidate solution along the orthogonal direction\n            step_size = np.random.uniform(-0.1, 0.1)  # Adjust step size range as needed\n            candidate_solution = best_individual + step_size * orthogonal_vector\n\n            # Boundary Handling\n            candidate_solution = np.clip(candidate_solution, func.bounds.lb, func.bounds.ub)\n\n            candidate_fitness = func(candidate_solution)\n            self.evals += 1\n\n            if candidate_fitness < self.f_opt:\n                self.f_opt = candidate_fitness\n                self.x_opt = candidate_solution\n                best_individual = candidate_solution.copy()\n\n        return best_individual\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0\n            else:\n                self.age[i] += 1\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2)))\n\n            self.F = 0.1 + 0.9 * sigmoid_output\n            self.CR = 0.1 + 0.9 * sigmoid_output\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def adjust_population_size(self):\n        \"\"\"Dynamically adjusts population size based on stagnation detection.\"\"\"\n        if len(self.best_fitness_history) > self.stagnation_generations:\n            # Calculate the improvement over the last stagnation_generations\n            improvement = self.best_fitness_history[-self.stagnation_generations -1] - self.best_fitness_history[-1]\n\n            if improvement < self.stagnation_threshold:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n\n            if self.stagnation_counter >= self.stagnation_generations:\n                # Increase population size\n                self.pop_size = int(self.pop_size * 1.2)  # Increase by 20%\n                self.pop_size = min(self.pop_size, 200)  # Set a maximum population size\n                print(f\"Stagnation detected. Increasing population size to {self.pop_size}\")\n                self.stagnation_counter = 0  # Reset the counter\n                return True #return True if population size increased.\n\n        return False\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()\n            self.selection(func, crossed_pop)\n\n            # Orthogonal Learning\n            self.orthogonal_learning(func, self.pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n            # Stagnation Check and Population Size Adjustment\n            if self.adjust_population_size():\n                 # Reinitialize population if size increased.\n                 new_pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n                 new_fitness = np.array([func(x) for x in new_pop])\n                 self.evals += new_pop.shape[0]\n                 self.pop = new_pop\n                 self.fitness = new_fitness\n                 self.age = np.zeros(self.pop_size, dtype=int)\n            \n\n            self.best_fitness_history.append(self.f_opt)\n            self.pop_sizes.append(self.pop_size)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 32, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "67d74f75-3c4c-4446-8648-54741b7b3e8b", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a simplified aging mechanism to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, ortho_groups=5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            ortho_groups (int): Number of groups for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.ortho_groups = ortho_groups\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Simplified Aging Mechanism: Random mutation if old\n            if self.age[i] > self.age_limit:\n                mutated_pop[i] = func.bounds.lb + np.random.rand(self.dim) * (func.bounds.ub - func.bounds.lb)\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on a simplified approach.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-5:])  # Shorter history\n            self.F = np.clip(self.F + 0.2 * (success_rate - 0.5), 0.1, 1.0)  # Simplified adaptation\n            self.CR = np.clip(self.CR + 0.2 * (success_rate - 0.5), 0.1, 1.0)  # Simplified adaptation\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"\n        Performs orthogonal learning to improve population diversity.\n        Divides the dimensions into groups and optimizes each group.\n        \"\"\"\n        group_size = self.dim // self.ortho_groups\n        for g in range(self.ortho_groups):\n            indices = list(range(g * group_size, (g + 1) * group_size))\n            if g == self.ortho_groups - 1:\n                indices = list(range(g * group_size, self.dim)) # Last group takes the remaining indices\n\n            # Select two random individuals\n            idx1, idx2 = np.random.choice(self.pop_size, 2, replace=False)\n            x1 = self.pop[idx1].copy()\n            x2 = self.pop[idx2].copy()\n            \n            # Create orthogonal array (example: L9 array for 3 factors, 3 levels each)\n            # In a real implementation, the selection of the OA should depend on the group size\n            oa = np.array([[0, 0, 0], [0, 1, 1], [0, 2, 2], [1, 0, 1], [1, 1, 2], [1, 2, 0], [2, 0, 2], [2, 1, 0], [2, 2, 1]])\n\n            for row in oa:\n                new_vector = self.pop[idx1].copy()\n                for i, col in enumerate(indices):\n                    # Map the level (0, 1, 2) to a value between x1[col] and x2[col]\n                    level = row[i % 3] #use modulus in case indices size > 3\n                    new_vector[col] = x1[col] + level / 2.0 * (x2[col] - x1[col])  # 3 levels (0, 0.5, 1)\n\n                # Clip the new vector to respect bounds\n                new_vector = np.clip(new_vector, func.bounds.lb, func.bounds.ub)\n\n                # Evaluate and update if better\n                new_fitness = func(new_vector)\n                self.evals += 1\n\n                if new_fitness < self.fitness[idx1]:\n                    self.pop[idx1] = new_vector\n                    self.fitness[idx1] = new_fitness\n                    if new_fitness < self.f_opt:\n                        self.f_opt = new_fitness\n                        self.x_opt = new_vector\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            \n            # Orthogonal learning every few generations\n            if self.evals % (2 * self.pop_size) == 0:\n                self.orthogonal_learning(func)\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 33, "feedback": "In the code, line 71, in mutate, the following error occurred:\nNameError: name 'func' is not defined\nOn line: mutated_pop[i] = func.bounds.lb + np.random.rand(self.dim) * (func.bounds.ub - func.bounds.lb)", "error": "In the code, line 71, in mutate, the following error occurred:\nNameError: name 'func' is not defined\nOn line: mutated_pop[i] = func.bounds.lb + np.random.rand(self.dim) * (func.bounds.ub - func.bounds.lb)", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "985fca76-721a-4a90-9d05-1f8793129596", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a diversity-promoting mutation strategy.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components=5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning and diversity-promoting mutation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components to sample for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking, aging, and a diversity-promoting strategy.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.2 * random_direction  # Stronger random perturbation for exploration\n            else:\n                # Diversity-Promoting Mutation: Add a small random vector to encourage exploration\n                diversity_vector = np.random.normal(0, 0.01, size=self.dim)  # Small Gaussian noise\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + diversity_vector\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def orthogonal_learning(self, func, pop):\n        \"\"\"Performs orthogonal learning to improve population diversity and convergence.\"\"\"\n        for i in range(self.pop_size):\n            # Randomly select components for orthogonal learning\n            selected_indices = np.random.choice(self.dim, size=self.orthogonal_components, replace=False)\n\n            # Generate orthogonal array (simplified for demonstration)\n            levels = 3  # Example: 3 levels for each component\n            orthogonal_array = np.array([[-1, -1], [-1, 1], [1, -1], [1, 1]])  # Simplified OA(4, 2, 2)\n\n            # Create candidate solutions based on orthogonal array\n            candidate_solutions = np.zeros((len(orthogonal_array), self.dim))\n            for j in range(len(orthogonal_array)):\n                candidate_solutions[j, :] = pop[i, :].copy()\n                for k, idx in enumerate(selected_indices):\n                    # Map orthogonal array values to the search space\n                    level_value = func.bounds.lb + (func.bounds.ub - func.bounds.lb) * (orthogonal_array[j][k % orthogonal_array.shape[1]] + 1) / 2\n                    candidate_solutions[j, idx] = level_value\n\n            # Evaluate candidate solutions\n            candidate_fitness = np.array([func(x) for x in candidate_solutions])\n            self.evals += len(candidate_solutions)\n\n            # Select the best solution\n            best_index = np.argmin(candidate_fitness)\n            if candidate_fitness[best_index] < self.fitness[i]:\n                pop[i, :] = candidate_solutions[best_index, :]\n                self.fitness[i] = candidate_fitness[best_index]\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            # Apply orthogonal learning\n            self.orthogonal_learning(func, self.pop)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 34, "feedback": "In the code, line 1025, in numpy.random.mtrand.RandomState.choice, the following error occurred:\nValueError: Cannot take a larger sample than population when 'replace=False'", "error": "In the code, line 1025, in numpy.random.mtrand.RandomState.choice, the following error occurred:\nValueError: Cannot take a larger sample than population when 'replace=False'", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "248185c3-603c-428f-99fb-a79ce641774f", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a more robust adaptation mechanism using both sigmoid and historical best information for parameter control.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, ortho_num=10):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning, enhanced parameter adaptation, and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            ortho_num (int): Number of samples for orthogonal learning\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.ortho_num = ortho_num\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n        self.best_F = F\n        self.best_CR = CR\n        self.best_fitness_history = []\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.best_fitness_history.append(self.f_opt)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n        self.best_fitness_history.append(self.f_opt)\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid and historical best performance.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Combine sigmoid output with historical best information\n            fitness_improvement = 0\n            if len(self.best_fitness_history) > 1:\n                fitness_improvement = self.best_fitness_history[-2] - self.best_fitness_history[-1] #Previous - current\n\n            # Adjust F and CR based on both sigmoid and fitness improvement\n            self.F = 0.1 + 0.8 * sigmoid_output + 0.1 * np.clip(fitness_improvement, 0, 1)  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.8 * sigmoid_output + 0.1 * np.clip(fitness_improvement, 0, 1)  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n            # Update best F and CR\n            if self.best_fitness_history[-1] == np.min(self.best_fitness_history):\n                self.best_F = self.F\n                self.best_CR = self.CR\n\n    def orthogonal_learning(self, func):\n        \"\"\"Perform orthogonal learning to improve the population.\"\"\"\n        for i in range(self.pop_size):\n            # Select design parameters (dimensions) for orthogonal design\n            selected_dims = np.random.choice(self.dim, size=min(self.dim, 3), replace=False)  # Choose up to 3 dims\n\n            # Create an orthogonal array (L_25(5^6) for example)\n            levels = 3  # define levels, you can use 3, 4, or 5.\n            design = self.create_orthogonal_array(levels, len(selected_dims))\n            if design is None:\n              continue\n\n            # Generate new candidate solutions based on the orthogonal array\n            candidates = np.zeros((design.shape[0], self.dim))\n            for j in range(design.shape[0]):\n                candidate = self.pop[i].copy()\n                for k, dim_index in enumerate(selected_dims):\n                    # Map the level in the orthogonal array to a value within the bounds\n                    lb = func.bounds.lb[dim_index] if isinstance(func.bounds.lb, np.ndarray) else func.bounds.lb\n                    ub = func.bounds.ub[dim_index] if isinstance(func.bounds.ub, np.ndarray) else func.bounds.ub\n                    candidate[dim_index] = lb + (ub - lb) * design[j, k] / (levels - 1) # Map to bounds\n                candidates[j] = candidate\n\n            # Evaluate the candidate solutions\n            candidate_fitness = np.array([func(x) for x in candidates])\n            self.evals += design.shape[0]\n\n            # Select the best candidate\n            best_candidate_index = np.argmin(candidate_fitness)\n            if candidate_fitness[best_candidate_index] < self.fitness[i]:\n                self.pop[i] = candidates[best_candidate_index]\n                self.fitness[i] = candidate_fitness[best_candidate_index]\n                self.age[i] = 0\n\n                if self.fitness[i] < self.f_opt:\n                    self.f_opt = self.fitness[i]\n                    self.x_opt = self.pop[i]\n                    self.best_fitness_history.append(self.f_opt)\n\n    def create_orthogonal_array(self, levels, factors):\n        \"\"\"Creates a basic orthogonal array.  Limited to levels 3, 4, 5 for factors <= 6\"\"\"\n        if levels == 3:\n            if factors <= 2: return np.array([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]])\n            elif factors <= 4: return np.array([[0, 0, 0, 0], [0, 1, 1, 1], [0, 2, 2, 2], [1, 0, 1, 2], [1, 1, 2, 0], [1, 2, 0, 1], [2, 0, 2, 1], [2, 1, 0, 2], [2, 2, 1, 0]])\n            else: return None\n\n        elif levels == 4:\n            if factors <= 2: return np.array([[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [1, 2], [1, 3], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 1], [3, 2], [3, 3]])\n            else: return None\n\n        elif levels == 5:\n            if factors <= 6: return np.array([[0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1], [0, 2, 2, 2, 2, 2], [0, 3, 3, 3, 3, 3], [0, 4, 4, 4, 4, 4], [1, 0, 1, 2, 3, 4], [1, 1, 0, 3, 4, 2], [1, 2, 3, 4, 2, 0], [1, 3, 4, 2, 0, 3], [1, 4, 2, 0, 3, 1], [2, 0, 2, 4, 1, 3], [2, 1, 3, 2, 0, 4], [2, 2, 4, 1, 3, 0], [2, 3, 1, 0, 4, 2], [2, 4, 0, 3, 2, 1], [3, 0, 3, 1, 4, 2], [3, 1, 4, 0, 2, 3], [3, 2, 1, 3, 0, 4], [3, 3, 0, 4, 3, 1], [3, 4, 2, 1, 1, 0], [4, 0, 4, 3, 2, 1], [4, 1, 2, 4, 1, 0], [4, 2, 0, 1, 0, 3], [4, 3, 3, 2, 1, 4], [4, 4, 1, 0, 4, 2]])\n            else: return None\n        else: return None\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 35, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "0504c359-5b3c-4364-b63a-3a7b551b829e", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a dynamic population size reduction mechanism to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=100, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, ortho_groups=5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and dynamic population size.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Initial population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            ortho_groups (int): Number of groups for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.initial_pop_size = pop_size  # Store initial population size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.ortho_groups = ortho_groups  # Number of groups for orthogonal learning\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.reduction_factor = 0.01  # Population reduction factor\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to generate new candidate solutions.\"\"\"\n        num_groups = min(self.ortho_groups, self.dim)  # Ensure number of groups doesn't exceed dimension\n        group_size = self.dim // num_groups\n        remaining = self.dim % num_groups\n\n        for k in range(num_groups):\n            indices = list(range(k * group_size, (k + 1) * group_size))\n            if k < remaining:\n                indices.append(num_groups * group_size + k)\n\n            # Select the best and worst individuals in the current population\n            best_index = np.argmin(self.fitness)\n            worst_index = np.argmax(self.fitness)\n            best_individual = self.pop[best_index, indices]\n            worst_individual = self.pop[worst_index, indices]\n\n            # Generate new candidate solutions using orthogonal array design (L9 array is common)\n            # Here we are using a simplified version\n            new_points = np.linspace(best_individual, worst_individual, 5) # Create 5 points between best and worst\n\n            for point in new_points:\n                candidate = self.pop[np.random.randint(self.pop_size)].copy() #create new candidate individual\n                candidate[indices] = point  # Update only selected dimensions\n\n                # Boundary Handling: Clip values to remain within bounds\n                candidate = np.clip(candidate, func.bounds.lb, func.bounds.ub)\n                fitness = func(candidate)\n                self.evals += 1\n\n                if fitness < self.f_opt:\n                    self.f_opt = fitness\n                    self.x_opt = candidate\n\n                #Replace a randomly selected member if the candidate is better\n                rand_index = np.random.randint(self.pop_size)\n                if fitness < self.fitness[rand_index]:\n                    self.pop[rand_index] = candidate\n                    self.fitness[rand_index] = fitness\n                    self.age[rand_index] = 0  # Reset age\n    \n    def reduce_population_size(self):\n        \"\"\"Dynamically reduces population size based on stagnation.\"\"\"\n        if len(self.success_history) > 20 and np.mean(self.success_history[-20:]) < 0.1:\n            reduction = int(self.initial_pop_size * self.reduction_factor)\n            if reduction > 0 and self.pop_size > 10: # Limit pop size\n                indices_to_remove = np.argsort(self.fitness)[-reduction:]  # Remove worst individuals\n                self.pop = np.delete(self.pop, indices_to_remove, axis=0)\n                self.fitness = np.delete(self.fitness, indices_to_remove)\n                self.age = np.delete(self.age, indices_to_remove)\n                self.pop_size -= reduction\n                print(f\"Population reduced to {self.pop_size}\") # Inform about reduction\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)\n            self.reduce_population_size()\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 36, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "3d8d32d8-5596-4a6c-bbed-3a2209ffcdfb", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a mirrored boundary handling strategy to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_component=0.1):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and mirrored boundary handling.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_component (float): Contribution factor for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_component = orthogonal_component\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking, aging and orthogonal learning.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction and use orthogonal learning\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + self.orthogonal_component * random_direction  # Add random perturbation with increased magnitude and orthogonal learning component\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def mirrored_bounds(self, x, lb, ub):\n        \"\"\"Handles boundary violations using a mirrored approach.\"\"\"\n        for i in range(len(x)):\n            if x[i] < lb:\n                x[i] = lb + (lb - x[i])  # Mirror around the lower bound\n            elif x[i] > ub:\n                x[i] = ub - (x[i] - ub)  # Mirror around the upper bound\n        return x\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Mirror values to remain within bounds\n            for i in range(self.pop_size):\n                mutated_pop[i] = self.mirrored_bounds(mutated_pop[i], func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Mirror values to remain within bounds\n            for i in range(self.pop_size):\n                crossed_pop[i] = self.mirrored_bounds(crossed_pop[i], func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 37, "feedback": "In the code, line 126, in mirrored_bounds, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: if x[i] < lb:", "error": "In the code, line 126, in mirrored_bounds, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: if x[i] < lb:", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "a199f81c-4566-4a69-a0ec-8d5de9094fac", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with Orthogonal Learning and a population diversity mechanism.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components=5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with Orthogonal Learning and diversity mechanism.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components used in orthogonal design.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.diversity_threshold = 0.01  # Threshold for population diversity\n        self.diversity_check_interval = 10 # Check diversity every n generations\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Applies orthogonal learning to enhance exploitation.\"\"\"\n        # Select the best individual\n        best_index = np.argmin(self.fitness)\n        best_individual = self.pop[best_index].copy()\n\n        # Randomly select dimensions for orthogonal design\n        selected_dims = np.random.choice(self.dim, size=min(self.orthogonal_components, self.dim), replace=False)\n\n        # Generate orthogonal array (L4 array for 2 levels and 3 factors or L9 array for 3 levels and 4 factors)\n        if len(selected_dims) <= 3:\n            orthogonal_array = np.array([\n                [-1, -1],\n                [ 1, -1],\n                [-1,  1],\n                [ 1,  1]\n            ])\n            num_combinations = 4\n\n        elif len(selected_dims) <= 4:\n            orthogonal_array = np.array([\n                [-1, -1, -1],\n                [ 1, -1, -1],\n                [-1,  1, -1],\n                [ 1,  1, -1],\n                [-1, -1,  1],\n                [ 1, -1,  1],\n                [-1,  1,  1],\n                [ 1,  1,  1],\n            ])\n            num_combinations = 8\n        else:\n            orthogonal_array = np.array([\n                [-1, -1, -1, -1, -1],\n                [ 1, -1, -1,  1, -1],\n                [-1,  1, -1,  1, -1],\n                [ 1,  1, -1, -1, -1],\n                [-1, -1,  1, -1,  1],\n                [ 1, -1,  1, -1,  1],\n                [-1,  1,  1, -1, -1],\n                [ 1,  1,  1,  1, -1],\n                [-1, -1, -1, -1, 1],\n                [ 1, -1, -1,  1, 1],\n            ])\n            num_combinations = 10\n\n\n        # Generate new candidate solutions based on orthogonal array\n        candidate_solutions = np.zeros((num_combinations, self.dim))\n        for i in range(num_combinations):\n            candidate_solution = best_individual.copy()\n            for j, dim_index in enumerate(selected_dims):\n                # Scale the orthogonal array values to the range of each dimension\n                lower_bound = func.bounds.lb[dim_index] if isinstance(func.bounds.lb, np.ndarray) else func.bounds.lb\n                upper_bound = func.bounds.ub[dim_index] if isinstance(func.bounds.ub, np.ndarray) else func.bounds.ub\n\n                candidate_solution[dim_index] = best_individual[dim_index] + 0.5 * (upper_bound - lower_bound) * orthogonal_array[i, j]\n                candidate_solution[dim_index] = np.clip(candidate_solution[dim_index], lower_bound, upper_bound)\n\n            candidate_solutions[i] = candidate_solution\n\n        # Evaluate candidate solutions\n        candidate_fitness = np.array([func(x) for x in candidate_solutions])\n        self.evals += num_combinations\n\n        # Select the best solution among candidates\n        best_candidate_index = np.argmin(candidate_fitness)\n        if candidate_fitness[best_candidate_index] < self.f_opt:\n            self.f_opt = candidate_fitness[best_candidate_index]\n            self.x_opt = candidate_solutions[best_candidate_index]\n            self.pop[best_index] = candidate_solutions[best_candidate_index]\n            self.fitness[best_index] = candidate_fitness[best_candidate_index]\n\n    def check_population_diversity(self):\n        \"\"\"Checks and maintains population diversity.\"\"\"\n        # Calculate the mean of the population\n        mean_pop = np.mean(self.pop, axis=0)\n\n        # Calculate the average distance of individuals from the mean\n        distances = np.linalg.norm(self.pop - mean_pop, axis=1)\n        avg_distance = np.mean(distances)\n\n        # If the average distance is below the threshold, increase diversity\n        if avg_distance < self.diversity_threshold:\n            self.increase_diversity()\n\n    def increase_diversity(self):\n        \"\"\"Increases population diversity by re-initializing a portion of the population.\"\"\"\n        num_to_reinitialize = int(0.2 * self.pop_size)  # Re-initialize 20% of the population\n        worst_indices = np.argsort(self.fitness)[-num_to_reinitialize:]  # Find worst individuals\n\n        # Re-initialize the worst individuals randomly within the bounds\n        for i in worst_indices:\n            self.pop[i] = np.random.uniform(self.pop[i].min(), self.pop[i].max(), size=self.dim)\n            # Ensure the re-initialized individuals are within the bounds\n            self.pop[i] = np.clip(self.pop[i], -5.0, 5.0)\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        generation = 0  # Track the number of generations\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n            # Apply orthogonal learning every few generations\n            if generation % 5 == 0:\n                self.orthogonal_learning(func)\n\n            # Check and maintain population diversity\n            if generation % self.diversity_check_interval == 0:\n                self.check_population_diversity()\n\n\n            generation += 1 #increment generation count\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 38, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "56cc282d-aa62-4e94-863f-43955f420322", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a modified mutation strategy promoting diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components=5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components to use in orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals (with replacement)\n            r1_idx = np.random.choice(top_indices)  # top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx)  # ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                # Modified Mutation: Blend with best individual\n                best_individual = self.pop[np.argmin(self.fitness)]\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * (best_individual - pop[i]) # Attraction to best\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2)))  # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"\n        Performs orthogonal learning to improve promising solutions.\n        \"\"\"\n        num_candidates = self.orthogonal_components + 1  # Number of candidate solutions\n        candidate_solutions = np.zeros((num_candidates, self.dim))\n\n        # Select best individual as a base\n        best_index = np.argmin(self.fitness)\n        base_solution = self.pop[best_index].copy()\n\n        # Generate orthogonal array (OA)\n        oa = self.generate_orthogonal_array(self.orthogonal_components)\n\n        # Create candidate solutions using OA\n        for i in range(self.orthogonal_components):\n            candidate_solutions[i] = base_solution.copy()\n            # Perturb each dimension based on OA\n            for j in range(self.dim):\n                # Simple perturbation based on OA values (-1 or 1)\n                candidate_solutions[i, j] += 0.05 * oa[i, j % oa.shape[1]]  # Scale the perturbation\n\n        # Add the base solution as the last candidate\n        candidate_solutions[-1] = base_solution\n\n        # Evaluate candidate solutions\n        candidate_fitness = np.array([func(x) for x in candidate_solutions])\n        self.evals += num_candidates\n\n        # Select the best solution among candidates\n        best_candidate_index = np.argmin(candidate_fitness)\n        if candidate_fitness[best_candidate_index] < self.f_opt:\n            self.f_opt = candidate_fitness[best_candidate_index]\n            self.x_opt = candidate_solutions[best_candidate_index].copy()\n\n            # Potentially replace a random individual in the population if the candidate is better\n            replace_index = np.random.randint(self.pop_size)\n            if candidate_fitness[best_candidate_index] < self.fitness[replace_index]:\n                self.pop[replace_index] = candidate_solutions[best_candidate_index].copy()\n                self.fitness[replace_index] = candidate_fitness[best_candidate_index]\n                self.age[replace_index] = 0  # Reset age\n\n\n    def generate_orthogonal_array(self, num_factors):\n      \"\"\"Generates a simple orthogonal array (L9) for orthogonal learning.\"\"\"\n      # A simple L9 orthogonal array (3 levels, up to 4 factors)\n      oa = np.array([\n          [-1, -1, -1],\n          [-1, 0, 1],\n          [-1, 1, 0],\n          [0, -1, 1],\n          [0, 0, 0],\n          [0, 1, -1],\n          [1, -1, 0],\n          [1, 0, -1],\n          [1, 1, 1]\n      ])\n      # Select the first num_factors columns\n      oa = oa[:num_factors, :]\n      return oa\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n            # Apply orthogonal learning every few generations\n            if self.evals % (5 * self.pop_size) == 0:\n                self.orthogonal_learning(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 39, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "d7b2c201-5681-4cb2-8f7c-53bb4361d0d6", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with archive, orthogonal crossover and a distance-based mutation factor adaptation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, archive_size=10):\n        \"\"\"\n        Self-Adaptive Differential Evolution with Archive, Orthogonal Crossover and Distance-Based Adaptation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            archive_size (int): Size of the archive.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.archive_size = archive_size\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.archive = []\n        self.archive_fitness = []\n        self.F = 0.5\n        self.CR = 0.9\n        self.F_history = []\n        self.CR_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n\n    def mutate(self, pop):\n        \"\"\"Performs the mutation operation.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x_r1, x_r2, x_r3 = pop[indices]\n            mutated_pop[i] = x_r1 + self.F * (x_r2 - x_r3)\n        return mutated_pop\n\n    def orthogonal_crossover(self, pop, mutated_pop):\n        \"\"\"Performs orthogonal crossover.\"\"\"\n        crossed_pop = np.copy(pop)\n        for i in range(self.pop_size):\n            num_changes = int(self.CR * self.dim)\n            indices = np.random.choice(self.dim, num_changes, replace=False)\n            crossed_pop[i, indices] = mutated_pop[i, indices]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation and updates archive.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                if len(self.archive) < self.archive_size:\n                    self.archive.append(self.pop[i].copy())\n                    self.archive_fitness.append(self.fitness[i])\n                elif self.fitness[i] > np.max(self.archive_fitness):\n                    max_index = np.argmax(self.archive_fitness)\n                    self.archive[max_index] = self.pop[i].copy()\n                    self.archive_fitness[max_index] = self.fitness[i]\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n            \"\"\"Adapts F and CR based on population diversity.\"\"\"\n            distances = []\n            for i in range(self.pop_size):\n                for j in range(i + 1, self.pop_size):\n                    distances.append(np.linalg.norm(self.pop[i] - self.pop[j]))\n\n            if distances:\n                mean_distance = np.mean(distances)\n                # Adaptation based on normalized mean distance\n                normalized_distance = mean_distance / (np.linalg.norm(func.bounds.ub - func.bounds.lb))  #Assuming box constraints.\n                self.F = np.clip(0.1 + 0.9 * normalized_distance, 0.1, 1.0)\n                self.CR = np.clip(0.1 + 0.9 * (1 - normalized_distance), 0.1, 1.0)\n                self.F_history.append(self.F)\n                self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            mutated_pop = self.mutate(self.pop)\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)  # Boundary handling\n            crossed_pop = self.orthogonal_crossover(self.pop, mutated_pop)\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)  # Boundary handling\n            self.selection(func, crossed_pop)\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 40, "feedback": "In the code, line 90, in adapt_parameters, the following error occurred:\nNameError: name 'func' is not defined\nOn line: normalized_distance = mean_distance / (np.linalg.norm(func.bounds.ub - func.bounds.lb))  #Assuming box constraints.", "error": "In the code, line 90, in adapt_parameters, the following error occurred:\nNameError: name 'func' is not defined\nOn line: normalized_distance = mean_distance / (np.linalg.norm(func.bounds.ub - func.bounds.lb))  #Assuming box constraints.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "a9f564dd-d7ce-426b-9fa3-e24dea0efa65", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a Cauchy mutation to enhance exploration and exploitation.", "code": "import numpy as np\nfrom scipy.stats import cauchy\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_learning_rate=0.1):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and Cauchy mutation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_learning_rate (float): Learning rate for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_learning_rate = orthogonal_learning_rate\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging with Cauchy mutation.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction + Cauchy Noise\n            if self.age[i] > self.age_limit:\n                cauchy_noise = cauchy.rvs(loc=0, scale=0.1, size=self.dim)  # Cauchy mutation\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + cauchy_noise # Add Cauchy noise\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def orthogonal_learning(self, pop, func):\n        \"\"\"Performs orthogonal learning.\"\"\"\n        for i in range(self.pop_size):\n            # Select two random individuals\n            r1, r2 = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = pop[r1], pop[r2]\n\n            # Generate a new candidate solution using orthogonal array design\n            candidate = (x1 + x2) / 2 + self.orthogonal_learning_rate * (x1 - x2) * np.random.uniform(-1, 1, self.dim)\n            candidate = np.clip(candidate, func.bounds.lb, func.bounds.ub)  # Clip to bounds\n            \n            fitness_candidate = func(candidate)\n            self.evals += 1\n            \n            # Update the individual if the candidate is better\n            if fitness_candidate < self.fitness[i]:\n                pop[i] = candidate\n                self.fitness[i] = fitness_candidate\n                self.age[i] = 0\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Orthogonal Learning\n            self.orthogonal_learning(self.pop, func)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 41, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "31baf2e0-f7d0-4e2d-864b-9b6a16724ad6", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a success-history based parameter adaptation, designed to accelerate convergence and maintain diversity.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components=5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def orthogonal_learning(self, func, pop):\n        \"\"\"Performs orthogonal learning to generate new candidate solutions.\"\"\"\n        num_candidates = self.orthogonal_components\n        candidates = np.zeros((self.pop_size, num_candidates, self.dim))\n\n        for i in range(self.pop_size):\n            # Generate orthogonal array (simplified for demonstration)\n            orthogonal_array = np.random.choice([-1, 1], size=(num_candidates, self.dim))\n\n            for j in range(num_candidates):\n                # Create a candidate solution based on orthogonal array and current individual\n                candidates[i, j] = pop[i] + 0.05 * orthogonal_array[j] # Small perturbation\n\n                # Clip values to remain within bounds\n                candidates[i, j] = np.clip(candidates[i, j], func.bounds.lb, func.bounds.ub)\n\n        # Evaluate candidate solutions\n        candidate_fitness = np.zeros((self.pop_size, num_candidates))\n        for i in range(self.pop_size):\n            for j in range(num_candidates):\n                candidate_fitness[i, j] = func(candidates[i, j])\n                self.evals += 1\n\n        # Select the best candidate for each individual\n        for i in range(self.pop_size):\n            best_candidate_index = np.argmin(candidate_fitness[i])\n            if candidate_fitness[i, best_candidate_index] < self.fitness[i]:\n                pop[i] = candidates[i, best_candidate_index]\n                self.fitness[i] = candidate_fitness[i, best_candidate_index]\n                self.age[i] = 0 # reset age\n\n        return pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            # Apply orthogonal learning\n            self.pop = self.orthogonal_learning(func, self.pop)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 42, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "055a0853-1fcb-4c0d-84f7-da588d8ca5a5", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a diversity-based restart mechanism to improve exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, restart_trigger=10):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and diversity-based restart.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            restart_trigger (int): Number of generations without improvement before restart.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.restart_trigger = restart_trigger\n        self.no_improvement_count = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.diversity_history = []\n\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n        self.diversity_history.append(self.calculate_diversity())\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        improved = False\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                improved = True\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n            self.no_improvement_count = 0 # Reset counter\n        else:\n            self.no_improvement_count += 1\n\n        return improved\n\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to generate promising candidate solutions.\"\"\"\n        num_samples = 5  # Number of candidate solutions to generate\n        candidates = np.zeros((num_samples, self.dim))\n\n        for k in range(num_samples):\n            # Randomly select two parents\n            parent1_idx, parent2_idx = np.random.choice(self.pop_size, 2, replace=False)\n            parent1, parent2 = self.pop[parent1_idx], self.pop[parent2_idx]\n\n            # Generate candidate solutions through orthogonal crossover\n            for j in range(self.dim):\n                candidates[k, j] = parent1[j] + np.random.rand() * (parent2[j] - parent1[j])\n\n            # Clip values to remain within bounds\n            candidates[k] = np.clip(candidates[k], func.bounds.lb, func.bounds.ub)\n\n        # Evaluate candidate solutions\n        candidate_fitness = np.array([func(x) for x in candidates])\n        self.evals += num_samples\n\n        # Replace the worst individual in the population with the best candidate\n        worst_index = np.argmax(self.fitness)\n        best_candidate_index = np.argmin(candidate_fitness)\n\n        if candidate_fitness[best_candidate_index] < self.fitness[worst_index]:\n            self.pop[worst_index] = candidates[best_candidate_index]\n            self.fitness[worst_index] = candidate_fitness[best_candidate_index]\n\n            if self.fitness[worst_index] < self.f_opt:\n                self.f_opt = self.fitness[worst_index]\n                self.x_opt = self.pop[worst_index]\n\n    def calculate_diversity(self):\n        \"\"\"Calculates the diversity of the population based on the average distance to the centroid.\"\"\"\n        centroid = np.mean(self.pop, axis=0)\n        distances = np.linalg.norm(self.pop - centroid, axis=1)\n        diversity = np.mean(distances)\n        return diversity\n\n    def restart_population(self, func):\n        \"\"\"Restarts the population if diversity is low or no improvement is observed.\"\"\"\n        print(\"Restarting population...\")\n        self.initialize_population(func) # Reinitialize population and fitness\n        self.no_improvement_count = 0 # Reset the counter\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            improved = self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)\n\n            self.diversity_history.append(self.calculate_diversity())\n\n            # Restart mechanism\n            if self.no_improvement_count >= self.restart_trigger:\n                    self.restart_population(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 43, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "d9e3a9f5-7675-435c-889e-a03b81052910", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with orthogonal learning and a simplified parameter adaptation mechanism for faster convergence.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, orthogonal_components = 5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with orthogonal learning and simplified parameter adaptation.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            orthogonal_components (int): Number of components for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.orthogonal_components = orthogonal_components\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.lb = None\n        self.ub = None\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.lb = func.bounds.lb\n        self.ub = func.bounds.ub\n        self.pop = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on a simplified success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-5:])  # Shorter memory for quicker adaptation\n\n            # Simplified adaptation: Adjust F and CR directly based on success rate\n            self.F = 0.5 * (1 + success_rate)  # F ranges around 0.5\n            self.CR = 0.5 + 0.4 * success_rate # CR ranges from 0.5 to 0.9\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning on the current population.\"\"\"\n        for i in range(self.pop_size):\n            index = np.random.choice(self.pop_size)\n            sample = self.pop[index].copy()\n            changes = np.random.uniform(-0.1*(self.ub - self.lb), 0.1*(self.ub-self.lb), self.orthogonal_components) #smaller perturbation range\n\n            for change in changes:\n                perturbed_sample = sample.copy()\n                idx = np.random.randint(self.dim)\n                perturbed_sample[idx] += change\n                perturbed_sample = np.clip(perturbed_sample, self.lb, self.ub) #boundary check\n\n                fitness = func(perturbed_sample)\n                self.evals+=1\n                if fitness < self.fitness[i]:\n                    self.pop[i] = perturbed_sample\n                    self.fitness[i] = fitness\n                    if fitness < self.f_opt:\n                        self.f_opt = fitness\n                        self.x_opt = perturbed_sample\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, self.lb, self.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, self.lb, self.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 44, "feedback": "In the code, line 784, in numpy.PyArray_MultiIterNew3, the following error occurred:\nValueError: shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (5,) and arg 1 with shape (2,).", "error": "In the code, line 784, in numpy.PyArray_MultiIterNew3, the following error occurred:\nValueError: shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (5,) and arg 1 with shape (2,).", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "eed53d79-fd8f-42de-a9e9-227593b6b5af", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal design to generate crossover points and adaptive population size.", "code": "import numpy as np\nfrom scipy.stats import norm\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size_init=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, pop_size_adapt=True):\n        \"\"\"\n        Self-Adaptive Differential Evolution with a novel mutation strategy, aging, orthogonal crossover, and adaptive population size.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size_init (int): Initial population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            pop_size_adapt (bool): Flag to enable adaptive population size.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size_init\n        self.pop_size_init = pop_size_init\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.pop_size_adapt = pop_size_adapt\n        self.generation = 0\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.pop_size_history = [] # Track pop size\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation using orthogonal design.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        orthogonal_matrix = self.generate_orthogonal_array(self.dim)\n\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if orthogonal_matrix[i % len(orthogonal_matrix), j]:  # Use modulo to cycle through matrix if pop_size > matrix rows\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def generate_orthogonal_array(self, n):\n       \"\"\"Generates a simple orthogonal array (L18) for crossover.\"\"\"\n       if n <= 2:  # Handle trivial cases\n           return np.array([[True, False], [False, True]])\n\n       if n <= 7:\n           return np.array([\n               [1, 1, 1, 1, 1, 1, 1],\n               [1, 1, 1, 2, 2, 2, 2],\n               [1, 2, 2, 1, 1, 2, 2],\n               [1, 2, 2, 2, 2, 1, 1],\n               [2, 1, 2, 1, 2, 1, 2],\n               [2, 1, 2, 2, 1, 2, 1],\n               [2, 2, 1, 1, 2, 2, 1],\n               [2, 2, 1, 2, 1, 1, 2],\n           ])[:n,:n]\n       elif n<=18:\n           return np.array([\n            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n            [1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2],\n            [1, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2],\n            [1, 2, 2, 2, 2, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 2],\n            [1, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2],\n            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1],\n            [2, 1, 2, 1, 2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2],\n            [2, 1, 2, 2, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 1],\n            [2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 2, 2],\n            [2, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2],\n            [2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 2, 2],\n            [2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2],\n            [2, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 2, 2],\n            [2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1],\n            [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2],\n            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1]\n        ])[:n,:n]\n\n       else:\n           raise ValueError(f\"No orthogonal array implemented for dimension {n}\")\n\n       # Convert 1/2 to boolean True/False\n       return orthogonal_matrix == 1\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def adapt_population_size(self):\n        \"\"\"Adapts the population size based on the success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-5:])  # Shorter window\n            if success_rate > 0.3:\n                self.pop_size = min(int(self.pop_size * 1.1), 2 * self.pop_size_init)  # Increase, but limit\n            elif success_rate < 0.1:\n                self.pop_size = max(int(self.pop_size * 0.9), self.pop_size_init // 2)  # Decrease, but limit\n\n            # Ensure population size is at least 2\n            self.pop_size = max(2, self.pop_size)\n\n            self.pop_size_history.append(self.pop_size)\n            # Resize population - reinitialize instead\n            self.age = np.zeros(self.pop_size, dtype=int)\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            self.generation += 1\n\n            if self.pop_size_adapt and self.generation % 5 == 0: # Adapt every 5 generations\n                 old_pop_size = self.pop_size\n                 self.adapt_population_size()\n                 if old_pop_size != self.pop_size:\n                    # Re-initialize population\n                    best_individual = self.x_opt # Preserve best\n                    self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n\n                    self.fitness = np.array([func(x) for x in self.pop])\n                    self.evals += self.pop_size - old_pop_size\n\n                    #Inject previous best\n                    best_index = np.argmin(self.fitness)\n\n                    self.pop[best_index] = best_individual\n                    self.fitness[best_index] = func(best_individual)\n                    self.evals += 1\n\n\n                    best_index = np.argmin(self.fitness)\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.pop[best_index]\n\n\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 45, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "98abe0e3-7275-4037-8622-2a954e96e5db", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism to escape local optima.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, restart_prob=0.01):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and a restart mechanism.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            restart_prob (float): Probability of restarting the population.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.restart_prob = restart_prob\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to generate a promising individual.\"\"\"\n        best_index = np.argmin(self.fitness)\n        best_individual = self.pop[best_index]\n        \n        # Sample orthogonal array (OA)\n        oa_size = 5  # Number of levels in OA\n        oa = self.create_orthogonal_array(oa_size)\n        \n        # Determine factor levels based on the best individual\n        levels = np.zeros((self.dim, oa_size))\n        for j in range(self.dim):\n            levels[j, :] = np.linspace(best_individual[j] - 0.5, best_individual[j] + 0.5, oa_size)\n\n        # Generate new individuals based on OA\n        new_individuals = np.zeros((oa.shape[0], self.dim))\n        for i in range(oa.shape[0]):\n            for j in range(self.dim):\n                new_individuals[i, j] = levels[j, oa[i, j]]\n\n        # Evaluate the new individuals\n        new_fitness = np.array([func(x) for x in new_individuals])\n        self.evals += oa.shape[0]\n\n        # Select the best individual from orthogonal learning\n        best_oa_index = np.argmin(new_fitness)\n        if new_fitness[best_oa_index] < self.f_opt:\n            self.f_opt = new_fitness[best_oa_index]\n            self.x_opt = new_individuals[best_oa_index]\n            self.pop[np.argmax(self.fitness)] = self.x_opt # Replace worst individual with best OA individual\n            self.fitness[np.argmax(self.fitness)] = self.f_opt\n            \n    def create_orthogonal_array(self, levels):\n        \"\"\"\n        Creates a small orthogonal array (example for levels=5, dim=6).\n        For higher dimensions, use a library or precomputed OA.\n        \"\"\"\n        if levels == 5:\n            oa = np.array([\n                [0, 0, 0, 0, 0, 0],\n                [0, 1, 1, 1, 1, 1],\n                [0, 2, 2, 2, 2, 2],\n                [0, 3, 3, 3, 3, 3],\n                [0, 4, 4, 4, 4, 4],\n                [1, 0, 1, 2, 3, 4],\n                [1, 1, 0, 3, 4, 2],\n                [1, 2, 3, 4, 0, 1],\n                [1, 3, 4, 2, 1, 0],\n                [1, 4, 2, 0, 4, 3],\n                [2, 0, 2, 4, 1, 3],\n                [2, 1, 3, 1, 0, 4],\n                [2, 2, 4, 0, 3, 1],\n                [2, 3, 1, 3, 4, 0],\n                [2, 4, 0, 2, 1, 2],\n                [3, 0, 3, 1, 4, 2],\n                [3, 1, 2, 0, 1, 3],\n                [3, 2, 1, 4, 2, 0],\n                [3, 3, 0, 2, 3, 4],\n                [3, 4, 4, 3, 0, 1],\n                [4, 0, 4, 3, 2, 1],\n                [4, 1, 4, 3, 2, 1],\n                [4, 2, 0, 1, 4, 3],\n                [4, 3, 2, 4, 0, 1],\n                [4, 4, 1, 2, 3, 0]\n            ])\n            return oa[:, :min(self.dim, 6)] # Use only required dimensions\n        else:\n            raise ValueError(\"Orthogonal array for levels != 5 is not implemented.\")\n\n\n    def restart_population(self, func):\n        \"\"\"Restarts the population randomly.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            # Restart mechanism\n            if np.random.rand() < self.restart_prob:\n                self.restart_population(func)\n\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Orthogonal learning\n            if self.evals + self.dim < self.budget:\n                self.orthogonal_learning(func)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 46, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "b6cb6e3e-1ea0-4b01-871d-acbc9e4a35fd", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with a novel mutation strategy incorporating information from both top-ranked and randomly selected individuals, along with an aging mechanism to promote exploration and a mirroring boundary handling method.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50):\n        \"\"\"\n        Self-Adaptive Differential Evolution with a novel mutation strategy and aging.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n                \n                #Update best solution\n                if new_fitness[i] < self.f_opt:\n                  self.f_opt = new_fitness[i]\n                  self.x_opt = crossed_pop[i]\n\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate and diversity.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def boundary_handling(self, pop, lb, ub):\n        \"\"\"Handles boundaries by mirroring.\"\"\"\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if pop[i, j] < lb:\n                    pop[i, j] = lb + (lb - pop[i, j])  # Mirroring\n                    if pop[i,j] > ub:\n                        pop[i,j] = ub  #Keep inside bounds\n                elif pop[i, j] > ub:\n                    pop[i, j] = ub - (pop[i, j] - ub)  # Mirroring\n                    if pop[i,j] < lb:\n                        pop[i,j] = lb #Keep inside bounds\n        return pop\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Mirroring\n            mutated_pop = self.boundary_handling(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Mirroring\n            crossed_pop = self.boundary_handling(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            improved_count = np.sum(self.fitness < old_fitness)\n            success_rate = improved_count / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 47, "feedback": "In the code, line 127, in boundary_handling, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: if pop[i, j] < lb:", "error": "In the code, line 127, in boundary_handling, the following error occurred:\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nOn line: if pop[i, j] < lb:", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "0b409623-3888-4aa5-8cb2-00ee3b144328", "fitness": "-inf", "name": "EnhancedSelfAdaptiveDE", "description": "Enhanced Self-Adaptive Differential Evolution with a new parameter adaptation mechanism based on the distribution of fitness improvements and orthogonal learning.", "code": "import numpy as np\n\nclass EnhancedSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, ortho_group_size=5):\n        \"\"\"\n        Enhanced Self-Adaptive Differential Evolution with a novel mutation strategy, aging, and orthogonal learning.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            ortho_group_size (int): size of group for orthogonal learning.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.ortho_group_size = ortho_group_size\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n        self.delta_fitness_history = []\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        delta_fitness = self.fitness - new_fitness\n\n        for i in range(self.pop_size):\n            if new_fitness[i] < self.fitness[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n                delta_fitness[i] = 0 #no improvement\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n        return delta_fitness\n\n    def adapt_parameters(self, delta_fitness):\n        \"\"\"Adapts F and CR based on distribution of fitness improvements and orthogonal learning.\"\"\"\n\n        # Adaptive F and CR based on fitness improvement distribution\n        positive_delta = delta_fitness[delta_fitness > 0]\n\n        if len(positive_delta) > 0:\n            mean_improvement = np.mean(positive_delta)\n            std_improvement = np.std(positive_delta)\n\n            # Adjust F and CR based on the distribution\n            self.F = np.clip(self.F * (1 + 0.2 * (mean_improvement / (std_improvement + 1e-8))), 0.1, 1.0)\n            self.CR = np.clip(self.CR * (1 - 0.1 * (std_improvement / (mean_improvement + 1e-8))), 0.1, 1.0)\n\n        self.F_history.append(self.F)\n        self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning on a subset of the population.\"\"\"\n        indices = np.random.choice(self.pop_size, size=self.ortho_group_size, replace=False)\n        group = self.pop[indices]\n\n        # Generate an orthogonal array (simplified example)\n        oa = np.array([[ -1, -1],\n                       [  1, -1],\n                       [ -1,  1],\n                       [  1,  1]])\n\n        # Iterate through each individual in the orthogonal group\n        for i, idx in enumerate(indices):\n            best_fitness = self.fitness[idx]\n            best_solution = self.pop[idx].copy()\n\n            # Iterate through each test point in the orthogonal array\n            for j in range(oa.shape[0]):\n                new_solution = self.pop[idx].copy()\n                # Modify only two randomly selected dimensions\n                dims_to_modify = np.random.choice(self.dim, size=2, replace=False)\n                new_solution[dims_to_modify[0]] += 0.05 * oa[j, 0] * (func.bounds.ub - func.bounds.lb)\n                new_solution[dims_to_modify[1]] += 0.05 * oa[j, 1] * (func.bounds.ub - func.bounds.lb)\n                new_solution = np.clip(new_solution, func.bounds.lb, func.bounds.ub)\n\n                new_fitness = func(new_solution)\n                self.evals += 1\n\n                if new_fitness < best_fitness:\n                    best_fitness = new_fitness\n                    best_solution = new_solution.copy()\n\n                    if new_fitness < self.f_opt:\n                        self.f_opt = new_fitness\n                        self.x_opt = new_solution.copy()\n\n            # Replace the individual with the best solution found through orthogonal learning\n            self.pop[idx] = best_solution\n            self.fitness[idx] = best_fitness\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            delta_fitness = self.selection(func, crossed_pop)\n\n            self.adapt_parameters(delta_fitness)\n\n            if self.evals < self.budget - self.ortho_group_size * 4:\n              self.orthogonal_learning(func)\n\n        return self.f_opt, self.x_opt", "configspace": "", "generation": 48, "feedback": "In the code, line 151, in orthogonal_learning, the following error occurred:\nValueError: setting an array element with a sequence.\nOn line: new_solution[dims_to_modify[0]] += 0.05 * oa[j, 0] * (func.bounds.ub - func.bounds.lb)", "error": "In the code, line 151, in orthogonal_learning, the following error occurred:\nValueError: setting an array element with a sequence.\nOn line: new_solution[dims_to_modify[0]] += 0.05 * oa[j, 0] * (func.bounds.ub - func.bounds.lb)", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
{"id": "737070f2-00e9-4107-aae2-e4c728146b1a", "fitness": "-inf", "name": "NovelSelfAdaptiveDE", "description": "Self-Adaptive Differential Evolution with orthogonal learning and dynamic population size adjustment for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass NovelSelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=50, F=0.5, CR=0.9, rank_ratio=0.2, age_limit=50, ortho_groups=5):\n        \"\"\"\n        Self-Adaptive Differential Evolution with orthogonal learning and dynamic population size.\n\n        Args:\n            budget (int): Maximum number of function evaluations.\n            dim (int): Dimensionality of the problem.\n            pop_size (int): Initial population size.\n            F (float): Initial scaling factor.\n            CR (float): Initial crossover rate.\n            rank_ratio (float): Ratio of top individuals to consider for ranking.\n            age_limit (int): Maximum age of an individual before forced mutation.\n            ortho_groups (int): Number of orthogonal learning groups.\n        \"\"\"\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.rank_ratio = rank_ratio\n        self.pop = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.evals = 0\n        self.age = None  # Age of each individual\n        self.age_limit = age_limit\n        self.ortho_groups = ortho_groups\n\n        self.F_history = []\n        self.CR_history = []\n        self.success_history = []\n\n        self.pop_size_history = [pop_size] # Track pop size\n        self.min_pop_size = 10 # Minimum allowed population size\n\n    def initialize_population(self, func):\n        \"\"\"Initializes the population randomly within the bounds.\"\"\"\n        self.pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.pop])\n        self.evals += self.pop_size\n\n        best_index = np.argmin(self.fitness)\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)\n\n    def mutate(self, pop, F):\n        \"\"\"Performs the mutation operation using ranking and aging.\"\"\"\n        mutated_pop = np.zeros_like(pop)\n        num_ranked = int(self.rank_ratio * self.pop_size)\n\n        for i in range(self.pop_size):\n            # Ranking-based selection\n            ranked_indices = np.argsort(self.fitness)\n            top_indices = ranked_indices[:num_ranked]\n\n            # Ensure i is not selected for r1 or r2 or r3\n            available_indices = [idx for idx in range(self.pop_size) if idx != i]\n\n            # Choose base vector from top ranked individuals with replacement\n            r1_idx = np.random.choice(top_indices) #top individual\n            r2_idx = np.random.choice(available_indices)\n            available_indices.remove(r2_idx) #ensure r3 is different\n            r3_idx = np.random.choice(available_indices)\n\n            x_r1, x_r2, x_r3 = pop[r1_idx], pop[r2_idx], pop[r3_idx]\n\n            # Aging Mechanism: If an individual is old, force mutation towards a random direction\n            if self.age[i] > self.age_limit:\n                random_direction = np.random.uniform(-1, 1, size=self.dim)\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3) + 0.1 * random_direction  # Add random perturbation\n            else:\n                mutated_pop[i] = x_r1 + F * (x_r2 - x_r3)\n\n        return mutated_pop\n\n    def crossover(self, pop, mutated_pop, CR):\n        \"\"\"Performs the crossover operation.\"\"\"\n        crossed_pop = np.zeros_like(pop)\n        for i in range(self.pop_size):\n            for j in range(self.dim):\n                if np.random.rand() < CR or j == np.random.randint(self.dim):\n                    crossed_pop[i, j] = mutated_pop[i, j]\n                else:\n                    crossed_pop[i, j] = pop[i, j]\n        return crossed_pop\n\n    def selection(self, func, crossed_pop):\n        \"\"\"Performs the selection operation.\"\"\"\n        new_fitness = np.array([func(x) for x in crossed_pop])\n        self.evals += self.pop_size\n\n        improved = new_fitness < self.fitness\n        for i in range(self.pop_size):\n            if improved[i]:\n                self.pop[i] = crossed_pop[i]\n                self.fitness[i] = new_fitness[i]\n                self.age[i] = 0  # Reset age if improved\n            else:\n                self.age[i] += 1  # Increment age if not improved\n\n        best_index = np.argmin(self.fitness)\n        if self.fitness[best_index] < self.f_opt:\n            self.f_opt = self.fitness[best_index]\n            self.x_opt = self.pop[best_index]\n\n        return improved  # Return a boolean array of improved individuals\n\n    def adapt_parameters(self):\n        \"\"\"Adapts F and CR based on sigmoid of success rate.\"\"\"\n        if self.success_history:\n            success_rate = np.mean(self.success_history[-10:])  # Consider last 10 generations\n            # Sigmoid function to map success rate to F/CR adjustments\n            sigmoid_output = 1 / (1 + np.exp(-10 * (success_rate - 0.2))) # Shifted sigmoid\n\n            # Use sigmoid output to adjust F and CR more smoothly and robustly\n            self.F = 0.1 + 0.9 * sigmoid_output  # F ranges from 0.1 to 1.0\n            self.CR = 0.1 + 0.9 * sigmoid_output  # CR ranges from 0.1 to 1.0\n\n            self.F = np.clip(self.F, 0.1, 1.0)\n            self.CR = np.clip(self.CR, 0.1, 1.0)\n            self.F_history.append(self.F)\n            self.CR_history.append(self.CR)\n\n    def orthogonal_learning(self, func):\n        \"\"\"Performs orthogonal learning to generate new candidate solutions.\"\"\"\n        num_groups = min(self.ortho_groups, self.dim)  # Ensure group size does not exceed dimension\n        group_size = self.dim // num_groups\n\n        for i in range(num_groups):\n            # Select a group of dimensions\n            dims = np.arange(i * group_size, (i + 1) * group_size)\n            if i == num_groups -1:\n              dims = np.arange(i * group_size, self.dim) # handle edge case\n\n            # Create an orthogonal array (OA)\n            oa = self.generate_orthogonal_array(group_size)  # Simplified OA generation\n            oa_size = oa.shape[0]\n\n            # Select the best individual from the current population\n            best_individual = self.x_opt\n\n            # Generate new candidate solutions based on OA\n            for j in range(oa_size):\n                candidate = best_individual.copy()\n                for k in range(len(dims)):\n                    # Map OA levels to the search space for each dimension\n                    lb = func.bounds.lb[dims[k]] if isinstance(func.bounds.lb, np.ndarray) else func.bounds.lb\n                    ub = func.bounds.ub[dims[k]] if isinstance(func.bounds.ub, np.ndarray) else func.bounds.ub\n\n                    candidate[dims[k]] = lb + (ub - lb) * oa[j, k]\n\n                # Evaluate the new candidate solution\n                fitness = func(candidate)\n                self.evals += 1\n\n                # Update the best solution if the candidate is better\n                if fitness < self.f_opt:\n                    self.f_opt = fitness\n                    self.x_opt = candidate.copy()\n                    \n                    # Update population as well (to ensure diversity)\n                    worst_index = np.argmax(self.fitness)\n                    self.pop[worst_index] = candidate.copy()\n                    self.fitness[worst_index] = fitness\n                    self.age[worst_index] = 0\n\n                    # Recalculate best index after population update\n                    best_index = np.argmin(self.fitness)\n                    self.f_opt = self.fitness[best_index]\n                    self.x_opt = self.pop[best_index]\n\n                if self.evals >= self.budget:\n                    return # Exit early if budget is reached\n\n    def generate_orthogonal_array(self, num_factors):\n        \"\"\"Generates a simple 2-level orthogonal array.\"\"\"\n        # This is a simplified OA generation.  For higher dimensions and levels,\n        # more sophisticated methods would be necessary (e.g., using libraries\n        # or pre-computed OAs). This basic OA offers some diversity.\n        oa_size = 2 ** int(np.ceil(np.log2(num_factors + 1)))\n        oa = np.zeros((oa_size, num_factors))\n        for i in range(num_factors):\n            level_changes = 2 ** (int(np.ceil(np.log2(num_factors + 1))) - i - 1)\n            for j in range(oa_size):\n                oa[j, i] = (j // level_changes) % 2\n        return oa[:(num_factors + 1), :]\n\n    def adjust_population_size(self):\n        \"\"\"Dynamically adjusts population size based on recent success.\"\"\"\n        if len(self.success_history) > 10:\n            recent_success = np.mean(self.success_history[-10:])\n            if recent_success > 0.3 and self.pop_size < 2 * self.min_pop_size:  # Increase population\n                self.pop_size = min(self.pop_size + 5, 2 * self.min_pop_size)  # Gradual increase, avoid explosion\n            elif recent_success < 0.1 and self.pop_size > self.min_pop_size:  # Decrease population\n                self.pop_size = max(self.pop_size - 5, self.min_pop_size) # Gradual decrease\n\n            self.pop_size_history.append(self.pop_size) # track\n\n    def __call__(self, func):\n        \"\"\"Optimizes the given function.\"\"\"\n        self.initialize_population(func)\n\n        while self.evals < self.budget:\n            F = self.F\n            CR = self.CR\n\n            mutated_pop = self.mutate(self.pop, F)\n\n            # Boundary Handling: Clip values to remain within bounds\n            mutated_pop = np.clip(mutated_pop, func.bounds.lb, func.bounds.ub)\n\n            crossed_pop = self.crossover(self.pop, mutated_pop, CR)\n\n            # Boundary Handling: Clip values to remain within bounds\n            crossed_pop = np.clip(crossed_pop, func.bounds.lb, func.bounds.ub)\n\n            old_fitness = self.fitness.copy()  # keep old fitness for success rate calculation\n            improved = self.selection(func, crossed_pop)\n\n            # Track Success Rate\n            success_rate = np.sum(improved) / self.pop_size\n            self.success_history.append(success_rate)\n\n            self.adapt_parameters()\n            self.orthogonal_learning(func)  # Apply orthogonal learning\n            self.adjust_population_size() # Dynamic Population Size\n\n            # Resize population if changed\n            if self.pop_size != self.pop.shape[0]:\n              self.resize_population(func)\n\n        return self.f_opt, self.x_opt\n\n    def resize_population(self, func):\n        \"\"\"Resizes the population, preserving the best individuals.\"\"\"\n        new_pop = np.random.uniform(func.bounds.lb, func.bounds.ub, size=(self.pop_size, self.dim))\n        new_fitness = np.array([func(x) for x in new_pop])\n        self.evals += self.pop_size\n\n        # Sort current population by fitness\n        sorted_indices = np.argsort(self.fitness)\n\n        # Transfer best individuals to the new population\n        num_transfer = min(self.pop.shape[0], self.pop_size) # transfer as many as possible\n        new_pop[:num_transfer] = self.pop[sorted_indices[:num_transfer]]\n        new_fitness[:num_transfer] = self.fitness[sorted_indices[:num_transfer]]\n\n        self.pop = new_pop\n        self.fitness = new_fitness\n\n        best_index = np.argmin(self.fitness) #update\n        self.f_opt = self.fitness[best_index]\n        self.x_opt = self.pop[best_index]\n        self.age = np.zeros(self.pop_size, dtype=int)", "configspace": "", "generation": 49, "feedback": "Evaluation timed out after 300 seconds.", "error": "Evaluation timed out after 300 seconds.", "parent_ids": ["5defeb4c-b380-4295-a314-429ddc70a304"], "operator": null, "metadata": {}, "task_prompt": "\nYou are a Python developer working on a new optimization algorithm.\nYour task is to develop a novel heuristic optimization algorithm for continuous optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the Many Affine BBOB test suite of noiseless functions. Your task is to write the optimization algorithm in Python code. \nEach of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nThe code should contain an `__init__(self, budget, dim)` function with optional additional arguments and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. \n"}
