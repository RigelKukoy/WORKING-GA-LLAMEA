{
     "id": "851876e6-2776-4345-966a-ecfb1e540613",
     "parents": [
          "a6cbfb4a-5af3-42e5-a269-1d6fe0d9dc2d"
     ],
     "algorithm": "A self-adaptive Differential Evolution algorithm with a smaller population size, aggressive parameter adaptation, and periodic local search using Nelder-Mead simplex method.}\n# Code: \n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\nclass SelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.success_F = []\n        self.success_CR = []\n        self.archive = []\n        self.archive_size = 10\n        self.adaptation_rate = 0.1\n        self.local_search_interval = budget // 20\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n    def mutate(self, pop, i):\n        idxs = [idx for idx in range(self.pop_size) if idx != i]\n        a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n        return np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n    def crossover(self, mutant, target):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def update_parameters(self):\n        if self.success_F:\n            mean_F = np.mean(self.success_F)\n            mean_CR = np.mean(self.success_CR)\n\n            self.F = (1 - self.adaptation_rate) * self.F + self.adaptation_rate * mean_F\n            self.CR = (1 - self.adaptation_rate) * self.CR + self.adaptation_rate * mean_CR\n        else:\n            self.F = 0.5\n            self.CR = 0.9\n        \n        self.F = np.clip(self.F, 0.1, 0.9)\n        self.CR = np.clip(self.CR, 0.1, 0.9)\n        self.success_F = []\n        self.success_CR = []\n\n    def local_search(self, func):\n        for i in range(self.pop_size):\n            if self.evals >= self.budget:\n                break\n            x0 = self.population[i].copy()\n            bounds = [(self.lb, self.ub)] * self.dim\n            res = minimize(func, x0, method='Nelder-Mead', bounds=bounds, options={'maxfev': min(self.budget - self.evals, 50)",
     "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass SelfAdaptiveDE:\n    def __init__(self, budget=10000, dim=10, pop_size=20, F=0.5, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = None\n        self.fitness = None\n        self.f_opt = np.inf\n        self.x_opt = None\n        self.success_F = []\n        self.success_CR = []\n        self.archive = []\n        self.archive_size = 10\n        self.adaptation_rate = 0.1\n        self.local_search_interval = budget // 20\n\n    def initialize_population(self, func):\n        self.population = np.random.uniform(self.lb, self.ub, size=(self.pop_size, self.dim))\n        self.fitness = np.array([func(x) for x in self.population])\n        self.evals = self.pop_size\n        self.f_opt = np.min(self.fitness)\n        self.x_opt = self.population[np.argmin(self.fitness)]\n\n    def mutate(self, pop, i):\n        idxs = [idx for idx in range(self.pop_size) if idx != i]\n        a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n        return np.clip(a + self.F * (b - c), self.lb, self.ub)\n\n    def crossover(self, mutant, target):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def update_parameters(self):\n        if self.success_F:\n            mean_F = np.mean(self.success_F)\n            mean_CR = np.mean(self.success_CR)\n\n            self.F = (1 - self.adaptation_rate) * self.F + self.adaptation_rate * mean_F\n            self.CR = (1 - self.adaptation_rate) * self.CR + self.adaptation_rate * mean_CR\n        else:\n            self.F = 0.5\n            self.CR = 0.9\n        \n        self.F = np.clip(self.F, 0.1, 0.9)\n        self.CR = np.clip(self.CR, 0.1, 0.9)\n        self.success_F = []\n        self.success_CR = []\n\n    def local_search(self, func):\n        for i in range(self.pop_size):\n            if self.evals >= self.budget:\n                break\n            x0 = self.population[i].copy()\n            bounds = [(self.lb, self.ub)] * self.dim\n            res = minimize(func, x0, method='Nelder-Mead', bounds=bounds, options={'maxfev': min(self.budget - self.evals, 50)})\n\n            if res.fun < self.fitness[i]:\n                self.population[i] = res.x\n                self.fitness[i] = res.fun\n                self.evals += res.nfev\n\n                if res.fun < self.f_opt:\n                    self.f_opt = res.fun\n                    self.x_opt = res.x\n\n    def __call__(self, func):\n        self.initialize_population(func)\n        iter_count = 0\n        while self.evals < self.budget:\n            iter_count += 1\n\n            if iter_count % self.local_search_interval == 0:\n                self.local_search(func)\n\n            new_population = []\n            new_fitness = []\n\n            for i in range(self.pop_size):\n                if self.evals >= self.budget:\n                  new_population.append(self.population[i])\n                  new_fitness.append(self.fitness[i])\n                  continue\n\n                mutant = self.mutate(self.population, i)\n                trial = self.crossover(mutant, self.population[i])\n                f = func(trial)\n                self.evals += 1\n\n                if f < self.fitness[i]:\n                    new_population.append(trial)\n                    new_fitness.append(f)\n\n                    self.success_F.append(self.F)\n                    self.success_CR.append(self.CR)\n\n                    if f < self.f_opt:\n                        self.f_opt = f\n                        self.x_opt = trial\n                else:\n                    new_population.append(self.population[i])\n                    new_fitness.append(self.fitness[i])\n            \n            self.population = np.array(new_population)\n            self.fitness = np.array(new_fitness)\n            self.update_parameters()\n        return self.f_opt, self.x_opt",
     "objective": -0.76561,
     "other_inf": null
}